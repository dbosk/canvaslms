\chapter{Utility functions for CLI commands}

This chapter provides utility functions that are shared across multiple CLI commands to avoid code duplication.

We outline the module:
<<[[utils.py]]>>=
import arrow
import datetime

<<functions>>
@

\section{Testing the utility functions}
\label{sec:utils:testing}

The utilities handle time formatting and date parsing---operations that must work correctly across timezones and handle various input formats gracefully.
Tests are distributed throughout this chapter, appearing immediately after each implementation to verify correctness.

\subsection{Testing philosophy}

When testing time utilities, we apply variation theory:
\begin{description}
\item[Invariant] The conversion logic and timezone handling
\item[Variant] Input types (None, string, datetime, arrow), timezones, formats
\end{description}

Testing time-dependent code is tricky: tests must produce consistent results regardless of when they run.
We use [[freezegun]] to freeze time at a known point, making our tests deterministic.

\subsection{Test structure}

We define the test file structure early, but the actual test implementations appear after their corresponding functionality.

One subtlety: this module imports the standard library [[datetime]] module as
[[datetime]]. If our tests also import the [[datetime]] class with the same
name, then a subsequent [[from canvaslms.cli.utils import *]] would overwrite
that symbol (because the star import brings in the module-level [[datetime]]
binding from [[canvaslms.cli.utils]]).

To avoid this name shadowing, we import the class as [[dt_datetime]] and use
that name in the few tests that construct concrete datetime objects.

<<test [[utils.py]]>>=
"""
Tests for canvaslms.cli.utils time formatting functions.

These tests demonstrate expected behavior using variation theory:
we vary inputs (None, different formats, timezones) while the
conversion logic stays constant.
"""
import pytest
from datetime import datetime as dt_datetime, timezone
from freezegun import freeze_time
import arrow

from canvaslms.cli.utils import *

<<test functions>>
@

\section{Time formatting utilities}

Function to format ISO timestamps in local time for better readability.
<<functions>>=
def format_local_time(iso_ts):
  """
  Formats an ISO timestamp string in local time (YYYY-MM-DD HH:mm).
  """
  if not iso_ts:
    return "N/A"
  try:
    return arrow.get(iso_ts).to('local').format('YYYY-MM-DD HH:mm')
  except Exception:
    return iso_ts
@

\subsection{Verifying [[format_local_time]]}

Now let's verify this function handles edge cases and formats timestamps correctly.
The [[format_local_time()]] function is used to display timestamps to users.

We use [[freeze_time]] to create a deterministic test environment---this is \emph{crucial} for time-dependent tests, as tests would otherwise pass or fail depending on the system timezone and current time.

<<test functions>>=
class TestFormatLocalTime:
    """Test format_local_time() with various inputs"""

    def test_none_returns_na(self):
        """None input should return 'N/A' for display"""
        assert format_local_time(None) == "N/A"

    def test_empty_string_returns_na(self):
        """Empty string should return 'N/A'"""
        assert format_local_time("") == "N/A"

    @freeze_time("2023-12-15 14:30:00")
    def test_formats_utc_to_local(self):
        """
        Should convert UTC timestamp to local time.

        Frozen at 2023-12-15 14:30 CET (UTC+1, Europe/Stockholm winter time).
        Input: 2023-12-15 13:30:00 UTC
        Expected output in local time (CET): 2023-12-15 14:30
        """
        utc_time = "2023-12-15T13:30:00Z"
        result = format_local_time(utc_time)
        assert result == "2023-12-15 14:30"

    def test_invalid_format_returns_original(self):
        """If parsing fails, return the original string"""
        invalid = "not-a-timestamp"
        result = format_local_time(invalid)
        assert result == invalid
@

Function to format timestamps in Canvas-compatible UTC format ending with 'Z'.
<<functions>>=
def format_canvas_time(iso_ts):
  """
  Parses an ISO timestamp string as local time and converts to UTC ISO format.
  Returns Canvas-compatible UTC timestamp ending with 'Z'.
  """
  if not iso_ts:
    return None
  try:
    if isinstance(iso_ts, datetime.datetime):
      # Already a datetime object
      dt = iso_ts
      if dt.tzinfo is None:
        dt = dt.replace(tzinfo=arrow.now().tzinfo)
      return dt.astimezone(datetime.timezone.utc).isoformat().replace("+00:00",
                                                                      "Z")
    elif isinstance(iso_ts, datetime.date):
      # Date only, interpret as start of day in local timezone
      dt = datetime.datetime.combine(iso_ts, datetime.time(0, 0))
      dt = dt.replace(tzinfo=arrow.now().tzinfo)
      return dt.astimezone(datetime.timezone.utc).isoformat().replace("+00:00",
                                                                      "Z")
    elif isinstance(iso_ts, arrow.Arrow):
      return iso_ts.to('utc').isoformat().replace("+00:00", "Z")
    elif isinstance(iso_ts, str):
      return arrow.get(iso_ts,
                       tzinfo='local').to('utc').isoformat().replace("+00:00",
                                                                     "Z")
  except Exception as e:
    raise ValueError(f"Invalid date/time format: {e}")
@

\subsection{Verifying [[format_canvas_time]]}

Now let's verify this more complex function handles multiple input types correctly.
The [[format_canvas_time()]] function accepts datetime objects, arrow objects, date objects, and strings, converting them all to Canvas's expected UTC format ending with 'Z'.

This is a perfect example of variation theory in action---we test the same conversion logic with many different input types, maintaining the invariant: always produce Canvas-compatible UTC timestamps ending with 'Z'.

<<test functions>>=
class TestFormatCanvasTime:
    """Test format_canvas_time() with various input types"""

    def test_none_returns_none(self):
        """None input should return None"""
        assert format_canvas_time(None) == None

    def test_empty_string_returns_none(self):
        """Empty string should return None"""
        assert format_canvas_time("") == None

    @freeze_time("2023-12-15 10:00:00")
    def test_datetime_with_timezone(self):
        """
        Should convert timezone-aware datetime to Canvas UTC format.

        Input: datetime with timezone
        Output: UTC ISO string ending with 'Z'
        """
        dt = dt_datetime(2023, 12, 15, 10, 0, 0, tzinfo=timezone.utc)
        result = format_canvas_time(dt)
        assert result.endswith("Z")
        assert "2023-12-15" in result

    @freeze_time("2023-12-15 10:00:00")
    def test_datetime_without_timezone_assumes_local(self):
        """
        Naive datetime (no timezone) should be interpreted as local time.

        Frozen at 2023-12-15 10:00 CET (UTC+1, Europe/Stockholm winter time).
        Input: naive datetime 2023-12-15 10:00
        Output: Should interpret as local (CET) and convert to UTC
        """
        dt = dt_datetime(2023, 12, 15, 10, 0, 0)
        result = format_canvas_time(dt)
        # Should be converted from CET to UTC (subtract 1 hour)
        assert result.endswith("Z")
        assert "2023-12-15T09:00:00Z" == result

    @freeze_time("2023-12-15 10:00:00")
    def test_date_object_start_of_day(self):
        """
        Date (not datetime) should be interpreted as start of day in local time.

        Frozen at 2023-12-15 10:00 CET (UTC+1, Europe/Stockholm winter time).
        Input: date(2023, 12, 15)
        Output: 2023-12-15 00:00 local â†’ converted to UTC
        """
        from datetime import date
        d = date(2023, 12, 15)
        result = format_canvas_time(d)
        assert result.endswith("Z")
        # Start of day in CET (00:00) = 23:00 UTC previous day
        assert "2023-12-14T23:00:00Z" == result

    def test_arrow_object(self):
        """Arrow objects should be converted to Canvas format"""
        arr = arrow.get("2023-12-15T10:00:00Z")
        result = format_canvas_time(arr)
        assert result == "2023-12-15T10:00:00Z"

    @freeze_time("2023-12-15 10:00:00")
    def test_string_iso_format(self):
        """ISO string should be parsed as local time and converted to UTC"""
        iso_str = "2023-12-15T10:00:00"
        result = format_canvas_time(iso_str)
        assert result.endswith("Z")
        # 10:00 local (CET) = 09:00 UTC
        assert "2023-12-15T09:00:00Z" == result

    def test_invalid_string_raises_error(self):
        """Invalid date string should raise ValueError"""
        with pytest.raises(ValueError, match="Invalid date/time format"):
            format_canvas_time("not a date")
@

\section{Timezone detection utilities}

When parsing user-provided datetime strings, we face a challenge: distinguishing
between strings with explicit timezone information and those without.

Consider these examples using variation theory's contrast pattern:
\begin{description}
\item[Naive strings] [[2023-12-15 14:30]] --- no timezone marker, should be
  interpreted as local time
\item[Explicit UTC] [[2023-12-15T14:30:00Z]] --- the [[Z]] suffix explicitly
  marks UTC
\item[Explicit offset] [[2023-12-15T14:30:00+02:00]] --- explicit timezone
  offset
\end{description}

Arrow's [[tzinfo]] parameter forces timezone interpretation on all strings.
If we always use [[tzinfo='local']], explicit timezone strings would be
incorrectly reinterpreted as local time, breaking their intended meaning.

We need to detect explicit timezone markers first, then conditionally apply
local timezone interpretation only for naive strings.

<<functions>>=
def _has_explicit_timezone(date_str):
  """
  Detect if a string contains explicit timezone information.

  Markers indicating explicit timezone:
  - 'Z' suffix (UTC)
  - '+' or '-' with time offset (e.g., +02:00, -05:00)

  Returns True if timezone is explicit, False for naive strings.
  """
  if not isinstance(date_str, str):
    return False
  # Check for Z suffix indicating UTC
  if 'Z' in date_str:
    return True
  # Check for timezone offset (+/- with time)
  # Date strings like YYYY-MM-DD have 2 hyphens
  # Timezone offsets add more: YYYY-MM-DDTHH:MM:SS-05:00 has 3+ hyphens
  if '+' in date_str or date_str.count('-') > 2:
    return True
  return False
@

\section{Date parsing utilities}

Function to parse date strings in various human-readable formats and convert
them to Canvas-compatible UTC timestamps. This function supports multiple
common date formats and provides flexible parsing for user input.

The key challenge is timezone interpretation. Users expect naive datetime
strings like [[2023-12-15 14:30]] to be interpreted as local time. However,
strings with explicit timezone markers like [[2023-12-15T14:30:00Z]] should
preserve their timezone.

We use conditional timezone interpretation:
\begin{enumerate}
\item Check if the string contains explicit timezone markers
\item For naive strings, apply [[tzinfo='local']] to interpret as local time
\item For explicit timezone strings, use default parsing to preserve the timezone
\item For format-specific parsing, always apply [[tzinfo='local']] since those
      formats never include timezone information
\end{enumerate}

<<functions>>=
def parse_date(date_str):
  """Parse a date string using arrow with multiple format attempts

  Returns a Canvas-compatible UTC timestamp ending with 'Z'
  """
  if not date_str or date_str.lower() in ['none', 'clear', '']:
    return None

  # Try common formats in order of preference
  formats = [
    None,  # ISO format (arrow's default)
    'YYYY-MM-DD HH:mm:ss',
    'YYYY-MM-DD HH:mm',
    'YYYY-MM-DD',
    'MMM DD YYYY',
    'MMMM DD, YYYY',
    'MM/DD/YYYY',
    'DD/MM/YYYY',
    'YYYY/MM/DD'
  ]

  for fmt in formats:
    try:
      if fmt is None:
        # Check if string has explicit timezone info
        if _has_explicit_timezone(date_str):
          # Preserve explicit timezone
          return format_canvas_time(arrow.get(date_str))
        else:
          # Interpret naive string as local time
          return format_canvas_time(arrow.get(date_str, tzinfo='local'))
      else:
        # Format-specific strings never include timezone, always use local
        return format_canvas_time(arrow.get(date_str, fmt, tzinfo='local'))
    except (arrow.parser.ParserError, ValueError):
      continue

  # If nothing worked, try natural language parsing
  try:
    import dateutil.parser
    parsed_date = dateutil.parser.parse(date_str)
    # Use format_canvas_time for Canvas compatibility
    return format_canvas_time(arrow.get(parsed_date))
  except (ImportError, ValueError):
    pass

  raise ValueError(f"Could not parse date: '{date_str}'. "
                  "Try formats like: YYYY-MM-DD, YYYY-MM-DD HH:MM, or MM/DD/YYYY")
@

\subsection{Verifying [[parse_date]]}

Now let's verify this user-facing function handles multiple date formats correctly.
The [[parse_date()]] function accepts human-readable date strings in many formats and converts them to Canvas format.
This function is particularly important because it processes user input from the command line.

We test multiple formats to ensure flexibility for users, who can input dates in many common formats and have them all converted to the standard Canvas format ending with 'Z'.

<<test functions>>=
class TestParseDate:
    """Test parse_date() with various date formats"""

    def test_none_returns_none(self):
        """None should return None"""
        assert parse_date(None) == None

    def test_none_string_returns_none(self):
        """String 'none' should return None"""
        assert parse_date("none") == None
        assert parse_date("None") == None

    def test_clear_returns_none(self):
        """String 'clear' should return None (for clearing dates)"""
        assert parse_date("clear") == None

    def test_empty_string_returns_none(self):
        """Empty string should return None"""
        assert parse_date("") == None

    @freeze_time("2023-12-15 10:00:00")
    def test_iso_format(self):
        """ISO format: YYYY-MM-DD"""
        result = parse_date("2023-12-15")
        assert result.endswith("Z")
        # Date interpreted as start of day local time (CET = UTC+1)
        # 2023-12-15 00:00 CET = 2023-12-14 23:00 UTC
        assert "2023-12-14T23:00:00Z" == result

    @freeze_time("2023-12-15 10:00:00")
    def test_iso_with_time(self):
        """ISO format with time: YYYY-MM-DD HH:mm"""
        result = parse_date("2023-12-15 14:30")
        assert result.endswith("Z")
        # Time interpreted as local time (CET = UTC+1)
        # 2023-12-15 14:30 CET = 2023-12-15 13:30 UTC
        assert "2023-12-15T13:30:00Z" == result

    @freeze_time("2023-12-15 10:00:00")
    def test_slash_format(self):
        """US format: MM/DD/YYYY"""
        result = parse_date("12/15/2023")
        assert result.endswith("Z")
        # Date interpreted as start of day local time (CET = UTC+1)
        # 2023-12-15 00:00 CET = 2023-12-14 23:00 UTC
        assert "2023-12-14T23:00:00Z" == result

    @freeze_time("2023-12-15 10:00:00")
    def test_month_name_format(self):
        """Month name format: Dec 15 2023"""
        result = parse_date("Dec 15 2023")
        assert result.endswith("Z")
        # Date interpreted as start of day local time (CET = UTC+1)
        # 2023-12-15 00:00 CET = 2023-12-14 23:00 UTC
        assert "2023-12-14T23:00:00Z" == result

    def test_invalid_format_raises_error(self):
        """Completely invalid string should raise ValueError"""
        with pytest.raises(ValueError, match="Could not parse date"):
            parse_date("not-a-valid-date-xyz123")
@

These tests verify that [[parse_date()]] provides a flexible interface, handling:
\begin{enumerate}
\item \textbf{Timezone bugs}: Code works across timezones using freezegun
\item \textbf{User input variety}: Many common date formats are accepted
\item \textbf{Edge cases}: None values, empty strings, special keywords
\item \textbf{Canvas compatibility}: All outputs end with 'Z' (UTC indicator)
\end{enumerate}