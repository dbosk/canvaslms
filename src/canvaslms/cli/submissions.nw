\chapter{The submissions related commands}

This chapter provides the subcommands [[submissions]], which lists the 
submissions of a given assignment, and the [[submission]] command, which 
handles an individual submission.

We outline the module:
<<submissions.py>>=
import canvaslms.cli.assignments as assignments
import canvaslms.cli.users as users
import canvaslms.hacks.canvasapi

import argparse
import csv
import pydoc
import pypandoc
import sys
import urllib.request

<<functions>>

def add_command(subp):
  """Adds the submissions and submission commands to argparse parser subp"""
  add_submissions_command(subp)
  add_submission_command(subp)

def add_submissions_command(subp):
  """Adds submissions command to argparse parser subp"""
  <<add submissions command to subp>>

def add_submission_command(subp):
  """Adds submission command to argparse parser subp"""
  <<add submission command to subp>>
@

\section{The [[submissions]] subcommand and its options}

We add the subparser for [[submissions]].
<<add submissions command to subp>>=
submissions_parser = subp.add_parser("submissions",
    help="Lists submissions of an assignment",
    description="Lists submissions of assignment(s). Output format: "
      "<Canvas-user-ID> <grade> <grade date>")
submissions_parser.set_defaults(func=submissions_command)
assignments.add_assignment_option(submissions_parser)
<<set up options for limiting by group or user>>
<<set up options for selecting type of submissions>>
@ Now, that [[submissions_command]] function must take three arguments: 
[[config]], [[canvas]] and [[args]].
It must also do the processing for the assignment options using 
[[process_assignment_option]].
<<functions>>=
def submissions_command(config, canvas, args):
  assignment_list = assignments.process_assignment_option(canvas, args)
  <<get submissions and print them>>
@

\subsection{Limit by group}

By default, we show all submission in the course.
However, sometimes we're only interested in a group of students.
<<set up options for limiting by group or user>>=
users.add_user_or_group_option(submissions_parser)
@

\subsection{Selecting the type of submissions}

We also want to be able to filter out the type of submissions.
For now, we focus on all or ungraded.
<<set up options for selecting type of submissions>>=
submissions_parser.add_argument("-U", "--ungraded", action="store_true",
  help="Show only ungraded submissions.")
@ We don't need to do any particular processing for this option.


\subsection{Get and print the list of submissions}

We then simply call the appropriate list-submissions function with the 
[[assignments_list]] object as a parameter.
If any of the group options are set, we filter out the submissions to only 
include submissions by the users in the groups.
Then we will print the most useful attributes of a submission, which the 
[[format_submission_short]] will return preformatted for us.
<<get submissions and print them>>=
if args.ungraded:
  submissions = list_ungraded_submissions(assignment_list)
else:
  submissions = list_submissions(assignment_list)

if args.user or args.category or args.group:
  user_list = users.process_user_or_group_option(canvas, args)
  submissions = filter_submissions(submissions, user_list)

output = csv.writer(sys.stdout, delimiter=args.delimiter)

for submission in submissions:
  output.writerow(format_submission_short(submission))
@


\section{The [[submission]] subcommand and its options}

Here we provide a subcommand [[submission]] which deals with an individual 
submission.
<<add submission command to subp>>=
submission_parser = subp.add_parser("submission",
  help="Prints information about a submission",
  description="Prints data about matching submissions, "
    "including submission and grading time, any text-based attachments.")
submission_parser.set_defaults(func=submission_command)
add_submission_options(submission_parser)
@ We also need the corresponding function.
For now, we only print the most relevant data of a submission.
<<functions>>=
def submission_command(config, canvas, args):
  submission_list = process_submission_options(canvas, args)
  <<get and print the submission data>>
@

Then we can fetch the submission.
<<get and print the submission data>>=
for submission in submission_list:
  pydoc.pager(format_submission(submission, canvas))
@


\section{Selecting a submission on the command line}%
\label{submission-options}

We now provide a function to set up the command-line options to select a 
particular submission along with a function to process those options.
<<functions>>=
def add_submission_options(parser):
  try:
    assignments.add_assignment_option(parser)
  except argparse.ArgumentError:
    pass

  try:
    users.add_user_or_group_option(parser)
  except argparse.ArgumentError:
    pass

def process_submission_options(canvas, args):
  assignment_list = assignments.process_assignment_option(canvas, args)
  user_list = users.process_user_or_group_option(canvas, args)
  return list(filter_submissions(list_submissions(assignment_list), user_list))
@


\section{Producing a list of submissions}%
\label{list-submissions-function}

We provide the following functions:
\begin{itemize}
  \item [[list_submissions]], which returns all submissions;
  \item [[list_ungraded_submissions]], which returns all ungraded submissions.
\end{itemize}
We return the submissions for a list of assignments, since we can match several 
assignments with a regular expression (using [[filter_assignments]]).
<<functions>>=
def list_submissions(assignments, include=["submission_comments"]):
  for assignment in assignments:
    submissions = assignment.get_submissions(include=include)
    for submission in submissions:
      submission.assignment = assignment
      yield submission

def list_ungraded_submissions(assignments, include=["submisson_comments"]):
  for assignment in assignments:
    submissions = assignment.get_submissions(bucket="ungraded",
      include=include)
    for submission in submissions:
      if submission.submitted_at and (submission.graded_at is None or
          not submission.grade_matches_current_submission):
        submission.assignment = assignment
        yield submission
@


\section{Filtering a list of submissions}

We provide the function [[filter_submissions]] which filters out a subset of 
submissions from a list.

For each submission we check if it's user is in the desired user set.
(Note that since the list~[[user_list]], might contain duplicates, so we turn 
it into a set first.)
Once we've found the user, we don't need to search further, so we can break 
after the yield.
<<functions>>=
def filter_submissions(submission_list, user_list):
  user_list = set(user_list)

  for submission in submission_list:
    for user in user_list:
      if submission.user_id == user.id:
        submission.user = user
        yield submission
        break
@


\section{Printing a submission}

We provide two functions to print a submission.
One to print a short identifier and one to print the submission data.

We'll format the submission in short format.
The most useful data is the identifier, the grade and the date of grading.
<<functions>>=
def format_submission_short(submission):
  if submission.submitted_at:
    date = submission.submitted_at
  else:
    date = submission.graded_at
  return [submission.assignment.course.course_code, submission.assignment.name,
    submission.user_id, submission.user.name, submission.grade, date]
@

We provide the function [[format_submission]] to nicely format a submission.
It prints metadata, downloads any text attachments to include in the output.
It also uses the [[canvas]] object to resolve course, assignment and user IDs.
<<functions>>=
def format_submission(submission, canvas):
  """Formats submission for printing to stdout"""
  student = submission.assignment.course.get_user(submission.user_id)

  formatted_submission = f"""# Metadata

{submission.assignment.course.course_code} > {submission.assignment.name}

- Student: {student.name} ({student.login_id or None}, {submission.user_id})
- Submission ID: {submission.id}
- Submitted (graded): {submission.submitted_at} ({submission.graded_at})
- Grade: {submission.grade} ({submission.score})
- URL: {submission.preview_url}
"""

  try:
    if submission.submission_comments:
      formatted_submission += f"""

# Comments
"""

    for comment in submission.submission_comments:
      formatted_submission += f"""
{comment["author_name"]} ({comment["created_at"]}):

{comment["comment"]}
"""
  except AttributeError:
    pass

  formatted_submission += f"""

# Body

{submission.body}
"""

  try:
    for attachment in submission.attachments:
      if "text/" not in attachment["content-type"]:
        continue

      contents = urllib.request.urlopen(attachment["url"]).read().decode("utf-8")
      formatted_submission += f"""

## {attachment["filename"]}

```
{contents}
```
"""
  except AttributeError:
    pass

  return formatted_submission
@

