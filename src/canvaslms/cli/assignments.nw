\chapter{The assignments related commands}

This chapter provides the subcommands [[assignments]] and [[assignment]].

The [[assignments]] command lists the assignment groups and the assignments 
therein of a given course.

The [[assignment]] command lists information about a given assignment.


\section{Module outline}

We outline the module:
<<assignments.py>>=
import argparse
import canvasapi
import canvaslms.cli
import canvaslms.cli.courses as courses
import canvaslms.cli.modules as modules
import canvaslms.cli.utils
import canvaslms.hacks.canvasapi
import csv
import json
import os
import pypandoc
import re
import rich.console
import rich.markdown
import sys

<<functions>>

def add_command(subp):
  """Adds the subcommands assignments and assignment to argparse parser subp"""
  add_assignments_command(subp)
  add_assignment_command(subp)

def add_assignments_command(subp):
  """Adds the assignments subcommand to argparse parser subp"""
  <<add assignments command to subp>>

def add_assignment_command(subp):
  """Adds the assignment subcommand to argparse parser subp"""
  <<add assignment command to subp>>
@


\section{Selecting assignments on the command line}

We now provide two functions that sets up the options for selecting an 
assignment on the command line.
These are used by the [[assignment_command]] and [[assignments_command]] 
functions, but can also be used by other commands.

When we select assignments, we have the option to only select those assignments 
with ungraded submissions.
However, this option is not always relevant, so we provide a way to disable it.
But to select an assignment, we must first select a course.

If the [[required]] option is set, we want to make all (relevant) options 
required.
<<functions>>=
def add_assignment_option(parser, ungraded=True, required=False):
  try:
    courses.add_course_option(parser, required=required)
  except argparse.ArgumentError:
    pass

  <<set up options for selecting assignments>>

def process_assignment_option(canvas, args):
  course_list = courses.process_course_option(canvas, args)
  <<process options for selecting assignments to assignments list>>
  assignments_list = list(assignments_list)
  if not assignments_list:
    raise canvaslms.cli.EmptyListError("No assignments found matching the criteria")
  return assignments_list
@

As mentioned above, we want to be able to select only assignments with ungraded
submissions.
Other than that, we want to select assignments by assignment name, assignment
group that an assignment belongs to, or module that contains the assignment.

\subsection{Design: Combinable filters vs.\ mutually exclusive filters}

We provide three ways to filter assignments: by name ([[-a]]), by assignment
group ([[-A]]), and by module ([[-M]]).
An earlier design made these mutually exclusive---you could use only one at a
time.
However, this prevented useful queries like ``all lab assignments in Module 3''
or ``all quizzes in the graded assignment group.''

We now allow these filters to be \emph{combined} using AND logic.
This provides more expressive filtering while maintaining backward
compatibility.
For example:
\begin{itemize}
\item [[-a "Lab" -M "Module 1"]] returns assignments matching ``Lab'' that are
  \emph{also} in modules matching ``Module 1''
\item [[-a "Quiz" -A "Graded"]] returns quizzes that are \emph{also} in the
  ``Graded'' assignment group
\item [[-M "Week 1" -A "Homework"]] returns assignments in Week 1 modules that
  are \emph{also} in the Homework group
\end{itemize}

Since [[-a]] defaults to [[.*]] (match all assignment names), using [[-M]]
alone still works as before: it returns all assignments in the matching modules,
regardless of name.

However, when filters are \emph{required} (some commands need at least one
filter), we maintain mutual exclusion to avoid confusing users with too many
options.
This is a pragmatic choice: required filters are typically used in simpler
contexts where combination isn't needed.

In summary, we want the following options:
\begin{itemize}
\item [[-U]] will filter assignments that have ungraded submissions.
\item [[-a]] will take a regex for assignment names.
\item [[-A]] will take a regex for assignment groups.
  Then we can return all assignments in those assignment groups.
\item [[-M]] will take a regex for modules.
  Then we can return all assignments in those modules.
\end{itemize}
These regular expressions match either the name or the Canvas identifier.
This lets us add the following arguments.
Remember, we add only the ungraded option if that was requested.
Also, if we want the required version, we want to require either an assignment,
an assignment group, or a module to be specified.
<<set up options for selecting assignments>>=
if ungraded:
  parser.add_argument("-U", "--ungraded", action="store_true",
    help="Filter only assignments with ungraded submissions.")

<<add filter options: required or combinable>>
@

When filters are required, we maintain the mutually exclusive group to keep the
interface simple.
When filters are optional, we allow combination by adding them directly to the
parser (not to a mutually exclusive group).
<<add filter options: required or combinable>>=
if required:
  filter_group = parser.add_mutually_exclusive_group(required=True)
  filter_group.add_argument("-a", "--assignment",
    help="Regex matching assignment title or Canvas identifier")
  filter_group.add_argument("-A", "--assignment-group",
    help="Regex matching assignment group title or Canvas identifier")
  filter_group.add_argument("-M", "--module",
    help="Regex matching module title or Canvas identifier")
else:
  parser.add_argument("-a", "--assignment",
    required=False, default=".*",
    help="Regex matching assignment title or Canvas identifier, "
      "default: '.*'. Can be combined with -A and -M for AND filtering.")
  parser.add_argument("-A", "--assignment-group",
    required=False, default="",
    help="Regex matching assignment group title or Canvas identifier. "
      "Can be combined with -a and -M for AND filtering.")
  parser.add_argument("-M", "--module",
    required=False, default="",
    help="Regex matching module title or Canvas identifier. "
      "Can be combined with -a and -A for AND filtering.")
@

Now we iterate over the [[course_list]] to get to the assignment groups to then
filter out the assignments.

\subsection{Sequential filter application for AND logic}

To support combinable filters with AND logic, we apply filters \emph{sequentially}
rather than using mutually exclusive branches.
The algorithm is:
\begin{enumerate}
\item Start with all assignments matching the [[-a]] regex (defaults to [[.*]],
  so all assignments by name)
\item If [[-A]] is specified, filter the result to keep only assignments in
  matching assignment groups
\item If [[-M]] is specified, filter the result to keep only assignments in
  matching modules
\item Return the final filtered list
\end{enumerate}

This contrasts with the earlier mutually exclusive design, which used
[[if]]/[[elif]]/[[else]] to choose \emph{one} filtering path.
Now we chain filters, progressively narrowing the result set.

Each filter that takes a list of groups or modules (rather than a single group
or module) allows us to match assignments in \emph{any} of the matching groups
or modules.
For example, if [[-M "Module [12]"]] matches both Module 1 and Module 2, we
return assignments from either module---but they must still match the other
filters (assignment name and assignment group, if specified).

<<process options for selecting assignments to assignments list>>=
assignments_list = []

for course in course_list:
  <<get ungraded flag>>
  <<apply sequential filters to get filtered assignments>>
  assignments_list += filtered_assignments
@

We check if the [[ungraded]] flag is set, defaulting to [[False]] if the
attribute doesn't exist (some commands don't provide this option).
<<get ungraded flag>>=
try:
  ungraded = args.ungraded
except AttributeError:
  ungraded = False
@

We start by filtering assignments by name using the [[-a]] option.
Then, if assignment group or module filters are specified, we apply them
sequentially to progressively narrow the results.
<<apply sequential filters to get filtered assignments>>=
filtered_assignments = list(filter_assignments([course],
  args.assignment,
  ungraded=ungraded))

<<get filter options from args>>
<<apply assignment group filter if specified>>
<<apply module filter if specified>>
@

We extract the filter options from [[args]], defaulting to empty strings if the
attributes don't exist.
<<get filter options from args>>=
try:
  assignm_grp_regex = args.assignment_group
except AttributeError:
  assignm_grp_regex = ""

try:
  module_regex = args.module
except AttributeError:
  module_regex = ""
@

If an assignment group filter is specified, we filter the assignments to keep
only those in matching groups.
Note that we use [[filter_assignments_by_group_list]] which takes a list of
groups and returns assignments in \emph{any} of them.
<<apply assignment group filter if specified>>=
if assignm_grp_regex:
  assignment_groups = filter_assignment_groups(course, assignm_grp_regex)
  filtered_assignments = list(filter_assignments_by_group_list(
      assignment_groups, filtered_assignments))
@

Similarly, if a module filter is specified, we further filter the assignments.
<<apply module filter if specified>>=
if module_regex:
  course_modules = modules.filter_modules(course, module_regex)
  filtered_assignments = list(filter_assignments_by_module_list(
      course_modules, filtered_assignments))
@


\section{The [[assignments]] subcommand and its options}

We add the subparser for [[assignments]].
<<add assignments command to subp>>=
assignments_parser = subp.add_parser("assignments",
    help="Lists assignments of a course",
    description="Lists assignments of a course. "
      <<assignments help on output format>>)
assignments_parser.set_defaults(func=assignments_command)
add_assignment_option(assignments_parser)
@ Now, that [[assignments_command]] function must take three arguments: 
[[config]], [[canvas]] and [[args]].
We use [[process_assignment_option]] to parse the options that we added with 
the [[add_assignment_option]] function above.
<<functions>>=
def assignments_command(config, canvas, args):
  output = csv.writer(sys.stdout, delimiter=args.delimiter)
  assignment_list = process_assignment_option(canvas, args)
  
  <<write assignments by assignment group to output>>
@

We then simply get the filtered list from the processing of the assignment 
options, stored in [[assignment_list]] above.
Then we will print the most useful attributes.
<<assignments help on output format>>=
"Output, CSV-format: "
"<course> <assignment group> <assignment name> "
"<due date> <unlock at> <lock at>"
<<write assignments by assignment group to output>>=
for assignment in assignment_list:
  # Get assignment group name safely
  if hasattr(assignment, 'assignment_group') and assignment.assignment_group:
    group_name = assignment.assignment_group.name
  elif hasattr(assignment, 'assignment_group_id') and assignment.assignment_group_id:
    # Fallback: try to get group from course if available
    try:
      group = assignment.course.get_assignment_group(assignment.assignment_group_id)
      group_name = group.name
    except:
      group_name = f"Group {assignment.assignment_group_id}"
  else:
    group_name = "No Group"
    
  output.writerow([
    assignment.course.course_code,
    group_name,
    assignment.name,
    canvaslms.cli.utils.format_local_time(assignment.due_at),
    canvaslms.cli.utils.format_local_time(assignment.unlock_at),
    canvaslms.cli.utils.format_local_time(assignment.lock_at)
  ])
@


\section{Filter assignments and assignment groups of a course}

We want to filter out the assignment groups that match a regex.
<<functions>>=
def filter_assignment_groups(course, regex):
  """Returns all assignment groups of course whose name matches regex"""
  name = re.compile(regex)
  return filter(
    lambda group: name.search(group.name),
    course.get_assignment_groups())
@

We also want to filter out the assignments of a course that belong to a given
assignment group.
<<functions>>=
def filter_assignments_by_group(assignment_group, assignments):
  """Returns elements in assignments that are part of assignment_group"""
  for assignment in assignments:
    if assignment.assignment_group_id == assignment_group.id:
      assignment.assignment_group = assignment_group
      yield assignment
@

We need a variant that filters by a \emph{list} of assignment groups.
This is used for AND filtering: when [[-A]] matches multiple groups (via regex),
we want assignments in \emph{any} of those groups, as long as they also match
the other filters.

For example, if [[-A "Graded|Homework"]] matches both ``Graded'' and ``Homework''
groups, we return assignments from either group.
But if we also specify [[-a "Lab"]], we only return Lab assignments from those
groups.

The key difference from [[filter_assignments_by_group]] is that this function
takes a list of groups and builds a set of group IDs for efficient membership
testing.
<<functions>>=
def filter_assignments_by_group_list(assignment_groups, assignments):
  """Returns elements in assignments that belong to any of the assignment_groups"""
  group_ids = {group.id for group in assignment_groups}

  for assignment in assignments:
    if assignment.assignment_group_id in group_ids:
      for group in assignment_groups:
        if assignment.assignment_group_id == group.id:
          assignment.assignment_group = group
          break
      yield assignment
@


\section{The [[assignment]] subcommand and its options}

We add the subparser for [[assignment]].
We use the [[add_course_option]] and [[add_assignment_option]] to set up how 
to select (filter) the courses and assignments.
<<add assignment command to subp>>=
assignment_parser = subp.add_parser("assignment",
    help="Lists assignment details",
    description="Lists assignment details")
assignment_parser.set_defaults(func=assignment_command)
add_assignment_option(assignment_parser)
@ Now, that [[assignment_command]] function must take two arguments: [[canvas]] 
and [[args]].
We use [[process_course_option]] and [[process_assignment_option]] to parse 
the options that we added with the [[add_course_option]] and 
[[add_assignment_option]] functions above.
<<functions>>=
def assignment_command(config, canvas, args):
  console = rich.console.Console()

  assignment_list = process_assignment_option(canvas, args)
  for assignment in assignment_list:
    output = format_assignment(assignment)

    if sys.stdout.isatty():
      <<check if we should use styles>>
      with console.pager(styles=styles, links=True):
        console.print(rich.markdown.Markdown(output,
                                             code_theme="manni"))
    else:
      print(output)
@ Note that we use the theme [[manni]] for the code, as this works in both dark 
and light terminals.

\subsection{Check if we should use styles}

By default, [[rich.console.Console]] uses the [[pydoc.pager]], which uses the 
system pager (as determined by environment variables etc.).
The default usually can't handle colours, so [[rich]] doesn't use colours when 
paging.
We want to check if [[less -r]] or [[less -R]] is set as the pager, in that 
case we can use styles.
<<check if we should use styles>>=
pager = ""
if "MANPAGER" in os.environ:
  pager = os.environ["MANPAGER"]
elif "PAGER" in os.environ:
  pager = os.environ["PAGER"]

styles = False
if "less" in pager and ("-R" in pager or "-r" in pager):
  styles = True
@


\section{Formatting assignments}

Sometimes we want to format the contents of an assignment in the terminal.
The assignment contents given by Canvas is HTML, we want to pipe that through 
[[pandoc]] and convert it to markdown.
<<functions>>=
def format_assignment(assignment):
  """Returns an assignment formatted for the terminal"""
  text = f"""
<<format assignment metadata>>

"""

  if assignment.description:
    instruction = pypandoc.convert_text(
      assignment.description, "md", format="html")
    text += f"## Instruction\n\n{instruction}\n\n"
    <<try to add rubric>>
  else:
    <<try to add rubric>>
    text += f"## Assignment data\n\n```json\n{format_json(assignment)}\n```\n"

  return text
@

\subsection{Assignment metadata}

Now let's look at the metadata to add.
<<format assignment metadata>>=
# {assignment.name}

## Metadata

- Unlocks: {canvaslms.cli.utils.format_local_time(assignment.unlock_at) if assignment.unlock_at else None}
- Due:     {canvaslms.cli.utils.format_local_time(assignment.due_at) if assignment.due_at else None}
- Locks:   {canvaslms.cli.utils.format_local_time(assignment.lock_at) if assignment.lock_at else None}
- Ungraded submissions: {assignment.needs_grading_count}
- Submission type: {assignment.submission_types}
- URL: {assignment.html_url}
- Submissions: {assignment.submissions_download_url}
@

\subsection{Assignment rubric}

We want to format the rubric as well.
<<try to add rubric>>=
try:
  text += f"## Rubric\n\n{format_rubric(assignment.rubric)}\n\n"
except AttributeError:
  pass
@

We'll do this with [[format_rubric]].
It should output a markdown representation of the rubric.
<<functions>>=
def format_rubric(rubric):
  """
  Returns a markdown representation of the rubric
  """
  if not rubric:
    return "No rubric set."

  text = ""
  for criterion in rubric:
    text += f"- {criterion['description']}\n"
    text += f"  - Points: {criterion['points']}\n"
    text += f"  - Ratings: "
    text += "; ".join([
      f"{rating['description'].strip()} ({rating['points']})"
      for rating in criterion["ratings"]
    ]) + "\n"
    text += f"\n```\n{criterion['long_description']}\n```\n\n"

  return text
@

\subsection{Assignment data as raw JSON}

We also want to format the assignment data as JSON.
We must extract all attributes from the assignment object.
<<functions>>=
def format_json(assignment):
  """Returns a JSON representation of the assignment"""
  return json.dumps({
    key: str(value) for key, value in assignment.__dict__.items()
      if not key.startswith("_")
  }, indent=2)
@


\section{Producing a list of assignments}%
\label{list-assignments-function}

We provide the following functions:
\begin{itemize}
  \item [[list_assignments]], which returns all assignments;
  \item [[list_ungraded_assignments]], which returns all ungraded assignments;
  \item [[filter_assignments]], which returns all assignments whose title 
  matches a regular expression.
\end{itemize}
We return the assignments for a list of courses, since we can match several 
courses with a regular expression (using [[filter_courses]]).
<<functions>>=
def list_assignments(assignments_containers, ungraded=False):
  """Lists all assignments in all assignments containers (courses or 
  assignement groups)"""
  for container in assignments_containers:
    if isinstance(container, canvasapi.course.Course):
      course = container
    elif isinstance(container, canvasapi.assignment.AssignmentGroup):
      assignment_group = container
      course = assignment_group.course

    if ungraded:
      assignments = container.get_assignments(bucket="ungraded")
    else:
      assignments = container.get_assignments()

    for assignment in assignments:
      try:
        assignment.course = course
      except NameError:
        pass

      try:
        assignment.assignment_group = assignment_group
      except NameError:
        pass

      yield assignment

def list_ungraded_assignments(assignments_containers):
  return list_assignments(assignments_containers, ungraded=True)
@

We also want to filter out assignments on the title based on regex.
We also take an optional default argument to indicate whether we only want 
ungraded assignments.
<<functions>>=
def filter_assignments(assignments_containers, regex, ungraded=False):
  """Returns all assignments from assignments_container whose
  title matches regex"""
  p = re.compile(regex)
  for assignment in list_assignments(assignments_containers, ungraded=ungraded):
    if p.search(assignment.name):
      yield assignment
    elif p.search(str(assignment.id)):
      yield assignment
@

