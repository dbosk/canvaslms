\chapter{The \texttt{modules} subcommand}

This chapter provides everything related to modules.
Firstly, it provides the [[modules]] subcommand.
Secondly, it provides some useful functions for working with modules that can 
be used by other subcommands.

We outline the module:
<<modules.py>>=
import argparse
import canvasapi
import canvaslms.cli.courses as courses
import csv
import re
import sys

<<functions>>

def add_command(subp):
  """Adds the subcommand and its options to argparse subparser subp"""
  modules_parser = subp.add_parser("modules",
    help="Lists modules of a course",
    description="Lists modules of a course. Output, CSV-format: "
      "<<columns in CSV output>>")
  modules_parser.set_defaults(func=modules_command)
  <<add arguments>>
@

The [[modules]] subcommand takes one positional argument, that is a regular 
expression for filtering the modules.
<<add arguments>>=
modules_parser.add_argument("regex",
  default=".*", nargs="?",
  help="Regex for filtering modules, default: '.*'")
courses.add_course_option(modules_parser, required=True)
@


\section{Producing a list of modules, [[modules_command]]}

We provide the function~[[modules_command]] which will be called by the main 
argument parser.
<<functions>>=
def modules_command(config, canvas, args):
  output = csv.writer(sys.stdout, delimiter=args.delimiter)
  course_list = courses.process_course_option(canvas, args)
  
  for course in course_list:
    modules = filter_modules(course, args.regex)
    for module in modules:
      <<write module information to output>>
@

We output useful information about each module.
<<columns in CSV output>>=
'course, module name, module id, unlock at, require sequential progress, item count'
<<write module information to output>>=
# Get module items count
try:
  items = list(module.get_module_items())
  item_count = len(items)
except:
  item_count = 0

output.writerow([
  course.course_code,
  module.name,
  module.id,
  module.unlock_at if hasattr(module, 'unlock_at') else None,
  module.require_sequential_progress if hasattr(module, 'require_sequential_progress') else False,
  item_count
])
@


\section{Module selection options for other commands}

We now provide functions that set up options for selecting modules on the 
command line.
These are used by other commands that need to work with modules.

When we select modules, we must first select a course.
If the [[required]] option is set, we want to make the module option required.
<<functions>>=
def add_module_option(parser, required=False):
  """Adds module selection option to parser"""
  try:
    courses.add_course_option(parser, required=required)
  except argparse.ArgumentError:
    pass

  parser.add_argument("-z", "--module",
    required=required, default="" if not required else None,
    help="Regex matching module title or Canvas identifier.")

def process_module_option(canvas, args):
  """Processes module selection from command line args"""
  course_list = courses.process_course_option(canvas, args)
  modules_list = []
  
  for course in course_list:
    try:
      module_regex = args.module
    except AttributeError:
      module_regex = ".*"
    
    if module_regex:
      modules = filter_modules(course, module_regex)
      modules_list.extend(modules)
  
  return modules_list
@


\section{Filter modules of a course}

We want to filter out the modules that match a regex.
The regex can match either the module name or the Canvas identifier.
<<functions>>=
def filter_modules(course, regex):
  """Returns all modules of course whose name matches regex"""
  name = re.compile(regex)
  return filter(
    lambda module: name.search(module.name) or name.search(str(module.id)),
    course.get_modules())
@


\section{Filter assignments by modules}

We also want to filter assignments that belong to specific modules.
<<functions>>=
def filter_assignments_by_module(module, assignments):
  """Returns elements in assignments that are part of module"""
  # Get all module items that are assignments
  assignment_ids = set()
  try:
    for item in module.get_module_items():
      if hasattr(item, 'type') and item.type == "Assignment":
        assignment_ids.add(item.content_id)
  except AttributeError:
    # Handle cases where module items don't have expected attributes
    pass
  
  for assignment in assignments:
    if assignment.id in assignment_ids:
      yield assignment
@