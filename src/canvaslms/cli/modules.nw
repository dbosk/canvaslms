\chapter{The \texttt{modules} subcommand}

This chapter provides everything related to modules.
Firstly, it provides the [[modules]] subcommand.
Secondly, it provides some useful functions for working with modules that can 
be used by other subcommands.

We outline the module:
<<modules.py>>=
import argparse
import canvasapi
import canvaslms.cli.courses as courses
import csv
import re
import sys

<<functions>>

def add_command(subp):
  """Adds the subcommand and its options to argparse subparser subp"""
  modules_parser = subp.add_parser("modules",
    help="Work with Canvas modules")
  modules_subp = modules_parser.add_subparsers(dest="modules_command", 
    help="Available module commands")
  
  # Add 'list' subcommand
  list_parser = modules_subp.add_parser("list",
    help="Lists modules of a course",
    description="Lists modules of a course. Output: course, module name, unlock at, require sequential progress, item count")
  list_parser.set_defaults(func=modules_list_command)
  <<add list arguments>>
  
  # Add 'show' subcommand  
  show_parser = modules_subp.add_parser("show",
    help="Shows modules and their contents",
    description="Shows modules and their contents. Output: course, module name, item type, item name, item id, completion requirement")
  show_parser.set_defaults(func=modules_show_command)
  <<add show arguments>>
@

The [[modules]] subcommand takes one positional argument, that is a regular 
expression for filtering the modules.
<<add list arguments>>=
list_parser.add_argument("regex",
  default=".*", nargs="?",
  help="Regex for filtering modules, default: '.*'")
courses.add_course_option(list_parser, required=True)

<<add show arguments>>=
show_parser.add_argument("regex",
  default=".*", nargs="?",
  help="Regex for filtering modules, default: '.*'")
courses.add_course_option(show_parser, required=True)
@


\section{Producing a list of modules, [[modules_list_command]]}

We provide the function~[[modules_list_command]] which will be called by the main 
argument parser for the 'modules list' subcommand.
<<functions>>=
def modules_list_command(config, canvas, args):
  output = csv.writer(sys.stdout, delimiter=args.delimiter)
  course_list = courses.process_course_option(canvas, args)
  
  for course in course_list:
    modules = filter_modules(course, args.regex)
    for module in modules:
      <<write module information to output>>
@

\section{Showing modules and their contents, [[modules_show_command]]}

We provide the function~[[modules_show_command]] which will be called by the main 
argument parser for the 'modules show' subcommand.
<<functions>>=
def modules_show_command(config, canvas, args):
  output = csv.writer(sys.stdout, delimiter=args.delimiter)
  course_list = courses.process_course_option(canvas, args)
  
  for course in course_list:
    modules = filter_modules(course, args.regex)
    for module in modules:
      try:
        items = list(module.get_module_items())
        if not items:
          # Show module even if it has no items
          output.writerow([
            course.course_code,
            module.name,
            "No items",
            "",
            "",
            ""
          ])
        else:
          for item in items:
            <<write module item information to output>>
      except:
        # If we can't get items, show the module with error
        output.writerow([
          course.course_code,
          module.name,
          "Error loading items",
          "",
          "",
          ""
        ])
@

We output useful information about each module.
<<columns in CSV output>>=
'course, module name, unlock at, require sequential progress, item count'

<<show columns in CSV output>>=
'course, module name, item type, item name, item id, completion requirement'

<<modules list help on output format>>=
"Output, CSV-format: "
"<course> <module name> <unlock at> <require sequential progress> <item count>"

<<modules show help on output format>>=
"Output, CSV-format: "
"<course> <module name> <item type> <item name> <item id> <completion requirement>"
<<write module information to output>>=
# Get module items count
try:
  items = list(module.get_module_items())
  item_count = len(items)
except:
  item_count = 0

output.writerow([
  course.course_code,
  module.name,
  module.unlock_at if hasattr(module, 'unlock_at') else None,
  module.require_sequential_progress if hasattr(module, 'require_sequential_progress') else False,
  item_count
])
@

We also need to write module item information for the show command.
<<write module item information to output>>=
# Get completion requirement info
completion_req = ""
if hasattr(item, 'completion_requirement') and item.completion_requirement:
  req = item.completion_requirement
  if 'type' in req:
    completion_req = req['type']
    if 'min_score' in req:
      completion_req += f" (min score: {req['min_score']})"

output.writerow([
  course.course_code,
  module.name,
  item.type if hasattr(item, 'type') else "Unknown",
  item.title if hasattr(item, 'title') else "No title",
  item.content_id if hasattr(item, 'content_id') else item.id if hasattr(item, 'id') else "",
  completion_req
])
@


\section{Module selection options for other commands}

We now provide functions that set up options for selecting modules on the 
command line.
These are used by other commands that need to work with modules.

When we select modules, we must first select a course.
If the [[required]] option is set, we want to make the module option required.
<<functions>>=
def add_module_option(parser, required=False):
  """Adds module selection option to parser"""
  try:
    courses.add_course_option(parser, required=required)
  except argparse.ArgumentError:
    pass

  parser.add_argument("-M", "--module",
    required=required, default="" if not required else None,
    help="Regex matching module title or Canvas identifier.")

def process_module_option(canvas, args):
  """Processes module selection from command line args"""
  course_list = courses.process_course_option(canvas, args)
  modules_list = []
  
  for course in course_list:
    try:
      module_regex = args.module
    except AttributeError:
      module_regex = ".*"
    
    if module_regex:
      modules = filter_modules(course, module_regex)
      modules_list.extend(modules)
  
  return modules_list
@


\section{Filter modules of a course}

We want to filter out the modules that match a regex.
The regex can match either the module name or the Canvas identifier.
<<functions>>=
def filter_modules(course, regex):
  """Returns all modules of course whose name matches regex"""
  name = re.compile(regex)
  return filter(
    lambda module: name.search(module.name) or name.search(str(module.id)),
    course.get_modules())
@


\section{Filter assignments by modules}

We also want to filter assignments that belong to specific modules.
<<functions>>=
def filter_assignments_by_module(module, assignments):
  """Returns elements in assignments that are part of module"""
  # Get all module items that are assignments
  assignment_ids = set()
  try:
    for item in module.get_module_items():
      if hasattr(item, 'type') and item.type == "Assignment":
        assignment_ids.add(item.content_id)
  except AttributeError:
    # Handle cases where module items don't have expected attributes
    pass
  
  for assignment in assignments:
    if assignment.id in assignment_ids:
      yield assignment
@