\chapter{The \texttt{calendar} commands}

\chapterprecis{This chapter was written by GitHub Copilot.}

This chapter provides calendar-related subcommands for Canvas LMS.
The calendar commands allow users to list, view, and create calendar events.

Canvas provides several calendar-related API endpoints:
\begin{itemize}
\item \texttt{get\_calendar\_events} to list calendar events
\item \texttt{get\_calendar\_event} to get a specific calendar event
\item \texttt{create\_calendar\_event} to create new calendar events
\item \texttt{get\_upcoming\_events} to get upcoming events
\end{itemize}

\section{Module outline}

We outline the module:
<<calendar.py>>=
import argparse
import canvasapi.exceptions
import canvaslms.cli
import canvaslms.cli.courses as courses
import csv
import datetime
import sys
import arrow
import textwrap

<<functions>>

def add_command(subp):
  """Adds the calendar command with subcommands to argparse subparser subp"""
  calendar_parser = subp.add_parser("calendar",
    help="Calendar-related commands",
    description="Calendar-related commands for Canvas LMS")
  
  calendar_subp = calendar_parser.add_subparsers(
    title="calendar subcommands",
    dest="calendar_command", 
    required=True)
  
  add_calendar_list_command(calendar_subp)
  add_calendar_show_command(calendar_subp)
  add_calendar_create_command(calendar_subp)
@


\section{The \texttt{calendar list} subcommand}

The \texttt{calendar list} subcommand lists calendar events, optionally filtered by course.
<<functions>>=
def add_calendar_list_command(subp):
  """Adds the calendar list subcommand and its options to argparse subparser subp"""
  calendar_list_parser = subp.add_parser("list",
    help="Lists calendar events",
    description="Lists calendar events. Output, CSV-format: "
      "<event-id> <title> <start-time> <end-time> <context-type> <context-name>")
  calendar_list_parser.set_defaults(func=calendar_list_command)
  courses.add_course_option(calendar_list_parser)
  <<add calendar list arguments>>

def calendar_list_command(config, canvas, args):
  """Lists calendar events in CSV format to stdout"""
  output = csv.writer(sys.stdout, delimiter=args.delimiter)
  
  <<process course option for calendar list>>
  <<get and output calendar events>>
@

We add options to filter events by date range.
<<add calendar list arguments>>=
calendar_list_parser.add_argument("--start-date",
  default=arrow.now().format('YYYY-MM-DD'),
  help="Start date for event filter (YYYY-MM-DD format, defaults to today)")
calendar_list_parser.add_argument("--end-date", 
  default=arrow.now().shift(weeks=1).format('YYYY-MM-DD'),
  help="End date for event filter (YYYY-MM-DD format, defaults to one week from today)")
calendar_list_parser.add_argument("--type",
  choices=["event", "assignment"],
  help="Filter by event type")
@


\section{Processing course options for calendar events}

If a course is specified, we get events for that course context.
Otherwise, we get all events for the user.
<<process course option for calendar list>>=
context_codes = []
course_list = courses.process_course_option(canvas, args)
if course_list:
  context_codes = [f"course_{course.id}" for course in course_list]
@


\section{Getting and outputting calendar events}

We fetch the calendar events and output them in CSV format.

The \texttt{args.type} parameter is optional and may be \texttt{None} by default.
When \texttt{None}, the Canvas API includes all event types (both ``event'' and ``assignment'').
When specified, it filters to only the requested type.
<<get and output calendar events>>=
try:
  # Prepare parameters for API call
  params = {}
  if context_codes:
    params['context_codes'] = context_codes
  if args.start_date:
    params['start_date'] = args.start_date
  if args.end_date:
    params['end_date'] = args.end_date
  if args.type:
    params['type'] = args.type
    
  events = canvas.get_calendar_events(**params)
  
  for event in events:
    <<output calendar event data>>
    
except canvasapi.exceptions.CanvasException as e:
  canvaslms.cli.err(1, f"Failed to get calendar events: {e}")
@

We output the calendar event data in a structured format.
<<output calendar event data>>=
# Get context information
context_type = getattr(event, 'context_type', '')
context_name = getattr(event, 'context_name', '')

# Format dates
start_at = getattr(event, 'start_at', '')
end_at = getattr(event, 'end_at', '')

row = [
  getattr(event, 'id', ''),
  getattr(event, 'title', ''),
  start_at,
  end_at,
  context_type,
  context_name
]
output.writerow(row)
@


\section{The \texttt{calendar show} subcommand}

The \texttt{calendar show} subcommand shows details of a specific calendar event.
<<functions>>=
def add_calendar_show_command(subp):
  """Adds the calendar show subcommand and its options to argparse subparser subp"""
  calendar_show_parser = subp.add_parser("show",
    help="Shows details of a specific calendar event",
    description="Shows details of a specific calendar event")
  calendar_show_parser.set_defaults(func=calendar_show_command)
  <<add calendar show arguments>>

def calendar_show_command(config, canvas, args):
  """Shows details of a specific calendar event"""
  <<get and display calendar event details>>
@

The show command requires an event ID.
<<add calendar show arguments>>=
calendar_show_parser.add_argument("event_id",
  help="The ID of the calendar event to show")
@

We fetch and display the event details.
<<get and display calendar event details>>=
try:
  event = canvas.get_calendar_event(args.event_id)
  
  print(f"Event ID: {event.id}")
  print(f"Title: {getattr(event, 'title', 'N/A')}")
  
  # Handle multiline description with proper alignment
  description = getattr(event, 'description', 'N/A')
  if description and description != 'N/A':
    # Split description into lines and align continuation lines
    lines = description.split('\n')
    print(f"Description: {lines[0]}")
    for line in lines[1:]:
      print(f"             {line}")
  else:
    print(f"Description: {description}")
  
  print(f"Start: {getattr(event, 'start_at', 'N/A')}")
  print(f"End: {getattr(event, 'end_at', 'N/A')}")
  print(f"Location: {getattr(event, 'location_name', 'N/A')}")
  print(f"Context: {getattr(event, 'context_type', 'N/A')} - {getattr(event, 'context_name', 'N/A')}")
  print(f"URL: {getattr(event, 'html_url', 'N/A')}")
  
except canvasapi.exceptions.CanvasException as e:
  canvaslms.cli.err(1, f"Failed to get calendar event: {e}")
@


\section{The \texttt{calendar create} subcommand}

The \texttt{calendar create} subcommand creates a new calendar event.
It supports two types of events:
\begin{itemize}
\item Regular calendar events (\texttt{--event-type event}, default)
\item Appointment groups for bookable time slots (\texttt{--event-type appointment\_group})
\end{itemize}

Appointment groups allow students to book time slots within a defined time range.
This is useful for office hours, lab sessions, or individual consultations.
<<functions>>=
def add_calendar_create_command(subp):
  """Adds the calendar create subcommand and its options to argparse subparser subp"""  
  calendar_create_parser = subp.add_parser("create",
    help="Creates a new calendar event", 
    description="Creates a new calendar event or appointment group for bookable time slots")
  calendar_create_parser.set_defaults(func=calendar_create_command)
  courses.add_course_option(calendar_create_parser)
  <<add calendar create arguments>>

def calendar_create_command(config, canvas, args):
  """Creates a new calendar event"""
  <<create calendar event>>
@

The create command requires title and start time.
<<add calendar create arguments>>=
calendar_create_parser.add_argument("title",
  help="Title of the calendar event")
calendar_create_parser.add_argument("--start-time", required=True,
  help="Start time (ISO format: YYYY-MM-DDTHH:MM:SS)")
calendar_create_parser.add_argument("--end-time",
  help="End time (ISO format: YYYY-MM-DDTHH:MM:SS)")
calendar_create_parser.add_argument("--description", 
  help="Description of the event")
calendar_create_parser.add_argument("--location",
  help="Location of the event")
calendar_create_parser.add_argument("--event-type", 
  choices=["event", "appointment_group"],
  default="event",
  help="Type of calendar event to create (default: event)")
calendar_create_parser.add_argument("--time-slot-duration", type=int,
  help="Duration in minutes for each bookable time slot (only for appointment_group type)")
calendar_create_parser.add_argument("--max-appointments", type=int, default=1,
  help="Maximum appointments per time slot (only for appointment_group type, default: 1)")
@

We create the calendar event with the specified parameters.
<<create calendar event>>=
try:
  if args.event_type == "appointment_group":
    # Create appointment group (bookable time slots)
    params = {
      'appointment_group': {
        'title': args.title,
        'start_at': args.start_time,
        'end_at': args.end_time or args.start_time,  # End time required for appointment groups
        'participants_per_appointment': args.max_appointments,
        'participant_visibility': 'protected',  # Students can see appointment times
        'max_appointments_per_participant': 1,
      }
    }
    
    if args.description:
      params['appointment_group']['description'] = args.description
    if args.location:
      params['appointment_group']['location_name'] = args.location
    if args.time_slot_duration:
      params['appointment_group']['min_appointments_per_participant'] = 1
      # Canvas uses the duration to create time slots automatically
      # We need to set sub_context_codes for the course context
      
    # Set context if course is specified
    if hasattr(args, 'course') and args.course:
      course_list = courses.process_course_option(canvas, args)
      if course_list:
        course = list(course_list)[0]  # Use first course if multiple
        params['appointment_group']['context_codes'] = [f"course_{course.id}"]
        params['appointment_group']['sub_context_codes'] = [f"course_{course.id}"]
    
    # Note: Canvas API creates appointment groups differently than regular events
    # This creates the appointment group, then students can book time slots
    response = canvas._Canvas__requester.request(
      'POST', 
      'appointment_groups',
      **params
    )
    
    print(f"Created appointment group with ID: {response.json().get('id')}")
    print(f"Title: {args.title}")
    print(f"Start: {args.start_time}")
    print(f"End: {args.end_time or args.start_time}")
    if args.time_slot_duration:
      print(f"Time slot duration: {args.time_slot_duration} minutes")
    print(f"Max appointments per slot: {args.max_appointments}")
    
  else:
    # Create regular calendar event
    params = {
      'calendar_event': {
        'title': args.title,
        'start_at': args.start_time,
      }
    }
    
    if args.end_time:
      params['calendar_event']['end_at'] = args.end_time
    if args.description:
      params['calendar_event']['description'] = args.description  
    if args.location:
      params['calendar_event']['location_name'] = args.location
      
    # Set context if course is specified
    if hasattr(args, 'course') and args.course:
      course_list = courses.process_course_option(canvas, args)
      if course_list:
        course = list(course_list)[0]  # Use first course if multiple
        params['calendar_event']['context_code'] = f"course_{course.id}"
    
    event = canvas.create_calendar_event(**params)
    
    print(f"Created calendar event with ID: {event.id}")
    print(f"Title: {event.title}")
    print(f"Start: {getattr(event, 'start_at', 'N/A')}")
    if hasattr(event, 'end_at') and event.end_at:
      print(f"End: {event.end_at}")
  
except canvasapi.exceptions.CanvasException as e:
  canvaslms.cli.err(1, f"Failed to create calendar event: {e}")
@