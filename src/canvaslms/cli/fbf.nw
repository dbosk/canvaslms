\chapter{The \texttt{fbf} command}
\label{fbf-command}

This chapter provides the subcommand [[fbf]], which provides access to
FeedbackFruits data through Canvas LTI integration.

FeedbackFruits is an LTI v1.3 tool integrated with Canvas. Through investigation,
we discovered that FeedbackFruits provides a REST API at
\texttt{https://api.feedbackfruits.com} that uses JWT Bearer token authentication.
This module provides commands to extract student progress data, grades, user
information, and other activity data from FeedbackFruits assignments.


\section{Overview: What works}

After exploring multiple approaches, we successfully implemented access to
FeedbackFruits data through their REST API:

\subsection{Successfully implemented}

\begin{itemize}
\item \textbf{JWT token authentication}: FeedbackFruits API uses JWT Bearer
tokens with 30-minute expiry for API access (tokens must be obtained via manual
browser inspection)

\item \textbf{Progress data extraction}: Retrieve student progress percentages,
completion status, grades broken down by rubric criterion, and detailed metadata

\item \textbf{User mapping}: The [[lti_user_id]] attribute in API responses maps
FeedbackFruits UUIDs to Canvas user IDs

\item \textbf{Multiple data endpoints}: Access to users, courses, activities,
tasks, progress, notifications, multimedia, questions, grade facets, groups,
and more

\item \textbf{Token refresh}: Support for refreshing expired JWT tokens using
refresh tokens

\item \textbf{Token storage}: Securely store tokens in keyring for reuse

\item \textbf{Canvas integration}: Extract rubrics, submission data, and LTI
configuration from Canvas
\end{itemize}

\subsection{Current limitations}

\begin{itemize}
\item \textbf{Manual token acquisition}: JWT tokens must be obtained by manually
inspecting browser network traffic during an LTI launch. Programmatic token
acquisition is not currently possible due to Canvas API limitations (see
[[auto-login]] command documentation for details).

\item \textbf{Task UUID discovery}: The FeedbackFruits task UUID must be found
through browser inspection; Canvas [[resource_link_id]] doesn't directly map to it.

\item \textbf{Token expiration}: JWT access tokens expire after 30 minutes (but
can be refreshed with the [[refresh-token]] command if you have a refresh token)

\item \textbf{Limited activity details}: Cannot yet extract discussion posts,
peer review details, or other fine-grained interaction data
\end{itemize}


\section{Quick start}

To extract student progress data from a FeedbackFruits assignment:

\subsection{Manual token extraction (current method)}

If automatic token acquisition fails, you can manually extract tokens:

\begin{enumerate}
\item \textbf{Extract JWT token and task UUID from browser}:
  \begin{enumerate}
  \item Open the FeedbackFruits assignment in Canvas while logged in
  \item Open browser DevTools (F12) → Network tab
  \item Look for requests to [[api.feedbackfruits.com]]
  \item Copy the JWT token from the [[Authorization: Bearer]] header
  \item Copy the task UUID from the [[filter[progressable_id]]] parameter
  \end{enumerate}

\item \textbf{Use the manually extracted token}:
\begin{verbatim}
canvaslms fbf progress -c COURSE_CODE -a ASSIGNMENT_NAME \
  --task-id UUID --token 'eyJ...'
\end{verbatim}
\end{enumerate}

\subsection{Token refresh}

JWT access tokens expire after 30 minutes. To refresh:
\begin{verbatim}
canvaslms fbf refresh-token --refresh-token 'REFRESH_TOKEN'
\end{verbatim}


\section{Implementation approach}

This section documents how we arrived at the current implementation.

\subsection{Successful approach: Direct REST API access}

\textbf{Status: ✓ Implemented and working}

FeedbackFruits provides a REST API at \texttt{https://api.feedbackfruits.com}
similar to Canvas New Quizzes. The API uses JWT Bearer token authentication
and provides JSON:API formatted responses.

\textbf{How it works:}
\begin{enumerate}
\item During LTI launch, the browser obtains a JWT access token (30-minute expiry)
\item This token grants full API access to FeedbackFruits endpoints
\item API responses include user data with [[lti_user_id]] mapping to Canvas users
\item Tokens can be refreshed using refresh tokens without requiring new LTI launch
\end{enumerate}

\textbf{Available endpoints:}
\begin{itemize}
\item [[/v1/progresses]] - Student progress and grades
\item [[/v1/people]] - User information with Canvas mapping
\item [[/v1/courses]] - FeedbackFruits course data
\item [[/v1/activities]] - Activity configuration
\item [[/v1/tasks]] - Task details within activities
\item [[/v1/notifications]] - Activity notifications
\item [[/v1/multimedia]] - Multimedia content details
\item [[/v1/questions]] - Questions associated with multimedia
\item [[/v1/grade_facets]] - Grading rubric facets
\item [[/v1/lti_grades]] - Individual grade records
\item [[/v1/groups]] - Student group information
\end{itemize}

This is the primary approach implemented in this module.

\subsection{Supporting approach: Canvas sessionless launch}

\textbf{Status: ✓ Implemented (launch-url command)}

The [[launch-url]] command uses Canvas's sessionless launch API to generate
time-limited URLs that could potentially be used for headless browser automation.

\textbf{Use case:} Manual inspection of student work when API access is insufficient.

\subsection{Supporting approach: Canvas-synced data}

\textbf{Status: ✓ Implemented (rubric and submissions commands)}

FeedbackFruits syncs grades and rubric assessments back to Canvas. The [[rubric]]
and [[submissions]] commands extract this data directly from Canvas.

\textbf{Use case:} Getting grading outcome data without requiring FeedbackFruits API access.


\section{Data sources available}

This module provides access to data from two sources:

\subsection{From Canvas LMS}

Available without JWT tokens:
\begin{itemize}
\item LTI launch parameters and configuration ([[info]] command)
\item Rubric criteria and point values ([[rubric]] command)
\item Rubric assessments and grades synced from FeedbackFruits ([[submissions]] command)
\item Sessionless launch URLs ([[launch-url]] command)
\end{itemize}

\subsection{From FeedbackFruits API}

Requires JWT token (obtained via browser inspection):
\begin{itemize}
\item Student progress percentages and completion status ([[progress]] command)
\item User information with Canvas mapping ([[users]], [[course-users]] commands)
\item Current user identity ([[current-user]] command)
\item Course information ([[course]] command)
\item Activity configuration ([[activity]], [[activity-flags]] commands)
\item Task details ([[task]] command)
\item Personal progress data ([[my-progress]] command)
\item User appearance/activity timestamps ([[appearances]] command)
\item Notifications ([[notifications]], [[mark-notifications-seen]] commands)
\item Multimedia content details ([[multimedia]] command)
\item Questions for multimedia ([[questions]] command)
\item Grading rubric facets ([[grade-facets]] command)
\item Individual LTI grade records ([[lti-grade]] command)
\item Student groups ([[group]] command)
\item Course sync operations ([[sync]] command)
\item LTI deployment information ([[deployment]] command)
\item Token refresh ([[refresh-token]] command)
\end{itemize}


\section{Future enhancements}

\subsection{Automated task UUID discovery}

\textbf{Goal:} Eliminate manual browser inspection for task UUIDs

\textbf{Current status:} JWT token acquisition is now automated via [[auto-login]],
but task UUID still requires one-time browser inspection.

\textbf{Approach:} After obtaining JWT token with [[auto-login]], automatically
query the FeedbackFruits API to discover task UUIDs:
\begin{enumerate}
\item Use JWT token to query [[/v1/activities]] endpoint
\item Match Canvas [[resource_link_id]] to FeedbackFruits activity ID
\item Extract task UUIDs from activity configuration
\item Cache the mapping for future use
\item Allow users to specify task type (e.g., "reflect", "summative-grade")
\end{enumerate}

\textbf{Challenge:} The mapping between Canvas [[resource_link_id]] and
FeedbackFruits activity UUID is not straightforward. May require additional
API exploration or heuristics.

\subsection{Enhanced data extraction}

\textbf{Current limitation:} Cannot extract detailed interaction data (discussion posts, peer reviews)

\textbf{Potential solutions:}
\begin{enumerate}
\item Discover additional FeedbackFruits API endpoints
\item Build JSON:API parser for complex relationship structures
\item Extract detailed activity logs and interaction timelines
\end{enumerate}

\subsection{LTI Advantage services}

LTI 1.3 specifies several standard services:
\begin{itemize}
\item \textbf{Assignment and Grade Services (AGS)}: Read/write grades
\item \textbf{Names and Role Provisioning Services (NRPS)}: Get roster data
\item \textbf{Deep Linking}: Configure tool placements
\end{itemize}

\textbf{Note:} These are typically tool-to-platform (FeedbackFruits → Canvas),
not platform-to-tool. Accessing them would require Canvas to implement the
tool role, which is not currently possible.


\section{Module outline}

We outline the module:
<<fbf.py>>=
import argparse
import canvasapi
import canvaslms.cli
import canvaslms.cli.courses as courses
import canvaslms.cli.assignments as assignments
import json
import requests
import sys

<<functions>>

def add_command(subp):
  """Adds the fbf subcommand to argparse parser subp"""
  <<add fbf command to subp>>
@


\section{The fbf command structure}

The [[fbf]] command will have several subcommands:

\begin{itemize}
\item [[info]]: Show LTI launch parameters and configuration for a FeedbackFruits assignment
\item [[launch-url]]: Get a sessionless launch URL for manual inspection
\item [[auto-login]]: Automatically obtain JWT tokens by performing LTI launch
\item [[probe]]: Test if FeedbackFruits API is accessible with the launch code
\item [[task-id]]: Extract or discover the FeedbackFruits task UUID for an assignment
\item [[progress]]: Fetch student progress data from FeedbackFruits API
\item [[users]]: Fetch user information from FeedbackFruits API
\item [[current-user]]: Show information about the current authenticated user
\item [[course]]: Show information about a FeedbackFruits course
\item [[activity]]: Show information about a FeedbackFruits activity
\item [[task]]: Show information about a specific task within an activity
\item [[my-progress]]: Show the current user's progress on an activity
\item [[appearances]]: Show when users last appeared/were active in a course
\item [[notifications]]: Show notifications for an activity
\item [[multimedia]]: Show multimedia material details (video, audio, etc.)
\item [[questions]]: Show questions associated with multimedia material
\item [[grade-facets]]: Show grading rubric facets/criteria for a task
\item [[lti-grade]]: Show individual LTI grade record details
\item [[group]]: Show student group information and members
\item [[sync]]: Trigger course data sync from Canvas
\item [[deployment]]: Show LTI deployment/environment information
\item [[refresh-token]]: Refresh an expired access token using a refresh token
\item [[rubric]]: Extract and format the rubric in detail
\item [[submissions]]: Show submission data and grades synced from FeedbackFruits
\item [[course-users]]: Show users enrolled in a FeedbackFruits course
\item [[activity-flags]]: Show feature flags for an activity
\item [[mark-notifications-seen]]: Mark all notifications as seen for an activity
\end{itemize}

<<add fbf command to subp>>=
parser_fbf = subp.add_parser("fbf",
  help="Extract data from FeedbackFruits (LTI) assignments")

fbf_subparsers = parser_fbf.add_subparsers(title="FeedbackFruits commands",
  dest="fbf_command", required=True)

<<add fbf info command>>
<<add fbf launch-url command>>
<<add fbf auto-login command>>
<<add fbf probe command>>
<<add fbf task-id command>>
<<add fbf progress command>>
<<add fbf users command>>
<<add fbf current-user command>>
<<add fbf course command>>
<<add fbf activity command>>
<<add fbf task command>>
<<add fbf my-progress command>>
<<add fbf appearances command>>
<<add fbf notifications command>>
<<add fbf multimedia command>>
<<add fbf questions command>>
<<add fbf grade-facets command>>
<<add fbf lti-grade command>>
<<add fbf group command>>
<<add fbf sync command>>
<<add fbf deployment command>>
<<add fbf refresh-token command>>
<<add fbf rubric command>>
<<add fbf submissions command>>
<<add fbf course-users command>>
<<add fbf activity-flags command>>
<<add fbf mark-notifications-seen command>>
@


\section{The info command}

The [[info]] command displays LTI launch parameters and configuration.

<<add fbf info command>>=
parser_info = fbf_subparsers.add_parser("info",
  help="Show LTI configuration for a FeedbackFruits assignment")
assignments.add_assignment_option(parser_info, ungraded=False, required=True)
parser_info.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_info.set_defaults(func=info_command)
@

<<functions>>=
def info_command(config, canvas, args):
  """Show LTI launch parameters for a FeedbackFruits assignment"""
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    if 'external_tool' not in assignment.submission_types:
      print(f"Warning: Assignment '{assignment.name}' is not an external tool assignment",
            file=sys.stderr)
      continue
    
    if args.json:
      print(json.dumps({
        'name': assignment.name,
        'id': assignment.id,
        'external_tool_tag_attributes': assignment.external_tool_tag_attributes,
        'url': assignment.url,
        'html_url': assignment.html_url,
      }, indent=2))
    else:
      print(f"Assignment: {assignment.name}")
      print(f"Assignment ID: {assignment.id}")
      print(f"HTML URL: {assignment.html_url}")
      print()
      
      if hasattr(assignment, 'external_tool_tag_attributes'):
        attrs = assignment.external_tool_tag_attributes
        print("LTI Launch Parameters:")
        print(f"  Launch URL: {attrs.get('url', 'N/A')}")
        print(f"  Resource Link ID: {attrs.get('resource_link_id', 'N/A')}")
        print(f"  Content ID: {attrs.get('content_id', 'N/A')}")
        print(f"  Content Type: {attrs.get('content_type', 'N/A')}")
        
        if 'custom_params' in attrs and attrs['custom_params']:
          print("  Custom Parameters:")
          for key, value in attrs['custom_params'].items():
            print(f"    {key}: {value}")
        print()
      
      print(f"Canvas Sessionless Launch URL:")
      print(f"  {assignment.url}")
      print()
@


\section{The launch-url command}

The [[launch-url]] command gets a signed sessionless launch URL from Canvas.

<<add fbf launch-url command>>=
parser_launch = fbf_subparsers.add_parser("launch-url",
  help="Get a sessionless launch URL for a FeedbackFruits assignment")
assignments.add_assignment_option(parser_launch, ungraded=False, required=True)
parser_launch.add_argument("--open", action="store_true",
  help="Open the URL in the default browser")
parser_launch.set_defaults(func=launch_url_command)
@

<<functions>>=
def launch_url_command(config, canvas, args):
  """Get a sessionless launch URL for a FeedbackFruits assignment"""
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    if 'external_tool' not in assignment.submission_types:
      print(f"Warning: Assignment '{assignment.name}' is not an external tool assignment",
            file=sys.stderr)
      continue
    
    # Get the sessionless launch URL from Canvas
    # The assignment.url already contains the sessionless launch endpoint
    try:
      # Make a GET request to the sessionless launch endpoint
      # This should return a JSON with a 'url' field containing the signed launch URL
      course = canvas.get_course(assignment.course_id)
      
      # Use the Canvas API to get sessionless launch
      # Format: /api/v1/courses/:course_id/external_tools/sessionless_launch
      response = canvas._Canvas__requester.request(
        'GET',
        f'courses/{assignment.course_id}/external_tools/sessionless_launch',
        assignment_id=assignment.id,
        launch_type='assessment'
      )
      
      if 'url' in response.json():
        launch_url = response.json()['url']
        print(f"Assignment: {assignment.name}")
        print(f"Signed Launch URL (expires soon):")
        print(launch_url)
        print()
        
        if args.open:
          import webbrowser
          webbrowser.open(launch_url)
      else:
        print(f"Error: Could not get launch URL for {assignment.name}",
              file=sys.stderr)
        print(f"Response: {response.json()}", file=sys.stderr)
    
    except Exception as e:
      print(f"Error getting launch URL for {assignment.name}: {e}",
            file=sys.stderr)
@


\section{The auto-login command (experimental)}

\textbf{Status:} Experimental - Not functional. Kept for future development.

The [[auto-login]] command attempts to automatically obtain JWT tokens through
OAuth2 token exchange, but is currently blocked by authentication architecture.

\textbf{What we discovered:}

FeedbackFruits uses OAuth2 authorization code flow:
\begin{enumerate}
\item Browser performs LTI launch through Canvas
\item Canvas redirects to FeedbackFruits with dynamic authorization code
\item FeedbackFruits exchanges code for JWT tokens via POST to
      [[https://accounts.feedbackfruits.com/auth/token]]
\end{enumerate}

\textbf{Why automatic token acquisition doesn't work:}

\begin{itemize}
\item The [[code]] parameter in Canvas LTI attributes is a static identifier,
      not the OAuth2 authorization code
\item The OAuth2 authorization code is generated dynamically during the
      browser redirect flow
\item Without browser automation (Selenium/Playwright), we cannot capture
      this dynamic code
\item Attempting to use the static LTI code returns "invalid\_grant" error
\end{itemize}

\textbf{Recommendation:} Use manual token extraction (see Quick Start section).
Browser automation could be implemented in the future if there's sufficient demand.

<<add fbf auto-login command>>=
parser_autologin = fbf_subparsers.add_parser("auto-login",
  help="Automatically obtain JWT tokens by performing LTI launch")
assignments.add_assignment_option(parser_autologin, ungraded=False, required=True)
parser_autologin.add_argument("--store", action="store_true",
  help="Store tokens in keyring for future use")
parser_autologin.add_argument("--json", action="store_true",
  help="Output tokens as JSON")
parser_autologin.add_argument("--verbose", "-v", action="store_true",
  help="Show detailed debug information")
parser_autologin.set_defaults(func=auto_login_command)
@

<<functions>>=
def auto_login_command(config, canvas, args):
  """Automatically obtain JWT tokens via OAuth2 token exchange"""
  import requests

  assignment_list = assignments.process_assignment_option(canvas, args)

  for assignment in assignment_list:
    if 'external_tool' not in assignment.submission_types:
      print(f"Warning: Assignment '{assignment.name}' is not an external tool assignment",
            file=sys.stderr)
      continue

    if args.verbose:
      print(f"Processing assignment: {assignment.name}", file=sys.stderr)

    try:
      # Step 1: Get authorization code from LTI launch attributes
      if args.verbose:
        print("Step 1: Extracting authorization code from LTI attributes...", file=sys.stderr)

      if not hasattr(assignment, 'external_tool_tag_attributes'):
        print(f"Error: Assignment '{assignment.name}' has no external tool attributes",
              file=sys.stderr)
        continue

      attrs = assignment.external_tool_tag_attributes
      code = attrs.get('custom_params', {}).get('code', '')

      if not code:
        print(f"Error: No authorization code found in LTI attributes", file=sys.stderr)
        continue

      if args.verbose:
        print(f"  Authorization code: {code[:20]}...", file=sys.stderr)

      # Step 2: Exchange authorization code for JWT tokens
      if args.verbose:
        print("Step 2: Exchanging code for JWT tokens...", file=sys.stderr)

      token_endpoint = "https://accounts.feedbackfruits.com/auth/token"
      token_data = {
        'grant_type': 'authorization_code',
        'code': code,
        'redirect_uri': 'https://eu.feedbackfruits.com/auth/callback',
        'client_id': 'FeedbackFruits'
      }

      response = requests.post(token_endpoint, data=token_data)

      if response.status_code != 200:
        print(f"Error: Token exchange failed (status {response.status_code})",
              file=sys.stderr)
        if args.verbose:
          print(f"  Response: {response.text[:500]}", file=sys.stderr)

        # Explain the common error
        if "invalid_grant" in response.text:
          print("", file=sys.stderr)
          print("Note: The 'code' in LTI attributes is not the OAuth2 authorization code.", file=sys.stderr)
          print("The OAuth2 code is generated dynamically during browser redirect.", file=sys.stderr)
          print("Automatic token acquisition requires browser automation (Selenium/Playwright).", file=sys.stderr)
          print("", file=sys.stderr)
          print("For now, please use manual token extraction (see documentation).", file=sys.stderr)
        continue

      # Step 3: Extract tokens from response
      if args.verbose:
        print("Step 3: Extracting tokens from response...", file=sys.stderr)

      try:
        token_response = response.json()
        access_token = token_response.get('access_token')
        refresh_token = token_response.get('refresh_token')

        if not access_token:
          print(f"Error: No access_token in response", file=sys.stderr)
          if args.verbose:
            print(f"  Response keys: {list(token_response.keys())}", file=sys.stderr)
          continue

        if args.verbose:
          print(f"  Successfully obtained access token", file=sys.stderr)
          if refresh_token:
            print(f"  Successfully obtained refresh token", file=sys.stderr)

      except json.JSONDecodeError as e:
        print(f"Error: Failed to parse token response as JSON: {e}", file=sys.stderr)
        continue

      # Step 4: Store tokens if requested
      if args.store:
        if args.verbose:
          print("Step 4: Storing tokens in keyring...", file=sys.stderr)

        try:
          import keyring
          service_name = f"canvaslms-fbf-{assignment.course_id}-{assignment.id}"
          keyring.set_password(service_name, "access_token", access_token)
          if refresh_token:
            keyring.set_password(service_name, "refresh_token", refresh_token)
          if args.verbose:
            print(f"  Tokens stored with service name: {service_name}", file=sys.stderr)
        except Exception as e:
          print(f"Warning: Could not store tokens in keyring: {e}", file=sys.stderr)

      # Output tokens
      if args.json:
        output = {
          'assignment': assignment.name,
          'assignment_id': assignment.id,
          'course_id': assignment.course_id,
          'access_token': access_token
        }
        if refresh_token:
          output['refresh_token'] = refresh_token
        print(json.dumps(output, indent=2))
      else:
        print(f"Assignment: {assignment.name}")
        print(f"Access Token: {access_token}")
        if refresh_token:
          print(f"Refresh Token: {refresh_token}")
        print()
        print("To use this token:")
        print(f"  canvaslms fbf progress -c {assignment.course_id} -a '{assignment.name}' \\")
        print(f"    --task-id TASK_UUID --token '{access_token[:50]}...'")
        if args.store:
          print()
          print("Token has been stored in keyring and can be retrieved with:")
          print(f"  keyring get canvaslms-fbf-{assignment.course_id}-{assignment.id} access_token")

    except Exception as e:
      print(f"Error during auto-login for {assignment.name}: {e}", file=sys.stderr)
      if args.verbose:
        import traceback
        traceback.print_exc()
@


\section{The probe command}

The [[probe]] command attempts to discover if FeedbackFruits has an accessible 
REST API and tests authentication with the launch code.

<<add fbf probe command>>=
parser_probe = fbf_subparsers.add_parser("probe",
  help="Test FeedbackFruits API accessibility and authentication")
assignments.add_assignment_option(parser_probe, ungraded=False, required=True)
parser_probe.add_argument("--verbose", "-v", action="store_true",
  help="Show detailed HTTP requests and responses")
parser_probe.set_defaults(func=probe_command)
@

<<functions>>=
def probe_command(config, canvas, args):
  """Test if FeedbackFruits API is accessible with launch code"""
  import requests
  
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    if 'external_tool' not in assignment.submission_types:
      print(f"Warning: Assignment '{assignment.name}' is not an external tool assignment",
            file=sys.stderr)
      continue
    
    if not hasattr(assignment, 'external_tool_tag_attributes'):
      print(f"Error: Assignment '{assignment.name}' has no external tool attributes",
            file=sys.stderr)
      continue
    
    attrs = assignment.external_tool_tag_attributes
    launch_url = attrs.get('url', '')
    code = attrs.get('custom_params', {}).get('code', '')
    resource_link_id = attrs.get('resource_link_id', '')
    
    print(f"Assignment: {assignment.name}")
    print(f"Launch URL: {launch_url}")
    print(f"Resource Link ID: {resource_link_id}")
    print(f"Launch Code: {code[:20]}..." if len(code) > 20 else f"Launch Code: {code}")
    print()
    
    # Extract base URL from launch URL
    if 'api.feedbackfruits.com' in launch_url:
      api_base = 'https://api.feedbackfruits.com'
      print(f"Testing FeedbackFruits API at {api_base}...")
      print()
      
      # Test various potential endpoints
      test_endpoints = [
        f'/v1/activities/{resource_link_id}',
        f'/v1/lti/activities/{resource_link_id}',
        f'/v1/activities',
      ]
      
      headers = {
        'Authorization': f'Bearer {code}',
        'Accept': 'application/json',
      }
      
      for endpoint in test_endpoints:
        test_url = api_base + endpoint
        if args.verbose:
          print(f"Testing: GET {test_url}")
          print(f"Headers: {headers}")
        
        try:
          response = requests.get(test_url, headers=headers, timeout=10)
          
          if args.verbose:
            print(f"Status: {response.status_code}")
            print(f"Response headers: {dict(response.headers)}")
            if response.text:
              print(f"Response body: {response.text[:500]}")
          
          if response.status_code == 200:
            print(f"✓ SUCCESS: {endpoint}")
            print(f"  Status: {response.status_code}")
            try:
              data = response.json()
              print(f"  Data keys: {list(data.keys())}")
            except:
              print(f"  Response: {response.text[:200]}...")
          elif response.status_code in [401, 403]:
            print(f"✗ AUTH FAILED: {endpoint}")
            print(f"  Status: {response.status_code} (authentication required)")
          elif response.status_code == 404:
            print(f"- NOT FOUND: {endpoint}")
            print(f"  Status: {response.status_code}")
          else:
            print(f"? UNKNOWN: {endpoint}")
            print(f"  Status: {response.status_code}")
          
          print()
          
        except requests.exceptions.Timeout:
          print(f"✗ TIMEOUT: {endpoint}")
          print()
        except requests.exceptions.RequestException as e:
          print(f"✗ ERROR: {endpoint}")
          print(f"  {e}")
          print()
      
      print("API probe complete.")
      print()
      print("Next steps:")
      print("  1. If any endpoint succeeded, examine the response structure")
      print("  2. If auth failed, check FeedbackFruits documentation for proper authentication")
      print("  3. If all failed, FeedbackFruits may not provide a REST API")
    else:
      print(f"Warning: Launch URL doesn't contain 'api.feedbackfruits.com'")
      print(f"Cannot probe FeedbackFruits API automatically.")
    
    print()
@


\section{The task-id command}

The [[task-id]] command attempts to discover the FeedbackFruits task UUID from 
Canvas assignment data.

<<add fbf task-id command>>=
parser_task = fbf_subparsers.add_parser("task-id",
  help="Extract FeedbackFruits task UUID from assignment")
assignments.add_assignment_option(parser_task, ungraded=False, required=True)
parser_task.add_argument("--test", action="store_true",
  help="Test if the task UUID is valid by checking API endpoint")
parser_task.set_defaults(func=task_id_command)
@

<<functions>>=
def task_id_command(config, canvas, args):
  """Extract FeedbackFruits task UUID from assignment"""
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    if 'external_tool' not in assignment.submission_types:
      print(f"Warning: Assignment '{assignment.name}' is not an external tool assignment",
            file=sys.stderr)
      continue
    
    if not hasattr(assignment, 'external_tool_tag_attributes'):
      print(f"Error: Assignment '{assignment.name}' has no external tool attributes",
            file=sys.stderr)
      continue
    
    attrs = assignment.external_tool_tag_attributes
    resource_link_id = attrs.get('resource_link_id', '')
    
    print(f"Assignment: {assignment.name}")
    print(f"Canvas Assignment ID: {assignment.id}")
    print(f"Resource Link ID: {resource_link_id}")
    
    # The resource_link_id might be a hash or might contain the UUID
    # We need to test different approaches
    task_uuid = None
    
    # Check if resource_link_id is a UUID format
    import re
    uuid_pattern = re.compile(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', re.IGNORECASE)
    uuid_match = uuid_pattern.search(resource_link_id)
    
    if uuid_match:
      task_uuid = uuid_match.group(0)
      print(f"Extracted UUID from resource_link_id: {task_uuid}")
    else:
      print(f"Resource link ID is not a UUID format")
      print(f"Attempting to use resource_link_id as-is: {resource_link_id}")
      task_uuid = resource_link_id
    
    print()
    
    if args.test and task_uuid:
      print(f"Testing task UUID by querying API...")
      # Test the UUID by attempting to access the progress endpoint
      test_url = f"https://api.feedbackfruits.com/v1/progresses"
      params = {
        'filter[progressable_type]': 'Task',
        'filter[progressable_id]': task_uuid,
        'filter[actor_type]': 'Person',
        'page[number]': 1
      }
      
      print(f"URL: {test_url}")
      print(f"Params: {params}")
      print()
      
      try:
        response = requests.get(test_url, params=params, timeout=10)
        print(f"Status: {response.status_code}")
        
        if response.status_code == 200:
          print("✓ Task UUID appears to be valid!")
          try:
            data = response.json()
            print(f"Response keys: {list(data.keys())}")
            if 'data' in data:
              print(f"Number of progress records: {len(data['data'])}")
          except:
            print(f"Response: {response.text[:500]}")
        elif response.status_code == 401:
          print("✗ Authentication required (this is expected - use browser session)")
        elif response.status_code == 404:
          print("✗ Task UUID not found - may need different mapping")
        else:
          print(f"? Unexpected response: {response.status_code}")
          print(f"Response: {response.text[:500]}")
      
      except requests.exceptions.RequestException as e:
        print(f"✗ Error: {e}")
    
    print()
@


\section{The progress command}

The [[progress]] command fetches student progress data from the FeedbackFruits 
API using a session cookie from your browser.

<<add fbf progress command>>=
parser_progress = fbf_subparsers.add_parser("progress",
  help="Fetch student progress data from FeedbackFruits")
assignments.add_assignment_option(parser_progress, ungraded=False, required=True)
parser_progress.add_argument("--task-id", dest="task_id",
  help="FeedbackFruits task UUID (if not auto-detected)")
parser_progress.add_argument("--token", dest="token",
  help="JWT Bearer token from browser (from Authorization header)")
parser_progress.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser (format: 'name=value')")
parser_progress.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_progress.set_defaults(func=progress_command)
@

<<functions>>=
def progress_command(config, canvas, args):
  """Fetch student progress data from FeedbackFruits API"""
  import re
  
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    if 'external_tool' not in assignment.submission_types:
      print(f"Warning: Assignment '{assignment.name}' is not an external tool assignment",
            file=sys.stderr)
      continue
    
    # Get task UUID
    task_uuid = args.task_id
    if not task_uuid:
      if not hasattr(assignment, 'external_tool_tag_attributes'):
        print(f"Error: Cannot determine task UUID for '{assignment.name}'",
              file=sys.stderr)
        print(f"Use --task-id to specify manually", file=sys.stderr)
        continue
      
      attrs = assignment.external_tool_tag_attributes
      resource_link_id = attrs.get('resource_link_id', '')
      
      # Try to extract UUID from resource_link_id
      uuid_pattern = re.compile(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', re.IGNORECASE)
      uuid_match = uuid_pattern.search(resource_link_id)
      
      if uuid_match:
        task_uuid = uuid_match.group(0)
      else:
        task_uuid = resource_link_id
    
    print(f"Assignment: {assignment.name}")
    print(f"Task UUID: {task_uuid}")
    print()
    
    # Build API request
    api_url = "https://api.feedbackfruits.com/v1/progresses"
    params = {
      'filter[progressable_type]': 'Task',
      'filter[progressable_id]': task_uuid,
      'filter[actor_type]': 'Person',
      'page[number]': 1
    }
    
    headers = {'Accept': 'application/json'}
    
    # Add authentication - prefer JWT token, fall back to cookie
    if args.token:
      headers['Authorization'] = f'Bearer {args.token}'
    elif args.cookie:
      headers['Cookie'] = args.cookie
    
    try:
      response = requests.get(api_url, params=params, headers=headers, timeout=30)
      
      if response.status_code == 200:
        data = response.json()
        
        if args.json:
          print(json.dumps(data, indent=2))
        else:
          # Parse and display progress data
          if 'data' in data and data['data']:
            print(f"Found {len(data['data'])} progress records:\n")
            
            for record in data['data']:
              attrs_data = record.get('attributes', {})
              relationships = record.get('relationships', {})
              
              actor_data = relationships.get('actor', {}).get('data', {})
              actor_id = actor_data.get('id', 'Unknown')
              
              print(f"Student ID: {actor_id}")
              print(f"  Progress: {attrs_data.get('progress', 0)}%")
              
              # Show grades if available
              grades = attrs_data.get('grades', {})
              if grades:
                print(f"  Grades: {grades}")
              
              # Show metadata if available
              metadata = attrs_data.get('metadata', {})
              if metadata:
                print(f"  Metadata: {metadata}")
              
              print()
            
            # Show included data if present
            if 'included' in data and data['included']:
              print(f"\nIncluded resources: {len(data['included'])} items")
              print(f"Types: {set(item['type'] for item in data['included'])}")
          else:
            print("No progress data found.")
            print()
            print("Possible reasons:")
            print("  1. No students have started the activity yet")
            print("  2. Task UUID is incorrect")
            print("  3. Authentication required (provide --token or --cookie)")
      
      elif response.status_code == 401:
        print("✗ Authentication required")
        print()
        print("To fetch data, you need to provide authentication:")
        print()
        print("Option 1: JWT Token (recommended)")
        print("  1. Open the FeedbackFruits activity in your browser")
        print("  2. Open browser DevTools (F12) > Network tab")
        print("  3. Look for requests to api.feedbackfruits.com")
        print("  4. Check request headers for: Authorization: Bearer <token>")
        print("  5. Copy the JWT token (after 'Bearer ')")
        print("  6. Run: canvaslms fbf progress -c COURSE -a ASSIGNMENT --token '<token>'")
        print()
        print("Option 2: Session Cookie")
        print("  1. DevTools > Application/Storage > Cookies")
        print("  2. Copy the _feedbackfruits_session cookie")
        print("  3. Run: canvaslms fbf progress -c COURSE -a ASSIGNMENT --cookie 'name=value'")
      
      elif response.status_code == 404:
        print("✗ Task not found")
        print()
        print(f"The task UUID '{task_uuid}' was not found.")
        print("Try running: canvaslms fbf task-id -c COURSE -a ASSIGNMENT --test")
      
      else:
        print(f"✗ Unexpected response: {response.status_code}")
        print(f"Response: {response.text[:500]}")
    
    except requests.exceptions.RequestException as e:
      print(f"✗ Error: {e}", file=sys.stderr)
    
    print()
@


\section{The users command}

The [[users]] command fetches user information from the FeedbackFruits API. 
This is useful for mapping FeedbackFruits user UUIDs to actual user details 
like names and email addresses.

<<add fbf users command>>=
parser_users = fbf_subparsers.add_parser("users",
  help="Fetch user information from FeedbackFruits")
assignments.add_assignment_option(parser_users, ungraded=False, required=True)
parser_users.add_argument("--task-id", dest="task_id",
  help="FeedbackFruits task UUID (fetch users from progress data)")
parser_users.add_argument("--user-ids", dest="user_ids",
  help="Comma-separated list of FeedbackFruits user UUIDs")
parser_users.add_argument("--token", dest="token",
  help="JWT Bearer token from browser (from Authorization header)")
parser_users.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser (format: 'name=value')")
parser_users.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_users.set_defaults(func=users_command)
@

<<functions>>=
def users_command(config, canvas, args):
  """Fetch user information from FeedbackFruits API"""
  import re
  
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    if 'external_tool' not in assignment.submission_types:
      print(f"Warning: Assignment '{assignment.name}' is not an external tool assignment",
            file=sys.stderr)
      continue
    
    print(f"Assignment: {assignment.name}")
    print()
    
    # Get user IDs - either from command line or from progress data
    user_ids = []
    
    if args.user_ids:
      user_ids = [uid.strip() for uid in args.user_ids.split(',')]
    elif args.task_id:
      # Fetch progress data first to get user IDs
      print("Fetching progress data to get user IDs...")
      
      api_url = "https://api.feedbackfruits.com/v1/progresses"
      params = {
        'filter[progressable_type]': 'Task',
        'filter[progressable_id]': args.task_id,
        'filter[actor_type]': 'Person',
        'page[number]': 1
      }
      
      headers = {'Accept': 'application/json'}
      if args.token:
        headers['Authorization'] = f'Bearer {args.token}'
      elif args.cookie:
        headers['Cookie'] = args.cookie
      
      try:
        response = requests.get(api_url, params=params, headers=headers, timeout=30)
        
        if response.status_code == 200:
          data = response.json()
          if 'data' in data:
            for record in data['data']:
              actor_data = record.get('relationships', {}).get('actor', {}).get('data', {})
              actor_id = actor_data.get('id')
              if actor_id:
                user_ids.append(actor_id)
            print(f"Found {len(user_ids)} user IDs from progress data")
            print()
        elif response.status_code == 401:
          print("✗ Authentication required for progress data", file=sys.stderr)
          return
        else:
          print(f"✗ Error fetching progress data: {response.status_code}", file=sys.stderr)
          return
      
      except requests.exceptions.RequestException as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return
    else:
      print("Error: Must provide either --user-ids or --task-id", file=sys.stderr)
      print("Use --task-id to automatically fetch user IDs from progress data", file=sys.stderr)
      return
    
    if not user_ids:
      print("No user IDs found", file=sys.stderr)
      return
    
    # Fetch user information
    api_url = "https://api.feedbackfruits.com/v1/users"
    params = {
      'filter[id]': ','.join(user_ids)
    }
    
    headers = {'Accept': 'application/json'}
    if args.token:
      headers['Authorization'] = f'Bearer {args.token}'
    elif args.cookie:
      headers['Cookie'] = args.cookie
    
    try:
      response = requests.get(api_url, params=params, headers=headers, timeout=30)
      
      if response.status_code == 200:
        data = response.json()
        
        if args.json:
          print(json.dumps(data, indent=2))
        else:
          # Parse and display user data
          if 'data' in data and data['data']:
            print(f"Found {len(data['data'])} users:\n")
            
            for user in data['data']:
              attrs = user.get('attributes', {})
              user_id = user.get('id', 'Unknown')
              
              print(f"User ID: {user_id}")
              print(f"  Name: {attrs.get('name', 'N/A')}")
              print(f"  Email: {attrs.get('email', 'N/A')}")
              
              # Show LTI user ID if available
              lti_user_id = attrs.get('lti_user_id')
              if lti_user_id:
                print(f"  LTI User ID: {lti_user_id}")
              
              # Show any other available attributes
              for key, value in attrs.items():
                if key not in ['name', 'email', 'lti_user_id'] and value:
                  print(f"  {key}: {value}")
              
              print()
          else:
            print("No user data found.")
      
      elif response.status_code == 401:
        print("✗ Authentication required")
        print()
        print("Provide authentication with --token or --cookie")
        print("See: canvaslms fbf progress --help for instructions")
      
      else:
        print(f"✗ Unexpected response: {response.status_code}")
        print(f"Response: {response.text[:500]}")
    
    except requests.exceptions.RequestException as e:
      print(f"✗ Error: {e}", file=sys.stderr)
    
    print()
@


\section{The current-user command}

The [[current-user]] command fetches information about the currently 
authenticated user.

<<add fbf current-user command>>=
parser_current = fbf_subparsers.add_parser("current-user",
  help="Show information about the current authenticated user")
parser_current.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_current.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_current.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_current.set_defaults(func=current_user_command)
@

<<functions>>=
def current_user_command(config, canvas, args):
  """Fetch current user information"""
  api_url = "https://api.feedbackfruits.com/v1/users/current"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        user = data.get('data', {})
        attrs = user.get('attributes', {})
        
        print("Current User:")
        print(f"  ID: {user.get('id')}")
        print(f"  Name: {attrs.get('name')}")
        print(f"  Created: {attrs.get('created-at')}")
        
        # Show preferences
        prefs = attrs.get('preferences', {})
        if prefs:
          print(f"\n  Preferences:")
          for key, value in prefs.items():
            print(f"    {key}: {value}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
      print("Provide --token or --cookie")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
      print(response.text[:500])
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The course command}

The [[course]] command fetches information about a FeedbackFruits course.

<<add fbf course command>>=
parser_course = fbf_subparsers.add_parser("course",
  help="Show information about a FeedbackFruits course")
parser_course.add_argument("--course-id", dest="course_id", required=True,
  help="FeedbackFruits course UUID")
parser_course.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_course.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_course.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_course.set_defaults(func=course_command)
@

<<functions>>=
def course_command(config, canvas, args):
  """Fetch FeedbackFruits course information"""
  api_url = f"https://api.feedbackfruits.com/v1/lti/courses/{args.course_id}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        course = data.get('data', {})
        attrs = course.get('attributes', {})
        
        print("Course Information:")
        print(f"  ID: {course.get('id')}")
        print(f"  Name: {attrs.get('name')}")
        print(f"  Code: {attrs.get('code')}")
        print(f"  Role: {attrs.get('role')}")
        print(f"  Enrolled: {attrs.get('enrolled')}")
        print(f"  Participants: {attrs.get('participants-count')}")
        print(f"  Created: {attrs.get('created-at')}")
        
        # Show sync status
        if attrs.get('enrollments-sync-completed-at'):
          print(f"\n  Last enrollment sync:")
          print(f"    Completed: {attrs.get('enrollments-sync-completed-at')}")
          print(f"    Count: {attrs.get('enrollments-sync-count')}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Course not found: {args.course_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The activity command}

The [[activity]] command fetches information about a FeedbackFruits activity.

<<add fbf activity command>>=
parser_activity = fbf_subparsers.add_parser("activity",
  help="Show information about a FeedbackFruits activity")
assignments.add_assignment_option(parser_activity, ungraded=False, required=False)
parser_activity.add_argument("--activity-id", dest="activity_id",
  help="FeedbackFruits activity UUID (if not using Canvas assignment)")
parser_activity.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_activity.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_activity.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_activity.set_defaults(func=activity_command)
@

<<functions>>=
def activity_command(config, canvas, args):
  """Fetch FeedbackFruits activity information"""
  
  # Get activity ID from Canvas assignment or command line
  activity_id = args.activity_id
  
  if not activity_id and (args.course or args.assignment or args.assignment_group):
    assignment_list = assignments.process_assignment_option(canvas, args)
    
    for assignment in assignment_list:
      if 'external_tool' not in assignment.submission_types:
        continue
      
      if hasattr(assignment, 'external_tool_tag_attributes'):
        attrs = assignment.external_tool_tag_attributes
        # Extract activity ID from the code parameter
        code = attrs.get('custom_params', {}).get('code')
        if code:
          # The code is the activity code, we need to find the activity
          print(f"Assignment: {assignment.name}")
          print(f"Activity code: {code}")
          print("Note: Use the activity ID from browser inspection")
          return
  
  if not activity_id:
    print("Error: Must provide --activity-id or Canvas assignment", file=sys.stderr)
    return
  
  api_url = f"https://api.feedbackfruits.com/v1/activities/{activity_id}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        activity = data.get('data', {})
        attrs = activity.get('attributes', {})
        rels = activity.get('relationships', {})
        
        print("Activity Information:")
        print(f"  ID: {activity.get('id')}")
        print(f"  Title: {attrs.get('title')}")
        print(f"  Tool: {attrs.get('tool')}")
        print(f"  Code: {attrs.get('code')}")
        print(f"  Created: {attrs.get('created-at')}")
        print(f"  Published: {attrs.get('published-at')}")
        print(f"  Views: {attrs.get('views-count')}")
        print(f"  Comments: {attrs.get('comments-count')}")
        
        # Show tasks
        tasks = rels.get('tasks', {}).get('data', [])
        if tasks:
          print(f"\n  Tasks ({len(tasks)}):")
          for task in tasks:
            print(f"    - {task.get('type')}: {task.get('id')}")
        
        # Show course
        course = rels.get('course', {}).get('data', {})
        if course:
          print(f"\n  Course:")
          print(f"    ID: {course.get('id')}")
          print(f"    Type: {course.get('type')}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Activity not found: {activity_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The task command}

The [[task]] command fetches information about a specific task within an activity.

<<add fbf task command>>=
parser_task = fbf_subparsers.add_parser("task",
  help="Show information about a specific task")
parser_task.add_argument("--task-id", dest="task_id", required=True,
  help="FeedbackFruits task UUID")
parser_task.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_task.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_task.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_task.set_defaults(func=task_command)
@

<<functions>>=
def task_command(config, canvas, args):
  """Fetch FeedbackFruits task information"""
  api_url = f"https://api.feedbackfruits.com/v1/tasks/{args.task_id}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        task = data.get('data', {})
        attrs = task.get('attributes', {})
        
        print("Task Information:")
        print(f"  ID: {task.get('id')}")
        print(f"  Type: {task.get('type')}")
        print(f"  Created: {attrs.get('created-at')}")
        
        if attrs.get('deadline-at'):
          print(f"  Deadline: {attrs.get('deadline-at')}")
        
        # Show description
        desc = attrs.get('description')
        if desc:
          if isinstance(desc, dict) and 'ops' in desc:
            # Quill format
            print(f"\n  Description:")
            for op in desc.get('ops', []):
              text = op.get('insert', '').strip()
              if text:
                print(f"    {text}")
          else:
            print(f"  Description: {desc}")
        
        # Show rubric if present
        rubric = attrs.get('rubric')
        if rubric:
          print(f"\n  Rubric:")
          if isinstance(rubric, dict):
            for key, value in rubric.items():
              print(f"    {key}: {value}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Task not found: {args.task_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The my-progress command}

The [[my-progress]] command fetches the current user's progress on a specific 
activity. This is different from the [[progress]] command which fetches all 
students' progress on a task.

<<add fbf my-progress command>>=
parser_myprogress = fbf_subparsers.add_parser("my-progress",
  help="Show the current user's progress on an activity")
parser_myprogress.add_argument("--progress-id", dest="progress_id",
  help="FeedbackFruits progress UUID (from activity's relationships)")
parser_myprogress.add_argument("--activity-id", dest="activity_id",
  help="Get progress ID from activity (requires --token)")
parser_myprogress.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_myprogress.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_myprogress.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_myprogress.set_defaults(func=my_progress_command)
@

<<functions>>=
def my_progress_command(config, canvas, args):
  """Fetch current user's progress on an activity"""
  
  progress_id = args.progress_id
  
  # If activity ID provided, fetch it to get progress ID
  if args.activity_id and not progress_id:
    activity_url = f"https://api.feedbackfruits.com/v1/activities/{args.activity_id}"
    
    headers = {'Accept': 'application/json'}
    if args.token:
      headers['Authorization'] = f'Bearer {args.token}'
    elif args.cookie:
      headers['Cookie'] = args.cookie
    
    try:
      response = requests.get(activity_url, headers=headers, timeout=30)
      
      if response.status_code == 200:
        activity_data = response.json()
        activity = activity_data.get('data', {})
        rels = activity.get('relationships', {})
        
        progress_data = rels.get('progress', {}).get('data')
        if progress_data:
          progress_id = progress_data.get('id')
          print(f"Found progress ID from activity: {progress_id}")
          print()
        else:
          print("No progress found for current user on this activity", file=sys.stderr)
          return
      else:
        print(f"[FAIL] Could not fetch activity: {response.status_code}", file=sys.stderr)
        return
    
    except requests.exceptions.RequestException as e:
      print(f"[FAIL] Error fetching activity: {e}", file=sys.stderr)
      return
  
  if not progress_id:
    print("Error: Must provide --progress-id or --activity-id", file=sys.stderr)
    return
  
  # Fetch the progress
  api_url = f"https://api.feedbackfruits.com/v1/progresses/{progress_id}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        progress = data.get('data', {})
        attrs = progress.get('attributes', {})
        rels = progress.get('relationships', {})
        
        print("My Progress:")
        print(f"  ID: {progress.get('id')}")
        print(f"  Created: {attrs.get('created-at')}")
        print(f"  Updated: {attrs.get('updated-at')}")
        
        if attrs.get('percentage') is not None:
          print(f"  Completion: {attrs.get('percentage')}%")
        
        if attrs.get('status'):
          print(f"  Status: {attrs.get('status')}")
        
        # Show related activity/task
        progressable = rels.get('progressable', {}).get('data')
        if progressable:
          print(f"\n  Activity/Task:")
          print(f"    Type: {progressable.get('type')}")
          print(f"    ID: {progressable.get('id')}")
        
        # Show actor (user)
        actor = rels.get('actor', {}).get('data')
        if actor:
          print(f"\n  User:")
          print(f"    Type: {actor.get('type')}")
          print(f"    ID: {actor.get('id')}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Progress not found: {progress_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The appearances command}

The [[appearances]] command fetches user appearance/activity records for a 
course, showing when users were last active. This is useful for tracking 
engagement and attendance.

<<add fbf appearances command>>=
parser_appearances = fbf_subparsers.add_parser("appearances",
  help="Show when users last appeared/were active in a course")
parser_appearances.add_argument("--course-id", dest="course_id", required=True,
  help="FeedbackFruits course UUID")
parser_appearances.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_appearances.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_appearances.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_appearances.set_defaults(func=appearances_command)
@

<<functions>>=
def appearances_command(config, canvas, args):
  """Fetch user appearance/activity records for a course"""
  api_url = f"https://api.feedbackfruits.com/v1/courses/{args.course_id}/appearances?include=user"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        appearances = data.get('data', [])
        included = data.get('included', [])
        
        # Build user lookup
        users_map = {}
        for inc in included:
          if inc.get('type') == 'users':
            users_map[inc['id']] = inc.get('attributes', {})
        
        print(f"Course Appearances: {len(appearances)} records")
        print()
        
        # Sort by last-seen-at (most recent first)
        sorted_appearances = sorted(
          appearances,
          key=lambda x: x.get('attributes', {}).get('last-seen-at', ''),
          reverse=True
        )
        
        for appearance in sorted_appearances:
          attrs = appearance.get('attributes', {})
          rels = appearance.get('relationships', {})
          
          # Get user info
          user_rel = rels.get('user', {}).get('data', {})
          user_id = user_rel.get('id')
          user_info = users_map.get(user_id, {})
          user_name = user_info.get('name', 'Unknown')
          
          print(f"User: {user_name}")
          print(f"  User ID: {user_id}")
          print(f"  Created: {attrs.get('created-at', 'N/A')}")
          print(f"  Last seen: {attrs.get('last-seen-at', 'N/A')}")
          print()
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Course not found: {args.course_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The course-users command}

The [[course-users]] command fetches all users enrolled in a specific FeedbackFruits 
course. It supports filtering by admin and bot status, allowing you to get only 
human students, only admins, etc.

<<add fbf course-users command>>=
parser_course_users = fbf_subparsers.add_parser("course-users",
  help="List users enrolled in a FeedbackFruits course")
parser_course_users.add_argument("--course-id", dest="course_id", required=True,
  help="FeedbackFruits course UUID")
parser_course_users.add_argument("--admin", dest="admin", 
  choices=['true', 'false'], default='true',
  help="Include admin users (default: true)")
parser_course_users.add_argument("--bot", dest="bot", 
  choices=['true', 'false'], default='false',
  help="Include bot users (default: false)")
parser_course_users.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_course_users.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_course_users.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_course_users.set_defaults(func=course_users_command)
@

<<functions>>=
def course_users_command(config, canvas, args):
  """Fetch users enrolled in a FeedbackFruits course"""
  api_url = f"https://api.feedbackfruits.com/v1/courses/{args.course_id}/users"
  params = {
    'admin': args.admin,
    'bot': args.bot
  }
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, params=params, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        users = data.get('data', [])
        print(f"Course Users: {len(users)} total")
        print()
        
        for user in users:
          user_id = user.get('id')
          attrs = user.get('attributes', {})
          
          print(f"User: {attrs.get('name', 'N/A')}")
          print(f"  ID: {user_id}")
          print(f"  Email: {attrs.get('email', 'N/A')}")
          print(f"  Role: {attrs.get('role', 'N/A')}")
          
          # Show additional attributes if present
          if attrs.get('locale'):
            print(f"  Locale: {attrs['locale']}")
          if attrs.get('avatar-url'):
            print(f"  Avatar: {attrs['avatar-url']}")
          
          print()
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Course not found: {args.course_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The activity-flags command}

The [[activity-flags]] command fetches feature flags for an activity, showing 
which features are enabled or disabled.

<<add fbf activity-flags command>>=
parser_flags = fbf_subparsers.add_parser("activity-flags",
  help="Show feature flags for an activity")
parser_flags.add_argument("--activity-id", dest="activity_id", required=True,
  help="FeedbackFruits activity UUID")
parser_flags.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_flags.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_flags.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_flags.set_defaults(func=activity_flags_command)
@

<<functions>>=
def activity_flags_command(config, canvas, args):
  """Fetch activity feature flags"""
  api_url = f"https://api.feedbackfruits.com/v1/activities/{args.activity_id}/flags"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        flags = data.get('data', [])
        
        if not flags:
          print("No flags found for this activity")
        else:
          print(f"Activity Flags: {len(flags)} found")
          print()
          
          for flag in flags:
            attrs = flag.get('attributes', {})
            
            print(f"Flag: {flag.get('id')}")
            print(f"  Type: {flag.get('type')}")
            
            # Show all attributes
            for key, value in attrs.items():
              print(f"  {key}: {value}")
            
            print()
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Activity not found: {args.activity_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The mark-notifications-seen command}

The [[mark-notifications-seen]] command marks all notifications as seen/read for 
an activity. This is a PUT request that updates the notification status.

<<add fbf mark-notifications-seen command>>=
parser_mark_notifs = fbf_subparsers.add_parser("mark-notifications-seen",
  help="Mark all notifications as seen for an activity")
parser_mark_notifs.add_argument("--activity-id", dest="activity_id", required=True,
  help="FeedbackFruits activity UUID")
parser_mark_notifs.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_mark_notifs.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_mark_notifs.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_mark_notifs.set_defaults(func=mark_notifications_seen_command)
@

<<functions>>=
def mark_notifications_seen_command(config, canvas, args):
  """Mark all notifications as seen for an activity"""
  api_url = f"https://api.feedbackfruits.com/v1/activities/{args.activity_id}/notifications/seen"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.put(api_url, headers=headers, timeout=30)
    
    if response.status_code in [200, 201, 202, 204]:
      print(f"✓ Notifications marked as seen for activity {args.activity_id}")
      
      if response.text and response.status_code != 204:
        data = response.json()
        if args.json:
          print(json.dumps(data, indent=2))
        else:
          # Show response if provided
          if data:
            print()
            print("Response:")
            print(json.dumps(data, indent=2))
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Activity not found: {args.activity_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
      print(response.text[:500])
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The notifications command}

The [[notifications]] command fetches notifications for an activity, showing 
comments and other activity updates for the current user.

<<add fbf notifications command>>=
parser_notifications = fbf_subparsers.add_parser("notifications",
  help="Show notifications for an activity")
parser_notifications.add_argument("--activity-id", dest="activity_id", required=True,
  help="FeedbackFruits activity UUID")
parser_notifications.add_argument("--page", dest="page", type=int, default=1,
  help="Page number (default: 1)")
parser_notifications.add_argument("--page-size", dest="page_size", type=int, default=10,
  help="Results per page (default: 10)")
parser_notifications.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_notifications.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_notifications.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_notifications.set_defaults(func=notifications_command)
@

<<functions>>=
def notifications_command(config, canvas, args):
  """Fetch notifications for an activity"""
  api_url = f"https://api.feedbackfruits.com/v1/notifications"
  params = {
    'activity_id': args.activity_id,
    'include': 'subject',
    'page[number]': args.page,
    'page[size]': args.page_size
  }
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, params=params, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        notifications = data.get('data', [])
        included = data.get('included', [])
        meta = data.get('meta', {})
        
        # Build subject lookup
        subjects_map = {}
        for inc in included:
          subjects_map[inc['id']] = inc
        
        print(f"Notifications: {len(notifications)} on this page")
        print(f"Total pages: {meta.get('total-pages', 'N/A')}")
        print(f"Unseen count: {meta.get('unseen-count', 0)}")
        print()
        
        for notif in notifications:
          attrs = notif.get('attributes', {})
          rels = notif.get('relationships', {})
          
          print(f"Notification ID: {notif.get('id')}")
          print(f"  Created: {attrs.get('created-at', 'N/A')}")
          
          if attrs.get('read') is not None:
            print(f"  Read: {attrs.get('read')}")
          
          if attrs.get('kind'):
            print(f"  Kind: {attrs.get('kind')}")
          
          if attrs.get('action'):
            print(f"  Action: {attrs.get('action')}")
          
          # Subject details
          subject_rel = rels.get('subject', {}).get('data', {})
          if subject_rel:
            subject_id = subject_rel.get('id')
            subject_type = subject_rel.get('type')
            print(f"  Subject: {subject_type}")
            
            # Get subject details from included
            subject = subjects_map.get(subject_id, {})
            if subject:
              subject_attrs = subject.get('attributes', {})
              if subject_type == 'comments':
                text = subject_attrs.get('text', {})
                if isinstance(text, dict) and 'ops' in text:
                  # Quill format
                  for op in text.get('ops', [])[:1]:  # First op only
                    comment_text = op.get('insert', '').strip()[:100]
                    if comment_text:
                      print(f"    Comment: {comment_text}...")
          
          print()
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Activity not found: {args.activity_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The multimedia command}

The [[multimedia]] command fetches details about multimedia materials (videos, 
audio, etc.) used in activities.

<<add fbf multimedia command>>=
parser_multimedia = fbf_subparsers.add_parser("multimedia",
  help="Show multimedia material details")
parser_multimedia.add_argument("--material-id", dest="material_id", required=True,
  help="FeedbackFruits multimedia material UUID")
parser_multimedia.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_multimedia.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_multimedia.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_multimedia.set_defaults(func=multimedia_command)
@

<<functions>>=
def multimedia_command(config, canvas, args):
  """Fetch multimedia material details"""
  api_url = f"https://api.feedbackfruits.com/v1/multimedia/materials/{args.material_id}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        material = data.get('data', {})
        attrs = material.get('attributes', {})
        rels = material.get('relationships', {})
        
        print("Multimedia Material:")
        print(f"  ID: {material.get('id')}")
        print(f"  Type: {material.get('type')}")
        print(f"  Created: {attrs.get('created-at', 'N/A')}")
        print(f"  Updated: {attrs.get('updated-at', 'N/A')}")
        
        if attrs.get('category'):
          print(f"  Category: {attrs.get('category')}")
        
        if attrs.get('views-count') is not None:
          print(f"  Views: {attrs.get('views-count')}")
        
        if attrs.get('copyrighted') is not None:
          print(f"  Copyrighted: {attrs.get('copyrighted')}")
        
        if attrs.get('disable-subtitles') is not None:
          print(f"  Subtitles disabled: {attrs.get('disable-subtitles')}")
        
        if attrs.get('custom-media-alternatives-count'):
          print(f"  Media alternatives: {attrs.get('custom-media-alternatives-count')}")
        
        if attrs.get('viewed') is not None:
          print(f"  Viewed by user: {attrs.get('viewed')}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Material not found: {args.material_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The questions command}

The [[questions]] command fetches questions associated with a multimedia material.

<<add fbf questions command>>=
parser_questions = fbf_subparsers.add_parser("questions",
  help="Show questions associated with multimedia material")
parser_questions.add_argument("--material-id", dest="material_id", required=True,
  help="FeedbackFruits multimedia material UUID")
parser_questions.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_questions.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_questions.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_questions.set_defaults(func=questions_command)
@

<<functions>>=
def questions_command(config, canvas, args):
  """Fetch questions for a multimedia material"""
  api_url = f"https://api.feedbackfruits.com/v1/multimedia/materials/{args.material_id}/questions"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        questions = data.get('data', [])
        
        print(f"Questions: {len(questions)} found")
        print()
        
        for i, question in enumerate(questions, 1):
          attrs = question.get('attributes', {})
          
          print(f"Question {i}:")
          print(f"  ID: {question.get('id')}")
          print(f"  Type: {question.get('type')}")
          print(f"  Created: {attrs.get('created-at', 'N/A')}")
          
          if attrs.get('admin') is not None:
            print(f"  Admin: {attrs.get('admin')}")
          
          if attrs.get('views-count') is not None:
            print(f"  Views: {attrs.get('views-count')}")
          
          if attrs.get('comments-count') is not None:
            print(f"  Comments: {attrs.get('comments-count')}")
          
          if attrs.get('upvotes-count') is not None:
            print(f"  Upvotes: {attrs.get('upvotes-count')}")
          
          print()
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Material not found: {args.material_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The grade-facets command}

The [[grade-facets]] command fetches the grading rubric facets/criteria for a task.

<<add fbf grade-facets command>>=
parser_grade_facets = fbf_subparsers.add_parser("grade-facets",
  help="Show grading rubric facets/criteria for a task")
parser_grade_facets.add_argument("--task-id", dest="task_id", required=True,
  help="FeedbackFruits task UUID")
parser_grade_facets.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_grade_facets.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_grade_facets.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_grade_facets.set_defaults(func=grade_facets_command)
@

<<functions>>=
def grade_facets_command(config, canvas, args):
  """Fetch grading rubric facets for a task"""
  api_url = f"https://api.feedbackfruits.com/v1/tasks/{args.task_id}/grade_facets"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        facets = data.get('data', [])
        
        if not facets:
          print("No grade facets found for this task")
        else:
          print(f"Grade Facets: {len(facets)} found")
          print()
          
          for i, facet in enumerate(facets, 1):
            attrs = facet.get('attributes', {})
            
            print(f"Facet {i}:")
            print(f"  ID: {facet.get('id')}")
            print(f"  Type: {facet.get('type')}")
            
            if attrs.get('name'):
              print(f"  Name: {attrs.get('name')}")
            
            if attrs.get('description'):
              print(f"  Description: {attrs.get('description')}")
            
            if attrs.get('weight') is not None:
              print(f"  Weight: {attrs.get('weight')}")
            
            if attrs.get('max-points') is not None:
              print(f"  Max points: {attrs.get('max-points')}")
            
            print()
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Task not found: {args.task_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The lti-grade command}

The [[lti-grade]] command fetches individual or bulk LTI grade records that are synced 
back to Canvas. This provides detailed information about specific grade entries.

The command supports two modes:
\begin{itemize}
\item Single grade: [[--grade-id <uuid>]]
\item Bulk grades: [[--grade-ids <uuid1>,<uuid2>,...]]
\end{itemize}

The bulk mode uses the [[filter[id]]] query parameter, similar to the [[users]] command,
allowing efficient batch retrieval of multiple grade records.

<<add fbf lti-grade command>>=
parser_lti_grade = fbf_subparsers.add_parser("lti-grade",
  help="Show individual LTI grade record details")
parser_lti_grade.add_argument("--grade-id", dest="grade_id",
  help="FeedbackFruits LTI grade UUID (single grade)")
parser_lti_grade.add_argument("--grade-ids", dest="grade_ids",
  help="Comma-separated list of grade UUIDs (bulk fetch)")
parser_lti_grade.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_lti_grade.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_lti_grade.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_lti_grade.set_defaults(func=lti_grade_command)
@

<<functions>>=
def lti_grade_command(config, canvas, args):
  """Fetch individual or bulk LTI grade records"""
  
  # Validate arguments
  if not args.grade_id and not args.grade_ids:
    print("[FAIL] Either --grade-id or --grade-ids is required", file=sys.stderr)
    return
  
  if args.grade_id and args.grade_ids:
    print("[FAIL] Use either --grade-id or --grade-ids, not both", file=sys.stderr)
    return
  
  # Build API URL
  if args.grade_id:
    # Single grade fetch
    api_url = f"https://api.feedbackfruits.com/v1/lti/grades/{args.grade_id}"
  else:
    # Bulk grades fetch with filter
    grade_ids = args.grade_ids.replace(' ', '')  # Remove spaces
    api_url = f"https://api.feedbackfruits.com/v1/lti/grades?filter[id]={grade_ids}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        # Handle both single grade (dict) and bulk (list) responses
        grade_data = data.get('data', {})
        
        if isinstance(grade_data, list):
          # Bulk response
          print(f"LTI Grades: {len(grade_data)} found")
          print()
          
          for i, grade in enumerate(grade_data, 1):
            print(f"Grade {i}:")
            print_grade_details(grade, indent="  ")
            print()
        else:
          # Single grade response
          print("LTI Grade Record:")
          print_grade_details(grade_data, indent="  ")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Grade not found: {args.grade_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)

def print_grade_details(grade, indent=""):
  """Helper function to print grade details"""
  attrs = grade.get('attributes', {})
  rels = grade.get('relationships', {})
  
  print(f"{indent}ID: {grade.get('id')}")
  print(f"{indent}Type: {grade.get('type')}")
  
  # Grade details
  if attrs.get('score') is not None:
    print(f"{indent}Score: {attrs.get('score')}", end='')
    if attrs.get('score-maximum') is not None:
      print(f"/{attrs.get('score-maximum')}")
    else:
      print()
  elif attrs.get('score-maximum') is not None:
    print(f"{indent}Maximum: {attrs.get('score-maximum')}")
  
  if attrs.get('activity-progress'):
    print(f"{indent}Activity progress: {attrs.get('activity-progress')}")
  
  if attrs.get('grading-progress'):
    print(f"{indent}Grading progress: {attrs.get('grading-progress')}")
  
  if attrs.get('created-at'):
    print(f"{indent}Created: {attrs.get('created-at')}")
  
  if attrs.get('updated-at'):
    print(f"{indent}Updated: {attrs.get('updated-at')}")
  
  # Relationships
  user_rel = rels.get('user', {}).get('data', {})
  if user_rel:
    print(f"{indent}User: {user_rel.get('id')}")
  
  activity_rel = rels.get('activity', {}).get('data', {})
  if activity_rel:
    print(f"{indent}Activity: {activity_rel.get('type')} - {activity_rel.get('id')}")
  
  task_rel = rels.get('task', {}).get('data', {})
  if task_rel:
    print(f"{indent}Task: {task_rel.get('id')}")
  
  link_rel = rels.get('resource-link', {}).get('data', {})
  if link_rel:
    print(f"{indent}Resource link: {link_rel.get('id')}")
@


\section{The group command}

The [[group]] command fetches information about a student group in FeedbackFruits.
Groups can be used for collaborative activities and are typically synced from Canvas.

<<add fbf group command>>=
parser_group = fbf_subparsers.add_parser("group",
  help="Show group information and members")
parser_group.add_argument("--group-id", dest="group_id", required=True,
  help="FeedbackFruits group UUID")
parser_group.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_group.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_group.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_group.set_defaults(func=group_command)
@

<<functions>>=
def group_command(config, canvas, args):
  """Fetch group information"""
  api_url = f"https://api.feedbackfruits.com/v1/groups/{args.group_id}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        group = data.get('data', {})
        attrs = group.get('attributes', {})
        rels = group.get('relationships', {})
        
        print("Group Information:")
        print(f"  ID: {group.get('id')}")
        print(f"  Type: {group.get('type')}")
        print(f"  Label: {attrs.get('label')}")
        print()
        
        # Course relationship
        course_rel = rels.get('course', {}).get('data', {})
        if course_rel:
          print(f"Course: {course_rel.get('id')}")
        
        # Leader relationship
        leader_rel = rels.get('leader', {}).get('data')
        if leader_rel:
          print(f"Leader: {leader_rel.get('id')}")
        
        # Group sets
        group_sets = rels.get('group-sets', {}).get('data', [])
        if group_sets:
          print(f"Group sets: {len(group_sets)}")
          for gs in group_sets:
            print(f"  - {gs.get('id')}")
        
        # Users/members
        users = rels.get('users', {}).get('data', [])
        if users:
          print()
          print(f"Members: {len(users)}")
          for user in users:
            print(f"  - {user.get('type')}: {user.get('id')}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Group not found: {args.group_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The sync command}

The [[sync]] command triggers a data synchronization between Canvas and FeedbackFruits
for a specific course. This PUT request initiates syncing of:
\begin{itemize}
\item Course roster (enrollments)
\item Student groups
\item Assignment resource links
\item Other LTI data
\end{itemize}

After syncing, updated data (like new groups) becomes available through the API.

<<add fbf sync command>>=
parser_sync = fbf_subparsers.add_parser("sync",
  help="Trigger course data sync from Canvas")
parser_sync.add_argument("--course-id", dest="course_id", required=True,
  help="FeedbackFruits course UUID")
parser_sync.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_sync.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_sync.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_sync.set_defaults(func=sync_command)
@

<<functions>>=
def sync_command(config, canvas, args):
  """Trigger course sync from Canvas"""
  api_url = f"https://api.feedbackfruits.com/v1/lti/courses/{args.course_id}/sync"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.put(api_url, headers=headers, timeout=30)
    
    if response.status_code in [200, 201, 202]:
      print(f"✓ Sync initiated for course {args.course_id}")
      
      if response.text:
        data = response.json()
        if args.json:
          print(json.dumps(data, indent=2))
        else:
          # Show sync status/results if provided
          if data:
            print()
            print("Sync response:")
            print(json.dumps(data, indent=2))
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Course not found: {args.course_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
      print(response.text[:500])
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The deployment command}

The [[deployment]] command fetches information about the LTI deployment/environment.

\textbf{Note}: There is also an [[/v1/institutions/{uuid}]] endpoint that provides 
similar information at the institution level. The deployment endpoint is typically 
more useful as it includes both institution details and LTI-specific configuration.

<<add fbf deployment command>>=
parser_deployment = fbf_subparsers.add_parser("deployment",
  help="Show LTI deployment/environment information")
parser_deployment.add_argument("--deployment-id", dest="deployment_id", required=True,
  help="FeedbackFruits deployment/environment UUID")
parser_deployment.add_argument("--token", dest="token",
  help="JWT Bearer token from browser")
parser_deployment.add_argument("--cookie", dest="cookie",
  help="Session cookie from browser")
parser_deployment.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_deployment.set_defaults(func=deployment_command)
@

<<functions>>=
def deployment_command(config, canvas, args):
  """Fetch FeedbackFruits LTI deployment information"""
  # Try both endpoints (environments and deployments are the same)
  api_url = f"https://api.feedbackfruits.com/v1/lti/deployments/{args.deployment_id}"
  
  headers = {'Accept': 'application/json'}
  if args.token:
    headers['Authorization'] = f'Bearer {args.token}'
  elif args.cookie:
    headers['Cookie'] = args.cookie
  
  try:
    response = requests.get(api_url, headers=headers, timeout=30)
    
    if response.status_code == 200:
      data = response.json()
      
      if args.json:
        print(json.dumps(data, indent=2))
      else:
        deployment = data.get('data', {})
        attrs = deployment.get('attributes', {})
        
        print("LTI Deployment Information:")
        print(f"  ID: {deployment.get('id')}")
        print(f"  Name: {attrs.get('name')}")
        print(f"  LMS Type: {attrs.get('lms-type')}")
        print(f"  URL: {attrs.get('url')}")
        print(f"  Identity Provider: {attrs.get('identity-provider')}")
        print(f"  Created: {attrs.get('created-at')}")
        
        # Show settings
        settings = attrs.get('settings', {})
        if settings:
          print(f"\n  Settings:")
          for key, value in settings.items():
            if isinstance(value, bool) or isinstance(value, str) and len(str(value)) < 50:
              print(f"    {key}: {value}")
    
    elif response.status_code == 401:
      print("[FAIL] Authentication required")
    elif response.status_code == 404:
      print(f"[FAIL] Deployment not found: {args.deployment_id}")
    else:
      print(f"[FAIL] Unexpected response: {response.status_code}")
  
  except requests.exceptions.RequestException as e:
    print(f"[FAIL] Error: {e}", file=sys.stderr)
@


\section{The refresh-token command}

The [[refresh-token]] command refreshes an expired access token using a 
refresh token. This is useful for maintaining long-term access without 
requiring manual browser token extraction.

<<add fbf refresh-token command>>=
parser_refresh = fbf_subparsers.add_parser("refresh-token",
  help="Refresh an expired access token using a refresh token")
parser_refresh.add_argument("--refresh-token", dest="refresh_token", required=True,
  help="Refresh token from browser (valid for 14 days)")
parser_refresh.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_refresh.set_defaults(func=refresh_token_command)
@

<<functions>>=
def refresh_token_command(config, canvas, args):
  """Refresh an access token using a refresh token"""
  import base64
  
  print("Refreshing access token...")
  print()
  
  # Decode refresh token to show expiry
  try:
    parts = args.refresh_token.split('.')
    payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
    
    import time
    exp_time = payload.get('exp', 0)
    current_time = time.time()
    
    if exp_time and current_time < exp_time:
      remaining = (exp_time - current_time) / 86400
      print(f"Refresh token valid for {remaining:.1f} more days")
    elif exp_time:
      print(f"Warning: Refresh token expired {(current_time - exp_time)/86400:.1f} days ago")
    print()
  except Exception as e:
    print(f"Warning: Could not decode refresh token: {e}")
    print()
  
  # Make refresh request
  url = "https://accounts.feedbackfruits.com/auth/token"
  data = {
    'grant_type': 'refresh_token',
    'refresh_token': args.refresh_token,
    'client_id': 'FeedbackFruits'
  }
  
  try:
    response = requests.post(url, data=data, timeout=30)
    
    if response.status_code == 200:
      result = response.json()
      
      if args.json:
        print(json.dumps(result, indent=2))
      else:
        print("✓ Token refresh successful!")
        print()
        
        if 'access_token' in result:
          access_token = result['access_token']
          print("New access token:")
          print(access_token)
          print()
          
          # Decode and show expiry
          try:
            parts = access_token.split('.')
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
            
            exp_time = payload.get('exp', 0)
            iat_time = payload.get('iat', 0)
            
            if exp_time and iat_time:
              import time
              valid_for = (exp_time - iat_time) / 60
              print(f"Valid for: {valid_for:.1f} minutes")
              print(f"Expires at: {time.ctime(exp_time)}")
              print()
          except Exception as e:
            pass
        
        if 'refresh_token' in result:
          print("New refresh token:")
          print(result['refresh_token'])
          print()
        
        if 'expires_in' in result:
          print(f"Expires in: {result['expires_in']} seconds ({result['expires_in']/60:.1f} minutes)")
          print()
        
        print("Usage:")
        print(f"  canvaslms fbf progress ... --token '{result.get('access_token', '...')[:50]}...'")
    
    elif response.status_code == 400:
      print("✗ Token refresh failed: Invalid or expired refresh token")
      print()
      error_data = response.json()
      print(f"Error: {error_data.get('message', 'Unknown error')}")
      print()
      print("The refresh token may be expired (valid for 14 days).")
      print("You need to extract a new refresh token from your browser.")
    
    else:
      print(f"✗ Unexpected response: {response.status_code}")
      print(f"Response: {response.text}")
  
  except requests.exceptions.RequestException as e:
    print(f"✗ Error: {e}", file=sys.stderr)
@


\section{The rubric command}

The [[rubric]] command extracts and displays the rubric in detail.

<<add fbf rubric command>>=
parser_rubric = fbf_subparsers.add_parser("rubric",
  help="Show detailed rubric for a FeedbackFruits assignment")
assignments.add_assignment_option(parser_rubric, ungraded=False, required=True)
parser_rubric.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_rubric.set_defaults(func=rubric_command)
@

<<functions>>=
def rubric_command(config, canvas, args):
  """Show detailed rubric for a FeedbackFruits assignment"""
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    if args.json:
      if hasattr(assignment, 'rubric'):
        print(json.dumps({
          'name': assignment.name,
          'id': assignment.id,
          'rubric': assignment.rubric,
        }, indent=2))
      else:
        print(json.dumps({
          'name': assignment.name,
          'id': assignment.id,
          'rubric': None,
        }, indent=2))
    else:
      print(f"Assignment: {assignment.name}")
      print(f"Assignment ID: {assignment.id}")
      print()
      
      if hasattr(assignment, 'rubric') and assignment.rubric:
        print("Rubric:")
        for criterion in assignment.rubric:
          print(f"\n  Criterion: {criterion['description']}")
          print(f"  Points: {criterion['points']}")
          
          if criterion.get('long_description'):
            print(f"  Description: {criterion['long_description']}")
          
          print(f"  Ratings:")
          for rating in criterion['ratings']:
            print(f"    - {rating['description']}: {rating['points']} points")
            if rating.get('long_description'):
              print(f"      {rating['long_description']}")
        print()
      else:
        print("No rubric defined for this assignment")
        print()
@


\section{The submissions command}

The [[submissions]] command shows submission data synced from FeedbackFruits.

<<add fbf submissions command>>=
parser_subs = fbf_subparsers.add_parser("submissions",
  help="Show submissions and grades for a FeedbackFruits assignment")
assignments.add_assignment_option(parser_subs, ungraded=False, required=True)
parser_subs.add_argument("--json", action="store_true",
  help="Output raw JSON data")
parser_subs.add_argument("-u", "--user", dest="user_regex",
  help="Filter by user name (regex)")
parser_subs.set_defaults(func=submissions_command)
@

<<functions>>=
def submissions_command(config, canvas, args):
  """Show submissions and grades for a FeedbackFruits assignment"""
  import re
  assignment_list = assignments.process_assignment_option(canvas, args)
  
  for assignment in assignment_list:
    submissions = assignment.get_submissions(include=['user', 'rubric_assessment'])
    
    # Filter by user if requested
    if args.user_regex:
      user_pattern = re.compile(args.user_regex, re.IGNORECASE)
      submissions = [s for s in submissions 
                     if hasattr(s, 'user') and user_pattern.search(s.user['name'])]
    
    if args.json:
      subs_data = []
      for submission in submissions:
        sub_dict = {
          'user_id': submission.user_id,
          'score': submission.score,
          'grade': submission.grade,
          'workflow_state': submission.workflow_state,
          'submitted_at': submission.submitted_at,
        }
        if hasattr(submission, 'user'):
          sub_dict['user_name'] = submission.user['name']
        if hasattr(submission, 'rubric_assessment') and submission.rubric_assessment:
          sub_dict['rubric_assessment'] = submission.rubric_assessment
        subs_data.append(sub_dict)
      
      print(json.dumps({
        'assignment': assignment.name,
        'assignment_id': assignment.id,
        'submissions': subs_data,
      }, indent=2))
    else:
      print(f"Assignment: {assignment.name}")
      print(f"Assignment ID: {assignment.id}")
      print()
      
      for submission in submissions:
        user_name = submission.user['name'] if hasattr(submission, 'user') else f"User {submission.user_id}"
        print(f"Student: {user_name}")
        print(f"  Score: {submission.score}/{assignment.points_possible}")
        print(f"  Grade: {submission.grade}")
        print(f"  Status: {submission.workflow_state}")
        
        if submission.submitted_at:
          print(f"  Submitted: {submission.submitted_at}")
        
        if hasattr(submission, 'rubric_assessment') and submission.rubric_assessment:
          print(f"  Rubric Assessment:")
          for criterion_id, assessment in submission.rubric_assessment.items():
            if isinstance(assessment, dict):
              print(f"    Criterion {criterion_id}: {assessment.get('points', 'N/A')} points")
              if assessment.get('comments'):
                print(f"      Comments: {assessment['comments']}")
        print()
@


\section{Testing and usage examples}

\subsection{Basic testing workflow}

To test this module:

\begin{enumerate}
\item \textbf{Basic info}: Run [[canvaslms fbf info -c COURSE -a ASSIGNMENT]] 
to see LTI configuration

\item \textbf{Find task UUID}: Run [[canvaslms fbf task-id -c COURSE -a ASSIGNMENT --test]] 
to extract and validate the FeedbackFruits task UUID

\item \textbf{Probe API}: Run [[canvaslms fbf probe -c COURSE -a ASSIGNMENT]] 
to test API endpoints

\item \textbf{Get progress data}: 
  \begin{enumerate}
  \item Open the FeedbackFruits activity in your browser while logged into Canvas
  \item Open DevTools (F12) → Network tab
  \item Look for requests to [[api.feedbackfruits.com]]
  \item Copy the JWT token from [[Authorization: Bearer]] header
  \item Copy the task UUID from [[filter[progressable_id]]] parameter
  \item Run [[canvaslms fbf progress -c COURSE -a ASSIGNMENT --task-id UUID --token 'jwt']]
  \end{enumerate}

\item \textbf{Get user information}: Run [[canvaslms fbf users -c COURSE -a ASSIGNMENT --task-id UUID --token 'jwt']] to fetch user details and map FeedbackFruits UUIDs to Canvas users via [[lti_user_id]]

\item \textbf{View rubric}: Run [[canvaslms fbf rubric -c COURSE -a ASSIGNMENT]] 
to see rubric details

\item \textbf{View submissions}: Run [[canvaslms fbf submissions -c COURSE -a ASSIGNMENT]] 
to see grades synced to Canvas
\end{enumerate}

The [[probe]] command with [[--verbose]] flag will show detailed HTTP requests 
and responses, helping to understand FeedbackFruits' API structure.


\section{Working with the progress API}

\subsection{Understanding the response structure}

The [[/v1/progresses]] endpoint returns progress data for students in a 
FeedbackFruits activity. The response follows JSON:API format:

\begin{verbatim}
{
  "data": [
    {
      "id": "...",
      "type": "progresses",
      "attributes": {
        "progression": 75,
        "status": "in_progress",
        "completed": false,
        "updated_at": "2024-10-29T12:00:00Z"
      },
      "relationships": {
        "actor": {
          "data": {
            "id": "...",
            "type": "people"
          }
        }
      }
    }
  ]
}
\end{verbatim}

Key fields:
\begin{itemize}
\item [[progression]]: Percentage complete (0-100)
\item [[status]]: Current status (e.g., [[in_progress]], [[completed]])
\item [[completed]]: Boolean indicating completion
\item [[actor.data.id]]: FeedbackFruits person ID (need to map to Canvas user)
\end{itemize}

\subsection{Authentication approach}

Since the API uses cookie-based authentication rather than API tokens:

\begin{enumerate}
\item \textbf{Manual workflow}: Extract cookies from browser and pass via [[--cookie]]
\item \textbf{Automated workflow}: Implement LTI launch flow to obtain session cookies
\item \textbf{Future improvement}: Store session cookies in keyring for reuse
\end{enumerate}

\subsection{Mapping FeedbackFruits IDs to Canvas users}

The [[actor.data.id]] from FeedbackFruits needs to be mapped to Canvas user IDs. 
Possible approaches:

\begin{enumerate}
\item \textbf{LTI user mapping}: Check if FeedbackFruits provides an endpoint 
to map LTI user IDs to their internal person IDs

\item \textbf{Email matching}: If FeedbackFruits API provides email addresses, 
match with Canvas user emails

\item \textbf{Name matching}: Fuzzy match on display names (least reliable)

\item \textbf{Activity roster}: Check if there's an endpoint like 
[[/v1/activities/:task_id/participants]] that provides the mapping
\end{enumerate}


\section{Discovered API endpoints}

\subsection{Progress endpoint}

Through browser exploration, we've discovered that FeedbackFruits provides a 
progress tracking API:

\begin{verbatim}
GET /v1/progresses?filter[progressable_type]=Task
                   &filter[progressable_id]=<task_uuid>
                   &filter[actor_type]=Person
                   &page[number]=1
\end{verbatim}

The [[progressable_id]] appears to be a UUID (e.g., 
[[6f5c0694-589e-4dec-a57c-8e2f8fc79774]]) that uniquely identifies a 
FeedbackFruits activity/task.

\textbf{Critical finding}: The Canvas [[resource_link_id]] 
([[826bad279e6ef566c19dbbcc5799cba3d4fc42b1]]) is \textit{not} the same as 
the FeedbackFruits task UUID. The mapping between these IDs is not exposed 
through unauthenticated API endpoints.

\subsection{Users endpoint}

FeedbackFruits provides a users endpoint for fetching user information:

\begin{verbatim}
GET /v1/users?filter[id]=<uuid1>,<uuid2>,...
\end{verbatim}

This endpoint accepts a comma-separated list of FeedbackFruits user UUIDs and 
returns user details including:
\begin{itemize}
\item [[name]]: User's display name
\item [[email]]: User's email address
\item [[lti_user_id]]: The LTI user ID from Canvas (for mapping back to Canvas users)
\end{itemize}

\textbf{Key insight}: The [[lti_user_id]] attribute provides the mapping 
between FeedbackFruits user UUIDs and Canvas user IDs, solving the user 
mapping problem!

\subsection{Authentication requirements}

Testing with the [[probe]] command reveals:

\begin{enumerate}
\item \textbf{Bearer token with launch code does not work}: The [[code]] 
parameter from Canvas LTI launch attributes cannot be used directly as a 
Bearer token for API authentication.

\item \textbf{JWT tokens work}: Through browser inspection, we discovered that 
FeedbackFruits uses JWT (JSON Web Tokens) for API authentication. The JWT 
token is obtained during the LTI launch flow.

\item \textbf{JWT structure}: The token contains:
\begin{itemize}
\item [[sub]]: User UUID in FeedbackFruits
\item [[iss]]: "FeedbackFruits Accounts"
\item [[scope]]: ["all"]
\item [[exp]]: Expiration timestamp (30 minutes from issue)
\end{itemize}

\item \textbf{Token types}: FeedbackFruits uses two types of tokens:
\begin{itemize}
\item \textbf{Access token}: JWT for API access, expires after 30 minutes
\item \textbf{Refresh token}: JWT for getting new access tokens, expires after 14 days
\end{itemize}

\item \textbf{Token refresh endpoint}: [[https://accounts.feedbackfruits.com/auth/token]] 
accepts POST requests with:
\begin{itemize}
\item [[grant_type]]: [[refresh_token]]
\item [[refresh_token]]: The refresh token JWT
\item [[client_id]]: [[FeedbackFruits]]
\end{itemize}
Returns a new access token and refresh token.

\item \textbf{No direct token endpoint}: There is no public endpoint to 
exchange the LTI launch code for a JWT token without going through the full 
LTI launch POST flow.
\end{enumerate}

\subsection{Obtaining task UUID}

Since the Canvas [[resource_link_id]] doesn't map directly to the task UUID, 
you must discover it through browser inspection:

\begin{enumerate}
\item Launch the FeedbackFruits activity from Canvas (as a teacher/student)
\item Open browser DevTools (F12) → Network tab
\item Look for API requests to [[api.feedbackfruits.com/v1/activities/]]
\item Extract the activity UUID from the URL
\item Use [[canvaslms fbf activity --activity-id <uuid> --token <jwt>]] to list all tasks
\item The activity contains multiple tasks (instruct, multimedia, reflect, summative-grade)
\item Use the appropriate task UUID for the [[--task-id]] option
\end{enumerate}

\textbf{Example}: An activity returns:
\begin{verbatim}
Tasks (4):
  - instruct-tasks: 4f1827f6-c7e7-4c89-8039-33a8a937d70c
  - multimedia-tasks: bb87b655-54af-4604-8ad7-ac4591bd741c
  - reflect-tasks: 6f5c0694-589e-4dec-a57c-8e2f8fc79774
  - summative-grade-tasks: fd406af5-3144-4c69-bba0-fed9d060cd2a
\end{verbatim}

For progress data, you typically want the [[reflect-tasks]] or 
[[summative-grade-tasks]] UUID.

\subsection{Authentication in browser sessions}

The JWT token is obtained through the LTI launch flow:
\begin{itemize}
\item \textbf{JWT-based}: FeedbackFruits uses JWT tokens for API authentication

\item \textbf{30-minute expiry}: Access tokens expire 30 minutes after issuance

\item \textbf{14-day refresh tokens}: Refresh tokens last 14 days and can obtain 
new access tokens

\item \textbf{Obtained via LTI launch}: The JWT is created during the LTI 
launch POST request from Canvas to FeedbackFruits
\end{itemize}

To use the API from the command line:
\begin{enumerate}
\item Launch FeedbackFruits activity in browser through Canvas
\item Open DevTools (F12) → Network tab
\item Look for requests to [[api.feedbackfruits.com]] or [[accounts.feedbackfruits.com]]
\item In the request headers, find [[Authorization: Bearer <jwt\_token>]]
\item Copy the JWT token (the long string after "Bearer ")
\item Also look for the refresh token in the same or subsequent requests
\item Pass via [[--token]] option: [[canvaslms fbf progress --token 'eyJ...']]
\end{enumerate}

To refresh an expired access token:
\begin{verbatim}
canvaslms fbf refresh-token --refresh-token 'eyJ...'
\end{verbatim}

This returns a new access token valid for 30 minutes and a new refresh token 
valid for 14 days.

Alternatively, the JWT may also be stored in a cookie, so the [[--cookie]] 
option remains supported.


\section{Advanced usage}

\textbf{Note:} For basic usage, see the Quick Start section at the beginning of
this chapter.

\subsection{Automating token refresh with a wrapper script}

Since manual token extraction is tedious, consider creating a wrapper script 
that stores and refreshes tokens:

\begin{verbatim}
#!/bin/bash
# fbf-fetch.sh - Helper script for FeedbackFruits data extraction

COURSE="$1"
ASSIGNMENT="$2"
TASK_UUID="$3"
TOKEN_FILE="$HOME/.config/canvaslms/fbf_tokens.json"

# Check if we have stored tokens
if [ -f "$TOKEN_FILE" ]; then
  ACCESS_TOKEN=$(jq -r '.access_token' "$TOKEN_FILE")
  REFRESH_TOKEN=$(jq -r '.refresh_token' "$TOKEN_FILE")
  EXPIRES=$(jq -r '.expires_at' "$TOKEN_FILE")
  NOW=$(date +%s)
  
  # Check if access token is expired
  if [ "$NOW" -gt "$EXPIRES" ]; then
    echo "Access token expired, refreshing..."
    
    # Refresh the token
    canvaslms fbf refresh-token --refresh-token "$REFRESH_TOKEN" \
      --json > /tmp/new_tokens.json
    
    if [ $? -eq 0 ]; then
      # Update stored tokens
      mv /tmp/new_tokens.json "$TOKEN_FILE"
      ACCESS_TOKEN=$(jq -r '.access_token' "$TOKEN_FILE")
      echo "Token refreshed successfully"
    else
      echo "Token refresh failed, manual intervention required"
      exit 1
    fi
  fi
else
  echo "No tokens found in $TOKEN_FILE"
  echo "Extract tokens from browser and save to file:"
  echo '  {"access_token": "...", "refresh_token": "...", "expires_at": epoch}'
  exit 1
fi

# Use the (refreshed) access token
canvaslms fbf progress -c "$COURSE" -a "$ASSIGNMENT" \
  --task-id "$TASK_UUID" \
  --token "$ACCESS_TOKEN" \
  "$@"
\end{verbatim}

This script:
\begin{itemize}
\item Stores tokens in a JSON file
\item Automatically refreshes expired access tokens
\item Uses the refresh token (valid for 14 days)
\item Only requires manual intervention when refresh token expires
\end{itemize}

\textbf{Note:} For current limitations and planned future enhancements, see the
relevant sections at the beginning of this chapter.
