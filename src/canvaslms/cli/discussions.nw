\chapter{The \texttt{discussions} subcommand}
\chapterprecis{This chapter was written by GitHub Copilot.}

This chapter provides the \texttt{discussions} subcommand which handles
discussions and announcements in Canvas courses.

We outline the module:
<<discussions.py>>=
import os
import re
import subprocess
import sys
import tempfile
import pypandoc
import rich.console
import rich.markdown
import arrow
import canvaslms.cli.courses
import canvaslms.cli.utils

<<functions>>

def add_command(subp):
  """Adds the discussions command with subcommands to argparse parser"""
  discussions_parser = subp.add_parser("discussions",
    help="Manage course discussions and announcements",
    description="Manage discussions and announcements in Canvas courses.")
  
  discussions_subp = discussions_parser.add_subparsers(
    title="discussions commands",
    dest="discussions_command",
    required=True)
  
  add_announce_command(discussions_subp)
  add_list_command(discussions_subp)
  add_show_command(discussions_subp)

def add_announce_command(subp):
  """Adds the announce subcommand"""
  announce_parser = subp.add_parser("announce",
    help="Post announcements to courses",
    description="Post announcements to one or more courses matching a regex pattern. "
                "The announcement can be provided via command line or interactively using an editor.")
  announce_parser.set_defaults(func=announce_command)
  <<add announce arguments>>

def add_list_command(subp):
  """Adds the list subcommand"""
  list_parser = subp.add_parser("list",
    help="List discussions and announcements",
    description="List discussions or announcements from courses.")
  list_parser.set_defaults(func=list_command)
  <<add list arguments>>

def add_show_command(subp):
  """Adds the show subcommand"""
  show_parser = subp.add_parser("show",
    help="Show details of discussions and announcements",
    description="Show detailed view of discussions or announcements from courses with rich formatting.")
  show_parser.set_defaults(func=show_command)
  <<add show arguments>>
@


\section{Announce command arguments}

The announce command requires a title and supports various ways to specify the message.
<<add announce arguments>>=
announce_parser.add_argument("title",
  help="Title of the announcement")
announce_parser.add_argument("-c", "--course", required=True,
  help="Regex matching courses on title, course code or Canvas ID")
announce_parser.add_argument("-m", "--message",
  help="Message content of the announcement (use -i for interactive mode)")
announce_parser.add_argument("-i", "--interactive",
  action="store_true", default=False,
  help="Interactive mode: open editor to write announcement message in Markdown")
@

\section{List command arguments}

The list command can list either announcements or discussions.
<<add list arguments>>=
list_parser.add_argument("type",
  choices=["announcements", "discussions"],
  help="Type of content to list")
list_parser.add_argument("-c", "--course", required=True,
  help="Regex matching courses on title, course code or Canvas ID")
@

\section{Show command arguments}

The show command displays detailed information about discussions or announcements.
<<add show arguments>>=
show_parser.add_argument("type",
  choices=["announcements", "discussions"],
  help="Type of content to show")
show_parser.add_argument("-c", "--course", required=True,
  help="Regex matching courses on title, course code or Canvas ID")
show_parser.add_argument("--match",
  help="Regular expression to match against discussion/announcement title and message")
show_parser.add_argument("--title", "-t",
  help="Regular expression to match against discussion/announcement title")
show_parser.add_argument("--message", "-m",
  help="Regular expression to match against discussion/announcement message")
show_parser.add_argument("--ignore-case", "-i",
  action="store_true",
  help="Make the regex case-insensitive")
show_parser.add_argument("--count", "-n", type=int, default=1,
  help="Number of matching items to show (default: 1), set to 0 to show all matches")
@


\section{The announce command function}

The main function that processes the announce command.
<<functions>>=
def announce_command(config, canvas, args):
  """Posts announcements to matching courses"""
  
  # Get list of matching courses
  course_list = list(canvaslms.cli.courses.filter_courses(canvas, args.course))
  
  if not course_list:
    print(f"No courses found matching pattern: {args.course}", file=sys.stderr)
    sys.exit(1)
  
  # Get the message content
  if args.interactive:
    message = get_message_from_editor()
  elif args.message:
    message = args.message
  else:
    print("Error: Either provide -m/--message or use -i/--interactive mode", file=sys.stderr)
    sys.exit(1)
  
  if not message.strip():
    print("Error: Message cannot be empty", file=sys.stderr)
    sys.exit(1)
  
  # Show courses that will receive the announcement
  print(f"Will post announcement '{args.title}' to {len(course_list)} course(s):", file=sys.stderr)
  for course in course_list:
    print(f"  - {course.course_code}: {course.name}", file=sys.stderr)
  
  # Interactive confirmation with preview and edit option
  if args.interactive:
    message = interactive_confirm_and_edit(args.title, message)
    if message is None:
      print("Cancelled.", file=sys.stderr)
      sys.exit(0)
  
  # Post announcements
  success_count = 0
  failed_count = 0
  for course in course_list:
    try:
      <<post announcement to course>>
      success_count += 1
    except Exception as e:
      print(f"Failed to post to {course.course_code}: {course.name} - {str(e)}", file=sys.stderr)
      failed_count += 1
  
  # Only output result if there were failures
  if failed_count > 0:
    print(f"Posted to {success_count}/{len(course_list)} courses.", file=sys.stderr)
    sys.exit(1)
@

\section{The list command function}

The main function that processes the list command.
<<functions>>=
def list_command(config, canvas, args):
  """Lists discussions or announcements from matching courses"""
  
  # Get list of matching courses
  course_list = list(canvaslms.cli.courses.filter_courses(canvas, args.course))
  
  if not course_list:
    print(f"No courses found matching pattern: {args.course}", file=sys.stderr)
    sys.exit(1)
  
  # List discussions/announcements for each course
  for course in course_list:
    try:
      if args.type == "announcements":
        <<list announcements for course>>
      else:  # discussions
        <<list discussions for course>>
    except Exception as e:
      print(f"Error accessing {course.course_code}: {str(e)}", file=sys.stderr)
      sys.exit(1)
@

\section{The show command function}

The main function that processes the show command.
<<functions>>=
def show_command(config, canvas, args):
  """Shows detailed view of discussions or announcements from matching courses"""
  
  # Get list of matching courses
  course_list = list(canvaslms.cli.courses.filter_courses(canvas, args.course))
  
  if not course_list:
    print(f"No courses found matching pattern: {args.course}", file=sys.stderr)
    sys.exit(1)
  
  <<compile regex patterns for show>>
  
  # Collect all discussions/announcements from matching courses
  all_items = []
  for course in course_list:
    try:
      if args.type == "announcements":
        items = course.get_discussion_topics(only_announcements=True)
      else:  # discussions
        items = course.get_discussion_topics()
        # Filter out announcements when listing discussions
        items = [item for item in items if not getattr(item, 'is_announcement', False)]
      
      # Add course info to each item for display
      for item in items:
        item._course = course
        all_items.append(item)
        
    except Exception as e:
      print(f"Error accessing {course.course_code}: {str(e)}", file=sys.stderr)
      sys.exit(1)
  
  # Filter by regex if provided
  filtered_items = []
  for item in all_items:
    if matches_regex_patterns(item, args):
      filtered_items.append(item)
  
  # Sort by creation date (newest first)
  filtered_items.sort(key=lambda x: getattr(x, 'created_at', ''), reverse=True)
  
  # Take the requested count
  if args.count == 0:
    count = len(filtered_items)  # Show all matches
  else:
    count = max(1, args.count)
  
  selected_items = filtered_items[:count]
  
  if not selected_items:
    print(f"No matching {args.type} found", file=sys.stderr)
    sys.exit(1)
  
  # Display items using Rich
  console = rich.console.Console()
  for idx, item in enumerate(selected_items):
    <<print discussion details with rich>>
    if idx != len(selected_items) - 1:
      print()  # Add blank line between items
@


\section{Interactive message editing}

Function to open an editor for writing the announcement message.
<<functions>>=
def get_message_from_editor(initial_content=""):
  """Opens the user's preferred editor to write the announcement message
  
  Args:
    initial_content: Optional initial markdown content to pre-populate the editor
  
  Returns:
    HTML content converted from markdown, or None if cancelled
  """
  editor = os.environ.get('EDITOR', 'nano')
  
  with tempfile.NamedTemporaryFile(mode='w+', suffix='.md', delete=False) as temp_file:
    # Pre-populate with initial content if provided
    if initial_content:
      temp_file.write(initial_content)
    temp_file_path = temp_file.name
  
  try:
    # Open editor
    subprocess.run([editor, temp_file_path], check=True)
    
    # Read the content back
    with open(temp_file_path, 'r') as temp_file:
      content = temp_file.read()
    
    markdown_content = content.strip()
    
    # Convert markdown to HTML using pandoc
    if markdown_content:
      try:
        html_content = pypandoc.convert_text(markdown_content, 'html', format='md')
        return html_content
      except Exception as e:
        print(f"Warning: Failed to convert markdown to HTML: {e}", file=sys.stderr)
        print("Using raw markdown content instead.", file=sys.stderr)
        return markdown_content
    else:
      return markdown_content
    
  finally:
    # Clean up temporary file
    try:
      os.unlink(temp_file_path)
    except OSError:
      pass
@

\section{Message preview rendering}

Function to render a preview of the message in the terminal.
<<functions>>=
def render_message_preview(title, html_content):
  """Renders a preview of the announcement message using Rich
  
  Args:
    title: The announcement title
    html_content: The HTML content to preview (will be converted to markdown for display)
  """
  console = rich.console.Console(stderr=True)
  
  print("\n" + "="*60, file=sys.stderr)
  console.print(f"[bold cyan]Preview: {title}[/bold cyan]")
  print("="*60 + "\n", file=sys.stderr)
  
  # Convert HTML back to markdown for nice display
  try:
    markdown_content = pypandoc.convert_text(html_content, 'md', format='html')
    console.print(rich.markdown.Markdown(markdown_content))
  except Exception:
    # Fallback: just print the HTML content
    console.print(html_content)
  
  print("\n" + "="*60 + "\n", file=sys.stderr)
@

\section{Interactive confirmation with edit option}

Function to handle the interactive confirmation loop with preview and edit options.
<<functions>>=
def interactive_confirm_and_edit(title, message):
  """Interactive loop for confirming or editing the announcement
  
  Args:
    title: The announcement title
    message: The initial HTML message content
  
  Returns:
    The final HTML message content, or None if cancelled
  """
  current_message = message
  
  # Keep track of markdown content for re-editing
  markdown_cache = None
  try:
    markdown_cache = pypandoc.convert_text(current_message, 'md', format='html')
  except Exception:
    markdown_cache = current_message
  
  while True:
    # Show preview
    render_message_preview(title, current_message)
    
    # Prompt for action
    print("Options:", file=sys.stderr)
    print("  [a] Accept and post announcement", file=sys.stderr)
    print("  [e] Edit message again", file=sys.stderr)
    print("  [d] Discard and cancel", file=sys.stderr)
    
    choice = input("Your choice (a/e/d): ").strip().lower()
    
    if choice in ['a', 'accept']:
      return current_message
    elif choice in ['e', 'edit']:
      # Re-open editor with current content
      new_message = get_message_from_editor(markdown_cache)
      if new_message and new_message.strip():
        current_message = new_message
        # Update markdown cache
        try:
          markdown_cache = pypandoc.convert_text(current_message, 'md', format='html')
        except Exception:
          markdown_cache = current_message
      else:
        print("Message cannot be empty. Keeping previous content.", file=sys.stderr)
    elif choice in ['d', 'discard', 'cancel']:
      return None
    else:
      print(f"Invalid choice '{choice}'. Please enter 'a', 'e', or 'd'.", file=sys.stderr)
@


\section{Posting announcements}

Function to post an announcement to a specific course.
<<post announcement to course>>=
discussion_topic = course.create_discussion_topic(
  title=args.title,
  message=message,
  is_announcement=True,
  published=True
)
@

\section{Listing announcements and discussions}

Functions to list announcements and discussions from courses.
<<list announcements for course>>=
announcements = course.get_discussion_topics(only_announcements=True)
for announcement in announcements:
  # Output in tab-delimited format for UNIX tools
  print(f"{course.course_code}\t{announcement.id}\t{announcement.title}\t{canvaslms.cli.utils.format_local_time(announcement.created_at)}")
@

<<list discussions for course>>=
discussions = course.get_discussion_topics()
for discussion in discussions:
  # Skip announcements when listing discussions
  if not getattr(discussion, 'is_announcement', False):
    # Output in tab-delimited format for UNIX tools
    print(f"{course.course_code}\t{discussion.id}\t{discussion.title}\t{canvaslms.cli.utils.format_local_time(discussion.created_at)}")
@

\section{Helper functions for show command}

Functions to support the show command functionality.
<<compile regex patterns for show>>=
pattern = None
if args.match:
  try:
    flags = re.IGNORECASE if args.ignore_case else 0
    pattern = re.compile(args.match, flags)
  except re.error as e:
    print(f"Invalid regex for --match: {e}", file=sys.stderr)
    sys.exit(1)

title_pattern = None
if args.title:
  try:
    flags = re.IGNORECASE if args.ignore_case else 0
    title_pattern = re.compile(args.title, flags)
  except re.error as e:
    print(f"Invalid regex for --title: {e}", file=sys.stderr)
    sys.exit(1)

message_pattern = None
if args.message:
  try:
    flags = re.IGNORECASE if args.ignore_case else 0
    message_pattern = re.compile(args.message, flags)
  except re.error as e:
    print(f"Invalid regex for --message: {e}", file=sys.stderr)
    sys.exit(1)
@

<<functions>>=
def matches_regex_patterns(item, args):
  """Check if discussion/announcement matches the regex patterns"""
  if not (args.match or args.title or args.message):
    return True
  
  title = getattr(item, 'title', '') or ''
  message = getattr(item, 'message', '') or ''
  text = f"{title}\n{message}"
  
  # Compile patterns dynamically (could be optimized by moving to show_command)
  flags = re.IGNORECASE if args.ignore_case else 0
  
  if args.title:
    try:
      title_pattern = re.compile(args.title, flags)
      if title_pattern.search(title):
        return True
    except re.error:
      pass
  
  if args.message:
    try:
      message_pattern = re.compile(args.message, flags)  
      if message_pattern.search(message):
        return True
    except re.error:
      pass
      
  if args.match:
    try:
      pattern = re.compile(args.match, flags)
      if pattern.search(text):
        return True
    except re.error:
      pass
  
  return False
@

<<print discussion details with rich>>=
# Print header with course and type info
item_type = "Announcement" if getattr(item, 'is_announcement', False) else "Discussion"
course = getattr(item, '_course', None)
course_info = f" [{course.course_code}]" if course else ""

console.print(f"[bold cyan]{item_type}{course_info}[/bold cyan]")
console.print(f"[bold]Title:  [/bold] {getattr(item, 'title', 'N/A')}")
console.print(f"[bold]Created:[/bold] {canvaslms.cli.utils.format_local_time(getattr(item, 'created_at', None))}")
console.print(f"[bold]Author: [/bold] {getattr(item, 'author', {}).get('display_name', 'N/A')}")

# Show URL if available
url = getattr(item, 'html_url', None)
if url:
  console.print(f"[bold]URL:    [/bold] {url}")

# Show message content if available
message = getattr(item, 'message', None)
if message and message.strip():
  console.print(f"[bold]Message:[/bold]")
  # Convert HTML message back to markdown for nice display
  try:
    markdown_content = pypandoc.convert_text(message, 'md', format='html')
    console.print(rich.markdown.Markdown(markdown_content))
  except Exception:
    # Fallback: just print the HTML content
    console.print(message)
else:
  console.print(f"[bold]Message:[/bold] [dim]No content[/dim]")
@
