\chapter{The [[discussions]] subcommand}
\chapterprecis{This chapter was written by GitHub Copilot.}

This chapter provides the [[discussions]] subcommand which handles
discussions and announcements in Canvas courses.

\section{Interactive mode with YAML front matter}

In interactive mode ([[-i]] flag), the editor opens with YAML front matter
similar to GitHub Pages and Jekyll. This allows you to edit all relevant 
announcement attributes in a structured way.

The editor opens with a template showing all available attributes:

\begin{verbatim}
---
title: ''
published: true
delayed_post_at: null
lock_at: null
require_initial_post: null
allow_rating: null
only_graders_can_rate: null
sort_by_rating: null
---
Your announcement content goes here in Markdown format.
\end{verbatim}

Simply fill in the values you want to set. Leave attributes as [[null]] if you 
don't need them.

Example with some attributes filled in:

\begin{verbatim}
---
title: "Important: Exam Schedule Change"
published: true
delayed_post_at: "2024-12-25T08:00:00"
lock_at: "2024-12-31T23:59:59"
require_initial_post: null
allow_rating: null
only_graders_can_rate: null
sort_by_rating: null
---
Your announcement content goes here in Markdown format.

You can use **bold**, *italic*, lists, links, etc.
\end{verbatim}

Supported attributes include:
\begin{itemize}
\item [[title]]: The announcement title (required)
\item [[published]]: Whether to publish immediately (default: true)
\item [[delayed_post_at]]: Schedule the announcement for a future date/time
\item [[lock_at]]: Date/time when discussion will be locked
\item [[require_initial_post]]: Require students to post before seeing replies
\item [[allow_rating]]: Allow rating/liking of posts
\item [[only_graders_can_rate]]: Restrict rating to graders only
\item [[sort_by_rating]]: Sort posts by rating instead of date
\end{itemize}

Date formats are parsed using the calendar module's date parser, which supports:
\begin{itemize}
\item [[YYYY-MM-DD HH:mm]]: Date and time in local timezone (preferred format)
\item [[YYYY-MM-DD]]: Date only (interpreted as midnight local time)
\item ISO 8601 formats
\end{itemize}

All dates are converted to UTC with [[Z]] suffix for Canvas API compatibility.

Examples:
\begin{itemize}
\item [[2024-12-25 08:00]]: December 25, 2024 at 8:00 AM local time
\item [[2024-12-25]]: December 25, 2024 at midnight local time
\item [[2024-12-25T08:00:00Z]]: December 25, 2024 at 8:00 AM UTC
\end{itemize}

If the title is not provided in the YAML front matter or command line, you will
be prompted to return to the editor rather than losing your work.

We outline the module:
<<discussions.py>>=
import os
import re
import subprocess
import sys
import tempfile
import csv
import pypandoc
import rich.console
import rich.markdown
import arrow
import yaml
import canvaslms.cli.courses
import canvaslms.cli.utils
import canvaslms.cli.calendar

<<functions>>

def add_command(subp):
  """Adds the discussions command with subcommands to argparse parser"""
  discussions_parser = subp.add_parser("discussions",
    help="Manage course discussions and announcements",
    description="Manage discussions and announcements in Canvas courses.")
  
  discussions_subp = discussions_parser.add_subparsers(
    title="discussions commands",
    dest="discussions_command",
    required=True)
  
  add_announce_command(discussions_subp)
  add_list_command(discussions_subp)
  add_show_command(discussions_subp)

def add_announce_command(subp):
  """Adds the announce subcommand"""
  announce_parser = subp.add_parser("announce",
    help="Post announcements to courses",
    description="Post announcements to one or more courses matching a regex pattern. "
                "The announcement can be provided via command line or interactively using an editor.")
  announce_parser.set_defaults(func=announce_command)
  <<add announce arguments>>

def add_list_command(subp):
  """Adds the list subcommand"""
  list_parser = subp.add_parser("list",
    help="List discussions and announcements",
    description="List discussions or announcements from courses.")
  list_parser.set_defaults(func=list_command)
  <<add list arguments>>

def add_show_command(subp):
  """Adds the show subcommand"""
  show_parser = subp.add_parser("show",
    help="Show details of discussions and announcements",
    description="Show detailed view of discussions or announcements from courses with rich formatting.")
  show_parser.set_defaults(func=show_command)
  <<add show arguments>>
@


\section{Announce command arguments}

The announce command requires a title and supports various ways to specify the message.
<<add announce arguments>>=
announce_parser.add_argument("title", nargs='?', default=None,
  help="Title of the announcement (can be set in YAML front matter in interactive mode)")
announce_parser.add_argument("-c", "--course", required=True,
  help="Regex matching courses on title, course code or Canvas ID")
announce_parser.add_argument("-m", "--message",
  help="Message content of the announcement (use -i for interactive mode)")
announce_parser.add_argument("-i", "--interactive",
  action="store_true", default=False,
  help="Interactive mode: open editor to write announcement with YAML front matter for attributes")
@

\section{List command arguments}

The list command can list either announcements or discussions.
Output is in CSV format with fields: course code, title, and date.
For announcements, the date shown is the delayed posting date if scheduled,
otherwise the creation date.
<<add list arguments>>=
list_parser.add_argument("type",
  choices=["announcements", "discussions"],
  help="Type of content to list")
list_parser.add_argument("-c", "--course", required=True,
  help="Regex matching courses on title, course code or Canvas ID")
@

\section{Show command arguments}

The show command displays detailed information about discussions or announcements.
<<add show arguments>>=
show_parser.add_argument("type",
  choices=["announcements", "discussions"],
  help="Type of content to show")
show_parser.add_argument("-c", "--course", required=True,
  help="Regex matching courses on title, course code or Canvas ID")
show_parser.add_argument("--match",
  help="Regular expression to match against discussion/announcement title and message")
show_parser.add_argument("--title", "-t",
  help="Regular expression to match against discussion/announcement title")
show_parser.add_argument("--message", "-m",
  help="Regular expression to match against discussion/announcement message")
show_parser.add_argument("--ignore-case", "-i",
  action="store_true",
  help="Make the regex case-insensitive")
show_parser.add_argument("--count", "-n", type=int, default=1,
  help="Number of matching items to show (default: 1), set to 0 to show all matches")
@


\section{The announce command function}

The main function that processes the announce command.
<<functions>>=
def announce_command(config, canvas, args):
  """Posts announcements to matching courses"""
  
  # Get list of matching courses
  course_list = list(canvaslms.cli.courses.filter_courses(canvas, args.course))
  
  if not course_list:
    print(f"No courses found matching pattern: {args.course}", file=sys.stderr)
    sys.exit(1)
  
  # Get the message content and attributes
  if args.interactive:
    # In interactive mode, parse YAML front matter
    result = get_announcement_from_editor(args.title)
    if result is None:
      print("Editor cancelled or failed.", file=sys.stderr)
      sys.exit(1)
    
    attributes, message = result
    title = attributes.get('title', args.title)
    
    # Check if title is missing and offer to return to editor
    while not title:
      print("Error: Title is required but not provided.", file=sys.stderr)
      print("Options:", file=sys.stderr)
      print("  [e] Return to editor to add title", file=sys.stderr)
      print("  [d] Discard and cancel", file=sys.stderr)
      
      try:
        choice = input("Your choice (e/d): ").strip().lower()
      except (EOFError, KeyboardInterrupt):
        print("\nCancelled.", file=sys.stderr)
        sys.exit(0)
      
      if choice in ['e', 'edit']:
        # Re-open editor with current content
        result = get_announcement_from_editor(None, attributes, message)
        if result is None:
          print("Editor cancelled or failed.", file=sys.stderr)
          sys.exit(1)
        attributes, message = result
        title = attributes.get('title')
      elif choice in ['d', 'discard', 'cancel']:
        print("Cancelled.", file=sys.stderr)
        sys.exit(0)
      else:
        print(f"Invalid choice '{choice}'. Please enter 'e' or 'd'.", file=sys.stderr)
        
  elif args.message:
    if not args.title:
      print("Error: Title is required when using -m/--message", file=sys.stderr)
      sys.exit(1)
    title = args.title
    message = args.message
    attributes = {}
  else:
    print("Error: Either provide -m/--message or use -i/--interactive mode", file=sys.stderr)
    sys.exit(1)
  
  if not message.strip():
    print("Error: Message cannot be empty", file=sys.stderr)
    sys.exit(1)
  
  # Show courses that will receive the announcement
  print(f"Will post announcement '{title}' to {len(course_list)} course(s):", file=sys.stderr)
  for course in course_list:
    print(f"  - {course.course_code}: {course.name}", file=sys.stderr)
  
  # Interactive confirmation with preview and edit option
  if args.interactive:
    result = interactive_confirm_and_edit(title, message, attributes)
    if result is None:
      print("Cancelled.", file=sys.stderr)
      sys.exit(0)
    attributes, message = result
    title = attributes.get('title', title)
  
  # Convert markdown to HTML for Canvas (only at the very end)
  try:
    html_message = pypandoc.convert_text(message, 'html', format='md')
  except Exception as e:
    print(f"Warning: Failed to convert markdown to HTML: {e}", file=sys.stderr)
    print("Using raw content instead.", file=sys.stderr)
    html_message = message
  
  # Post announcements
  success_count = 0
  failed_count = 0
  for course in course_list:
    try:
      <<post announcement to course>>
      success_count += 1
    except Exception as e:
      print(f"Failed to post to {course.course_code}: {course.name} - {str(e)}", file=sys.stderr)
      failed_count += 1
  
  # Only output result if there were failures
  if failed_count > 0:
    print(f"Posted to {success_count}/{len(course_list)} courses.", file=sys.stderr)
    sys.exit(1)
@

\section{The list command function}

The main function that processes the list command.
Output is in CSV format for easy parsing with POSIX tools.
<<functions>>=
def list_command(config, canvas, args):
  """Lists discussions or announcements from matching courses"""
  
  # Get list of matching courses
  course_list = list(canvaslms.cli.courses.filter_courses(canvas, args.course))
  
  if not course_list:
    print(f"No courses found matching pattern: {args.course}", file=sys.stderr)
    sys.exit(1)
  
  # List discussions/announcements for each course
  for course in course_list:
    try:
      if args.type == "announcements":
        <<list announcements for course>>
      else:  # discussions
        <<list discussions for course>>
    except Exception as e:
      print(f"Error accessing {course.course_code}: {str(e)}", file=sys.stderr)
      sys.exit(1)
@

\section{The show command function}

The main function that processes the show command.
<<functions>>=
def show_command(config, canvas, args):
  """Shows detailed view of discussions or announcements from matching courses"""
  
  # Get list of matching courses
  course_list = list(canvaslms.cli.courses.filter_courses(canvas, args.course))
  
  if not course_list:
    print(f"No courses found matching pattern: {args.course}", file=sys.stderr)
    sys.exit(1)
  
  <<compile regex patterns for show>>
  
  # Collect all discussions/announcements from matching courses
  all_items = []
  for course in course_list:
    try:
      if args.type == "announcements":
        items = course.get_discussion_topics(only_announcements=True)
      else:  # discussions
        items = course.get_discussion_topics()
        # Filter out announcements when listing discussions
        items = [item for item in items if not getattr(item, 'is_announcement', False)]
      
      # Add course info to each item for display
      for item in items:
        item._course = course
        all_items.append(item)
        
    except Exception as e:
      print(f"Error accessing {course.course_code}: {str(e)}", file=sys.stderr)
      sys.exit(1)
  
  # Filter by regex if provided
  filtered_items = []
  for item in all_items:
    if matches_regex_patterns(item, args):
      filtered_items.append(item)
  
  # Sort by creation date (newest first)
  filtered_items.sort(key=lambda x: getattr(x, 'created_at', ''), reverse=True)
  
  # Take the requested count
  if args.count == 0:
    count = len(filtered_items)  # Show all matches
  else:
    count = max(1, args.count)
  
  selected_items = filtered_items[:count]
  
  if not selected_items:
    print(f"No matching {args.type} found", file=sys.stderr)
    sys.exit(1)
  
  # Display items using Rich
  console = rich.console.Console()
  for idx, item in enumerate(selected_items):
    <<print discussion details with rich>>
    if idx != len(selected_items) - 1:
      print()  # Add blank line between items
@


\section{Interactive message editing}

The interactive editing system uses YAML front matter to allow users to set
announcement attributes alongside the message content. This design was chosen
because it's familiar to users of Jekyll and GitHub Pages, keeps all 
announcement data in one place, and remains plain text and editor-agnostic.

We implement this through three main functions: [[parse_yaml_front_matter]] 
extracts YAML metadata from content, [[format_yaml_front_matter]] formats 
content with a YAML header, and [[get_announcement_from_editor]] orchestrates 
the editing process.

\subsection{Parsing YAML front matter}

The parser looks for content delimited by [[---]] markers at the start of the
file. If found, it attempts to parse the section as YAML and returns both the
attributes dictionary and the remaining content.
<<functions>>=
def parse_yaml_front_matter(content):
  """Parse YAML front matter from content
  
  Args:
    content: String containing optional YAML front matter followed by content
  
  Returns:
    Tuple of (attributes dict, content string)
  """
  # Check if content starts with YAML front matter delimiter
  if not content.strip().startswith('---'):
    return {}, content
  
  # Try to extract YAML front matter
  parts = content.split('---', 2)
  if len(parts) < 3:
    return {}, content
  
  try:
    # parts[0] is empty, parts[1] is YAML, parts[2] is content
    yaml_str = parts[1]
    attributes = yaml.safe_load(yaml_str) or {}
    message_content = parts[2].lstrip('\n')
    return attributes, message_content
  except yaml.YAMLError as e:
    print(f"Warning: Failed to parse YAML front matter: {e}", file=sys.stderr)
    return {}, content

def format_yaml_front_matter(attributes, message_content):
  """Format content with YAML front matter
  
  Args:
    attributes: Dictionary of attributes
    message_content: The message content
  
  Returns:
    String with YAML front matter and content
  """
  if not attributes:
    return message_content
  
  yaml_str = yaml.dump(attributes, default_flow_style=False, sort_keys=False)
  return f"---\n{yaml_str}---\n{message_content}"
@

\subsection{Opening the editor with YAML template}

The [[get_announcement_from_editor]] function creates a temporary file with
YAML front matter template showing all available attributes. After the user
edits and saves, we parse the result and return the attributes and content
separately.
<<functions>>=
def get_announcement_from_editor(initial_title=None, initial_attributes=None, initial_content=""):
  """Opens the user's preferred editor to write the announcement with YAML front matter
  
  Args:
    initial_title: Optional title to pre-populate (overridden by attributes)
    initial_attributes: Optional dictionary of attributes to pre-populate
    initial_content: Optional initial markdown content to pre-populate the editor
  
  Returns:
    Tuple of (attributes dict, markdown content), or None if cancelled
  """
  editor = os.environ.get('EDITOR', 'nano')
  
  # Prepare initial content with YAML front matter template
  if initial_attributes is None:
    initial_attributes = {}
  
  # Set default attributes if not provided
  if 'title' not in initial_attributes and initial_title:
    initial_attributes['title'] = initial_title
  
  # Add all possible template fields if not present
  # This shows users all available attributes they can set
  if not initial_attributes.get('title'):
    initial_attributes['title'] = ""
  if 'published' not in initial_attributes:
    initial_attributes['published'] = True
  if 'delayed_post_at' not in initial_attributes:
    initial_attributes['delayed_post_at'] = None
  if 'lock_at' not in initial_attributes:
    initial_attributes['lock_at'] = None
  if 'require_initial_post' not in initial_attributes:
    initial_attributes['require_initial_post'] = None
  if 'allow_rating' not in initial_attributes:
    initial_attributes['allow_rating'] = None
  if 'only_graders_can_rate' not in initial_attributes:
    initial_attributes['only_graders_can_rate'] = None
  if 'sort_by_rating' not in initial_attributes:
    initial_attributes['sort_by_rating'] = None
  
  # Format the initial content
  template_content = format_yaml_front_matter(initial_attributes, initial_content)
  
  with tempfile.NamedTemporaryFile(mode='w+', suffix='.md', delete=False) as temp_file:
    temp_file.write(template_content)
    temp_file_path = temp_file.name
  
  try:
    # Open editor
    try:
      subprocess.run([editor, temp_file_path], check=True)
    except subprocess.CalledProcessError as e:
      print(f"Error: Editor exited with error code {e.returncode}", file=sys.stderr)
      return None
    except FileNotFoundError:
      print(f"Error: Editor '{editor}' not found", file=sys.stderr)
      return None
    except Exception as e:
      print(f"Error opening editor: {e}", file=sys.stderr)
      return None
    
    # Read the content back
    with open(temp_file_path, 'r') as temp_file:
      content = temp_file.read()
    
    # Parse YAML front matter
    attributes, markdown_content = parse_yaml_front_matter(content)
    
    return attributes, markdown_content.strip()
    
  finally:
    # Clean up temporary file
    try:
      os.unlink(temp_file_path)
    except OSError:
      pass

@

Note that [[get_message_from_editor]] is retained for backward compatibility,
though it now uses the YAML-aware editor internally.
<<functions>>=
def get_message_from_editor(initial_content=""):
  """Opens the user's preferred editor to write the announcement message
  
  This is the legacy function for backward compatibility.
  
  Args:
    initial_content: Optional initial markdown content to pre-populate the editor
  
  Returns:
    The markdown content, or None if cancelled
  """
  result = get_announcement_from_editor(None, {}, initial_content)
  if result is None:
    return None
  attributes, content = result
  return content
@

\section{Message preview rendering}

Function to render a preview of the message in the terminal.
<<functions>>=
def render_message_preview(title, markdown_content, attributes=None):
  """Renders a preview of the announcement message using Rich
  
  Args:
    title: The announcement title
    markdown_content: The markdown content to preview
    attributes: Optional dictionary of announcement attributes
  """
  console = rich.console.Console(stderr=True)
  
  print("\n" + "="*60, file=sys.stderr)
  console.print(f"[bold cyan]Preview: {title}[/bold cyan]")
  print("="*60 + "\n", file=sys.stderr)
  
  # Show attributes if present
  if attributes:
    console.print("[bold]Attributes:[/bold]")
    for key, value in attributes.items():
      if key != 'title':  # Title is already shown in header
        console.print(f"  {key}: {value}")
    print(file=sys.stderr)
  
  # Render markdown directly
  try:
    console.print(rich.markdown.Markdown(markdown_content))
  except Exception:
    # Fallback: just print the content
    console.print(markdown_content)
  
  print("\n" + "="*60 + "\n", file=sys.stderr)
@

\section{Interactive confirmation with edit option}

Function to handle the interactive confirmation loop with preview and edit options.
<<functions>>=
def interactive_confirm_and_edit(title, message, attributes):
  """Interactive loop for confirming or editing the announcement
  
  Args:
    title: The announcement title
    message: The markdown message content
    attributes: Dictionary of announcement attributes
  
  Returns:
    Tuple of (attributes dict, message content), or None if cancelled
  """
  current_message = message
  current_attributes = attributes.copy()
  current_title = title
  
  while True:
    # Show preview
    render_message_preview(current_title, current_message, current_attributes)
    
    # Prompt for action
    print("Options:", file=sys.stderr)
    print("  [a] Accept and post announcement", file=sys.stderr)
    print("  [e] Edit message again", file=sys.stderr)
    print("  [d] Discard and cancel", file=sys.stderr)
    
    try:
      choice = input("Your choice (a/e/d): ").strip().lower()
    except (EOFError, KeyboardInterrupt):
      print("\nCancelled.", file=sys.stderr)
      return None
    
    if choice in ['a', 'accept']:
      return current_attributes, current_message
    elif choice in ['e', 'edit']:
      # Re-open editor with current content
      result = get_announcement_from_editor(current_title, current_attributes, current_message)
      # Handle cancellation or error
      if result is None:
        print("Editor cancelled or failed. Keeping previous content.", file=sys.stderr)
      else:
        new_attributes, new_message = result
        if new_message.strip():
          current_message = new_message
          current_attributes = new_attributes
          current_title = new_attributes.get('title', current_title)
        else:
          print("Message cannot be empty. Keeping previous content.", file=sys.stderr)
    elif choice in ['d', 'discard', 'cancel']:
      return None
    else:
      print(f"Invalid choice '{choice}'. Please enter 'a', 'e', or 'd'.", file=sys.stderr)
@


\section{Posting announcements}

Function to post an announcement to a specific course, using attributes from 
YAML front matter. We build the kwargs dictionary from the attributes, 
converting date strings to Canvas-compatible format using the calendar module's
[[format_canvas_time]] function.

\subsection{Date attribute parsing}

Both [[delayed_post_at]] and [[lock_at]] need the same date parsing logic.
We extract this to a helper function to avoid repetition.
<<functions>>=
def parse_date_attribute(attributes, attr_name):
  """Parse a date attribute using calendar module's format_canvas_time
  
  Args:
    attributes: Dictionary of announcement attributes
    attr_name: Name of the date attribute to parse
  
  Returns:
    Canvas-formatted date string, or None if not present or invalid
  """
  if attr_name not in attributes:
    return None
  
  date_value = attributes[attr_name]
  if date_value and date_value != 'null':
    try:
      return canvaslms.cli.calendar.format_canvas_time(date_value)
    except Exception as e:
      print(f"Warning: Failed to parse {attr_name} '{date_value}': {e}", 
            file=sys.stderr)
      return None
  return None
@

\subsection{Building the announcement parameters}

We now build the parameters for [[create_discussion_topic]], starting with
required fields and adding optional attributes if present.
<<post announcement to course>>=
kwargs = {
  'title': title,
  'message': html_message,
  'is_announcement': True,
}

if 'published' in attributes:
  kwargs['published'] = attributes['published']
else:
  kwargs['published'] = True

<<add date attributes to kwargs>>
<<add boolean attributes to kwargs>>

discussion_topic = course.create_discussion_topic(**kwargs)
@

We simply add date attributes by parsing them with our helper function.
<<add date attributes to kwargs>>=
for attr in ['delayed_post_at', 'lock_at']:
  parsed = parse_date_attribute(attributes, attr)
  if parsed:
    kwargs[attr] = parsed
<<add boolean attributes to kwargs>>=
for attr in ['require_initial_post', 'allow_rating', 
             'only_graders_can_rate', 'sort_by_rating']:
  if attr in attributes:
    kwargs[attr] = attributes[attr]
@

\section{Listing announcements and discussions}

Functions to list announcements and discussions from courses.
The output uses CSV format for compatibility with POSIX tools.

For announcements, we prefer showing the scheduled posting date
([[delayed_post_at]]) over the creation date, since scheduled announcements
are more relevant when they'll actually appear to students.
<<list announcements for course>>=
output = csv.writer(sys.stdout, delimiter=args.delimiter)
announcements = course.get_discussion_topics(only_announcements=True)
for announcement in announcements:
  date_to_show = (getattr(announcement, 'delayed_post_at', None) or 
                  getattr(announcement, 'created_at', None))
  output.writerow([
    course.course_code,
    announcement.title,
    canvaslms.cli.utils.format_local_time(date_to_show)
  ])
@

For discussions, we filter out announcements (which are technically a special
type of discussion in Canvas) and show only the creation date.
<<list discussions for course>>=
output = csv.writer(sys.stdout, delimiter=args.delimiter)
discussions = course.get_discussion_topics()
for discussion in discussions:
  if not getattr(discussion, 'is_announcement', False):
    output.writerow([
      course.course_code,
      discussion.title,
      canvaslms.cli.utils.format_local_time(discussion.created_at)
    ])
@

\section{Helper functions for show command}

Functions to support the show command functionality.
<<compile regex patterns for show>>=
pattern = None
if args.match:
  try:
    flags = re.IGNORECASE if args.ignore_case else 0
    pattern = re.compile(args.match, flags)
  except re.error as e:
    print(f"Invalid regex for --match: {e}", file=sys.stderr)
    sys.exit(1)

title_pattern = None
if args.title:
  try:
    flags = re.IGNORECASE if args.ignore_case else 0
    title_pattern = re.compile(args.title, flags)
  except re.error as e:
    print(f"Invalid regex for --title: {e}", file=sys.stderr)
    sys.exit(1)

message_pattern = None
if args.message:
  try:
    flags = re.IGNORECASE if args.ignore_case else 0
    message_pattern = re.compile(args.message, flags)
  except re.error as e:
    print(f"Invalid regex for --message: {e}", file=sys.stderr)
    sys.exit(1)
@

<<functions>>=
def matches_regex_patterns(item, args):
  """Check if discussion/announcement matches the regex patterns"""
  if not (args.match or args.title or args.message):
    return True
  
  title = getattr(item, 'title', '') or ''
  message = getattr(item, 'message', '') or ''
  text = f"{title}\n{message}"
  
  # Compile patterns dynamically (could be optimized by moving to show_command)
  flags = re.IGNORECASE if args.ignore_case else 0
  
  if args.title:
    try:
      title_pattern = re.compile(args.title, flags)
      if title_pattern.search(title):
        return True
    except re.error:
      pass
  
  if args.message:
    try:
      message_pattern = re.compile(args.message, flags)  
      if message_pattern.search(message):
        return True
    except re.error:
      pass
      
  if args.match:
    try:
      pattern = re.compile(args.match, flags)
      if pattern.search(text):
        return True
    except re.error:
      pass
  
  return False
@

<<print discussion details with rich>>=
# Print header with course and type info
item_type = "Announcement" if getattr(item, 'is_announcement', False) else "Discussion"
course = getattr(item, '_course', None)
course_info = f" [{course.course_code}]" if course else ""

console.print(f"[bold cyan]{item_type}{course_info}[/bold cyan]")
console.print(f"[bold]Title:  [/bold] {getattr(item, 'title', 'N/A')}")
console.print(f"[bold]Created:[/bold] {canvaslms.cli.utils.format_local_time(getattr(item, 'created_at', None))}")
console.print(f"[bold]Author: [/bold] {getattr(item, 'author', {}).get('display_name', 'N/A')}")

# Show URL if available
url = getattr(item, 'html_url', None)
if url:
  console.print(f"[bold]URL:    [/bold] {url}")

# Show message content if available
message = getattr(item, 'message', None)
if message and message.strip():
  console.print(f"[bold]Message:[/bold]")
  # Convert HTML message back to markdown for nice display
  try:
    markdown_content = pypandoc.convert_text(message, 'md', format='html')
    console.print(rich.markdown.Markdown(markdown_content))
  except Exception:
    # Fallback: just print the HTML content
    console.print(message)
else:
  console.print(f"[bold]Message:[/bold] [dim]No content[/dim]")
@
