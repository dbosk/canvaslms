\chapter{The main program}

The main program functionality exists in the subpackage [[canvaslms.cli]].
In this module there is a function [[main]] which is the main function of the 
command-line interface.
We define it in this chapter.

The we use subcommands, similar to Git.
Each subcommand has its own module in [[canvaslms.cli]], each module must have 
a function [[add_command]].
The [[add_command]] function takes a subparser as an argument and adds 
its subcommand and options to it.
At the end of the chapter we will call these functions for each of the included 
modules.

\section{Dependencies and source code overview}

We use the following packages:
\begin{itemize}
\item [[appdirs]] for platform specific configuration file locations, it must 
be installed by running [[python3 -m pip install appdirs]].
\item [[argcomplete]] for bash completion, it must be installed by running 
[[python3 -m pip install argcomplete]].
\item [[canvasapi]] for the Canvas LMS REST API, it must be installed by 
running [[python3 -m pip install canvasapi]].
\end{itemize}

Then the source code can be outlined as follows.
<<[[cli.py]]>>=
"""A command-line interface for the Canvas LMS."""

import appdirs
import argcomplete, argparse
from canvasapi import Canvas
import canvaslms.cli.login
import json
import logging
import os
import pathlib
import sys
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

<<modules>>

logger = logging.getLogger(__name__)
dirs = appdirs.AppDirs("canvaslms", "dbosk@kth.se")

<<classes and exceptions>>
<<functions>>

def main():
  <<command-line interface>>
@


\section{Testing}

Tests are distributed throughout this chapter, appearing immediately after each implementation to verify correctness.

<<test [[cli.py]]>>=
"""
Tests for canvaslms.cli verbosity system.

These tests verify the multi-level verbosity system that maps -v and -q flags
to Python logging levels.
"""
import pytest
import logging
import argparse

<<test functions>>
@


\section{Printing errors and warnings}

We want uniform error handling.
<<classes and exceptions>>=
class EmptyListError(Exception):
  """Exception raised when a process function returns an empty list"""
  pass
@

We will use the function [[err]] for errors and [[warn]] for warnings, both
inspired by err(3) and warn(3) in the BSD world.
These will be available as [[canvaslms.cli.err]] and [[canvaslms.cli.warn]].

These functions now use Python's logging module internally, so all error and
warning messages benefit from proper logging infrastructure (levels, formatting,
redirection).
<<functions>>=
def err(rc, msg):
  """Logs error msg and exits with rc as return code"""
  logger.error(f"{sys.argv[0]}: {msg}")
  sys.exit(rc)

def warn(msg):
  """Logs warning msg"""
  logger.warning(f"{sys.argv[0]}: {msg}")
@


\section{Configuration}

We provide several ways to supply configuration to the program.
For ease, we provide a function that loads the configuration and returns a 
dictionary containing it.
<<functions>>=
def read_configuration(config_file):
  """Returns a dictionary containing the configuration"""
  config = {}

  <<read configuration file>>
  <<read environment variables>>

  return config
@

The function gets the configuration file as an argument.
We don't return any error if the file doesn't exist.
We leave that to the caller to determine what to do if the configuration is 
empty.
Likewise, we issue a warning if the configuration file is malformed, \ie it 
can't be processed as valid JSON.
<<read configuration file>>=
try:
  with open(config_file, "r") as file:
    config.update(json.load(file))
except FileNotFoundError:
  pass
except json.decoder.JSONDecodeError as err:
  warn(f"config file is malformed: {err}")
@

We can read the credentials from the environment, this takes precedence over 
the credentials in the configuration file.
<<read environment variables>>=
if "canvas" not in config:
  config["canvas"] = {}

if "CANVAS_SERVER" in os.environ:
  config["canvas"]["host"] = os.environ["CANVAS_SERVER"]

if "CANVAS_TOKEN" in os.environ:
  config["canvas"]["access_token"] = os.environ["CANVAS_TOKEN"]
@

At times, we might want to update the configuration file.
When we update the config file, we must ensure that any other part of the 
configuration file is kept, so we write the [[config]] dictionary to the config 
file.

If we get a [[FileNotFoundError]], that means the config directory doesn't 
exist and we must create it.
<<functions>>=
def update_config_file(config, config_file):
  """Updates the config file by writing the config dictionary back to it"""
  try:
    <<open and write config to config file>>
  except FileNotFoundError:
    <<create file's parent directories>>
    <<open and write config to config file>>
<<create file's parent directories>>=
os.makedirs(pathlib.PurePath(config_file).parent)
<<open and write config to config file>>=
with open(config_file, "w") as fd:
  json.dump(config, fd)
@


\section{A command-line interface}%
\label{command-line-interface}

If we run this program, we must first set up a [[canvas]] object, then process 
the command-line arguments.
<<command-line interface>>=
argp = argparse.ArgumentParser(
  description="Scriptable Canvas LMS",
  epilog="Copyright (c) 2020--2026 Daniel Bosk. Licensed under the MIT License.\n"
         "Web: https://github.com/dbosk/canvaslms")

subp = argp.add_subparsers(
  title="commands",
  dest="command",
  required=True)

<<add global options to argp>>
<<add subcommands to subp>>

argcomplete.autocomplete(argp)
args = argp.parse_args()

<<configure logging based on verbose flag>>

config = read_configuration(args.config_file)

<<run subcommands>>
@

We configure Python's logging module based on the [[-v]]/[[--verbose]] and
[[-q]]/[[--quiet]] flags.
These flags can be stacked to control verbosity precisely, mapping to the
complete Python logging hierarchy.

We calculate a \emph{net verbosity} by subtracting the quiet count from the
verbose count.
This allows [[-v]] and [[-q]] to offset each other naturally:
for example, [[-vv -q]] gives net verbosity 1, equivalent to [[-v]].

The net verbosity maps to logging levels as follows:
\begin{description}
\item[Net $\leq -3$ ([[-qqq]] or more)] Completely silent (no output)
\item[Net $= -2$ ([[-qq]])] [[CRITICAL]] messages only
\item[Net $= -1$ ([[-q]])] [[ERROR]] and [[CRITICAL]] messages
\item[Net $= 0$ (default)] [[WARNING]], [[ERROR]], and [[CRITICAL]] messages
\item[Net $= 1$ ([[-v]])] [[INFO]], [[WARNING]], [[ERROR]], and [[CRITICAL]]
\item[Net $= 2$ ([[-vv]])] [[DEBUG]] and all above
\item[Net $\geq 3$ ([[-vvv]] or more)] [[NOTSET]]\,---\,everything including library internals
\end{description}

<<configure logging based on verbose flag>>=
net_verbosity = args.verbose - args.quiet

<<determine logging level from net verbosity>>
logging.basicConfig(level=level, format='[%(levelname)s] %(message)s')
@

We extract the level determination logic into a reusable chunk:
<<determine logging level from net verbosity>>=
if net_verbosity <= -3:
  # -qqq or more: completely silent
  level = logging.CRITICAL + 1
elif net_verbosity == -2:
  # -qq: critical only
  level = logging.CRITICAL
elif net_verbosity == -1:
  # -q: errors and critical
  level = logging.ERROR
elif net_verbosity == 0:
  # default: warnings and above
  level = logging.WARNING
elif net_verbosity == 1:
  # -v: info and above
  level = logging.INFO
elif net_verbosity == 2:
  # -vv: debug and above
  level = logging.DEBUG
else:  # net_verbosity >= 3
  # -vvv or more: everything including library debug messages
  level = logging.NOTSET
@

\subsubsection{Verifying the verbosity system}

Now let's verify this verbosity mapping works correctly.
The tests demonstrate how [[-v]] and [[-q]] flags stack and offset each other.

The core of the verbosity system is the net verbosity calculation, which allows
flags to offset each other naturally:

<<test functions>>=
class TestVerbositySystem:
    """Test the verbosity system in CLI"""

    def test_net_verbosity_calculation(self):
        """
        Net verbosity should be verbose count minus quiet count.

        This allows -v and -q to offset each other naturally.
        """
        args = argparse.Namespace(verbose=2, quiet=1)
        net_verbosity = args.verbose - args.quiet
        assert net_verbosity == 1

    def test_multiple_verbose_flags(self):
        """Multiple -v flags should stack: -vvv gives verbosity 3"""
        args = argparse.Namespace(verbose=3, quiet=0)
        net_verbosity = args.verbose - args.quiet
        assert net_verbosity == 3

    def test_multiple_quiet_flags(self):
        """Multiple -q flags should stack: -qqq gives verbosity -3"""
        args = argparse.Namespace(verbose=0, quiet=3)
        net_verbosity = args.verbose - args.quiet
        assert net_verbosity == -3

    def test_offsetting_flags(self):
        """-vv -q should give net verbosity 1"""
        args = argparse.Namespace(verbose=2, quiet=1)
        net_verbosity = args.verbose - args.quiet
        assert net_verbosity == 1
@

The net verbosity maps to specific Python logging levels.
We test the complete mapping with parameterized tests:

<<test functions>>=
class TestVerbosityLevelMapping:
    """Test the complete mapping from net verbosity to logging levels"""

    @pytest.mark.parametrize("verbose,quiet,expected_level", [
        (0, 3, logging.CRITICAL + 1),  # -qqq: completely silent
        (0, 2, logging.CRITICAL),       # -qq: critical only
        (0, 1, logging.ERROR),          # -q: error and critical
        (0, 0, logging.WARNING),        # default: warnings and above
        (1, 0, logging.INFO),           # -v: info and above
        (2, 0, logging.DEBUG),          # -vv: debug and above
        (3, 0, logging.NOTSET),         # -vvv: everything
        (4, 0, logging.NOTSET),         # -vvvv: still everything
        (2, 1, logging.INFO),           # -vv -q = -v: info level
        (3, 2, logging.INFO),           # -vvv -qq = -v: info level
    ])
    def test_verbosity_to_logging_level(self, verbose, quiet, expected_level):
        """Test that verbosity flags map correctly to logging levels"""
        net_verbosity = verbose - quiet

        # Use the same logic as in the implementation
        <<determine logging level from net verbosity>>

        assert level == expected_level
@


\subsection{The configuration file location}

We want to add an option to point to a configuration file in a non-standard 
location.
<<add global options to argp>>=
argp.add_argument("-f", "--config-file",
  default=f"{dirs.user_config_dir}/config.json",
  help="Path to configuration file "
    f"(default: {dirs.user_config_dir}/config.json) "
    "or set CANVAS_SERVER and CANVAS_TOKEN environment variables.")
@


\subsection{Output format}

Many commands output data in CSV format.
By default we use the tab character as the delimiter, since this gives us 
compatibility with all the POSIX tools available at the command line.
But we provide an option to change the delimiter, \eg to a comma.
<<add global options to argp>>=
argp.add_argument("-d", "--delimiter",
  default="\t",
  help="Sets the delimiter for CSV output, the default is the tab character")
argp.add_argument("-q", "--quiet",
  action="count",
  default=0,
  help="Decrease verbosity: -q=ERROR only, -qq=CRITICAL only, -qqq=silent")
argp.add_argument("-v", "--verbose",
  action="count",
  default=0,
  help="Increase verbosity: -v=INFO, -vv=DEBUG, -vvv=all library debug")
@


\subsection{Logging in and setting up Canvas}

Each subcommand will have its own module in the package.
Each such module must have a function [[add_command]] that takes the [[subp]] 
parser as an argument and adds its command and options to that.
For example, the [[login]] command:
The \texttt{login} command is located in [[canvaslms.cli.login]].
<<modules>>=
import canvaslms.cli.login
<<add subcommands to subp>>=
canvaslms.cli.login.add_command(subp)
@

In short, each [[add_command]] must add a subparser 
([[subp.add_parser]]) that will set the [[func]] attribute.
Then we can execute the correct function and let that function check the 
remaining arguments.

Each command function must take three arguments:
\begin{enumerate}
\item the configuration,
\item a Canvas object to use for interaction with Canvas,
\item the processed command-line arguments.
\end{enumerate}
This means that we must read the credentials to create the Canvas object.
One exception is the [[login]] command: this command doesn't need the Canvas 
object as it will be run before there are credentials.
<<run subcommands>>=
if (<<we don't need [[canvas]]>>):
  canvas = None
else:
  <<create canvas object>>

if args.func:
  try:
    args.func(config, canvas, args)
    <<save canvas to cache after command>>
  except EmptyListError as e:
    if args.quiet == 0:
      err(1, str(e))
    else:
      sys.exit(1)
@

We know that the [[login]] command doesn't need the Canvas object.
So we don't want to uncessarily create it (and fail) if the command is 
[[login]] (that means the user is trying to set up Canvas).
(There will be more cases, but we'll return to them later.)
<<we don't need [[canvas]]>>=
args.func == canvaslms.cli.login.login_command
@

To create the Canvas object, we must read the credentials using the
[[canvaslms.cli.login]] module.
If there are no credentials, we give an error about running the [[login]]
command first.
Otherwise, we try to load the Canvas object from the persistent cache.
If that fails (cache doesn't exist or is invalid), we create a new Canvas
object and will save it to the cache after the command completes.
<<create canvas object>>=
hostname, token = canvaslms.cli.login.load_credentials(config)

if not (hostname and token):
  err(1, "No hostname or token, run `canvaslms login`")

<<add https to hostname if needed>>

<<try to load canvas from cache>>

if not canvas:
  canvas = Canvas(hostname, token)
  <<configure retry policy for canvas>>
@

Now, we must specify a URL to the Canvas server, not actually a hostname.
If the hostname already contains \enquote{https}, fine; if not, we should add
it.
<<add https to hostname if needed>>=
if "://" not in hostname:
  hostname = f"https://{hostname}"
@


\subsubsection{Loading Canvas from cache}

Before creating a new Canvas object from scratch, we try to load it from the
persistent cache.
This can significantly speed up commands by reusing previously fetched course
data, assignments, users, and submissions.
<<try to load canvas from cache>>=
canvas = canvaslms.cli.cache.load_canvas_cache(token, hostname)
@

After successfully executing a command, we save the Canvas object to the cache
for future use.
We only save if the canvas object was actually used (not [[None]]).
<<save canvas to cache after command>>=
if canvas:
  canvaslms.cli.cache.save_canvas_cache(canvas, token, hostname)
@


\subsubsection{Configuring retry policy with exponential backoff}

The Canvas API, like most web services, can experience transient failures due to
network issues, temporary server overload, or rate limiting.
Consider what happens without retry logic:
A user runs [[canvaslms courses list]], but the Canvas server happens to return
an HTTP 503 error because it's briefly overloaded.
The command fails immediately with an error, and the user must manually re-run
it\,---\,possibly multiple times if the server remains under load.
This is frustrating and makes scripts brittle.

With automatic retry logic, the same scenario plays out differently:
The first request gets an HTTP 503, but instead of failing, the client waits 2
seconds and tries again.
If that fails, it waits 4 seconds, then 8, and so on.
By the time it tries the third or fourth time, the server has likely recovered,
and the request succeeds\,---\,all without user intervention.

To make [[canvaslms]] more robust and user-friendly, we configure automatic
retry handling with exponential backoff.

The [[canvasapi]] library uses the [[requests]] library internally, which in
turn uses [[urllib3]] for HTTP connections.
The [[urllib3.util.retry.Retry]] class provides sophisticated retry logic with
exponential backoff.
We configure it to handle:
\begin{description}
\item[HTTP 429 (Too Many Requests)] The standard rate-limiting response code.
\item[HTTP 500 (Internal Server Error)] Temporary server-side errors.
\item[HTTP 502 (Bad Gateway)] Upstream server errors, often transient.
\item[HTTP 503 (Service Unavailable)] Server temporarily unable to handle
  requests.
\item[HTTP 504 (Gateway Timeout)] Upstream server timeout, may succeed on retry.
\end{description}

\paragraph{Exponential backoff strategy}

Exponential backoff means that the delay between retries grows exponentially
rather than linearly.
With a backoff factor of 2, the delays follow the sequence: 2, 4, 8, 16, 32, 64,
128, 256 seconds.
We cap the maximum delay at 256 seconds to prevent excessively long waits while
still allowing the server time to recover.
With 10 total retry attempts, the total maximum time spent retrying is
approximately $2 + 4 + 8 + 16 + 32 + 64 + 128 + 256 + 256 + 256 = 1022$ seconds
(about 17 minutes).

This strategy is beneficial because:
\begin{itemize}
\item Early retries happen quickly for transient glitches (2--4 seconds).
\item Later retries give the server more time to recover from sustained issues.
\item It prevents overwhelming a struggling server with rapid retry attempts.
\end{itemize}

\paragraph{Jitter to prevent thundering herd}

We add jitter (random variation) of 0.3 to the backoff delays.
This means each delay is multiplied by a random factor between 0.7 and 1.3.
Jitter is important when many clients experience the same failure simultaneously
(for example, if the Canvas server goes down briefly and then recovers).
Without jitter, all clients would retry at exactly the same moments, potentially
overwhelming the server again.
Jitter spreads the retry attempts over time, allowing the server to recover
smoothly.

\paragraph{Respecting the Retry-After header}

When a server is rate-limiting or overloaded, it may include a [[Retry-After]]
header in the response to tell clients how long to wait before retrying.
By setting [[respect_retry_after_header=True]], we honor this guidance from the
Canvas API, which may specify shorter or longer delays than our exponential
backoff would calculate.

\paragraph{Implementation via session adapter monkey-patching}

The [[canvasapi]] library doesn't expose a way to pass custom retry configuration
through its [[Canvas]] constructor.
However, it internally creates a [[requests.Session]] object for connection pooling.
We can configure retry behavior by creating an [[HTTPAdapter]] with our retry
strategy and mounting it to the session for both [[https://]] and [[http://]]
protocols.

We access the internal session through [[canvas._Canvas__requester._session]].
This uses Python's name mangling for private attributes (the [[__requester]]
attribute becomes [[_Canvas__requester]]).
While this is somewhat fragile (it depends on [[canvasapi]]'s internal structure),
it's currently the only way to configure retries without modifying the library
itself.

<<configure retry policy for canvas>>=
retry_strategy = Retry(
  total=10,
  backoff_factor=2,
  backoff_max=256,
  backoff_jitter=0.3,
  status_forcelist=[429, 500, 502, 503, 504],
  allowed_methods=["HEAD", "GET", "PUT", "DELETE", "OPTIONS", "TRACE", "POST"],
  respect_retry_after_header=True
)

adapter = HTTPAdapter(max_retries=retry_strategy)
canvas._Canvas__requester._session.mount("https://", adapter)
canvas._Canvas__requester._session.mount("http://", adapter)
@


\subsection{Adding the subcommands}

Finally, let's add all the commands.

\paragraph{The \texttt{courses} command}

The \texttt{courses} command resides in [[canvaslms.cli.courses]] and supports 
the protocol above.
<<modules>>=
import canvaslms.cli.courses
<<add subcommands to subp>>=
canvaslms.cli.courses.add_command(subp)
@

\paragraph{The \texttt{modules} command}

The \texttt{modules} command resides in [[canvaslms.cli.modules]].
<<modules>>=
import canvaslms.cli.modules
<<add subcommands to subp>>=
canvaslms.cli.modules.add_command(subp)
@

\paragraph{The \texttt{users} command}

The \texttt{users} command resides in [[canvaslms.cli.users]].
<<modules>>=
import canvaslms.cli.users
<<add subcommands to subp>>=
canvaslms.cli.users.add_command(subp)
@

\paragraph{The assignments related commands}

There are two commands related to assignments in the 
[[canvaslms.cli.assignments]] module.
Both are added by the same function call.
<<modules>>=
import canvaslms.cli.assignments
<<add subcommands to subp>>=
canvaslms.cli.assignments.add_command(subp)
@

\paragraph{The submissions related commands}

There are two commands related to submissions in the
[[canvaslms.cli.submissions]] module.
Both are added by one function call.
<<modules>>=
import canvaslms.cli.submissions
<<add subcommands to subp>>=
canvaslms.cli.submissions.add_command(subp)
@

\paragraph{The \texttt{grade} command (backwards compatibility alias)}

For backwards compatibility, we provide a standalone [[grade]] command that
serves as an alias for [[submissions grade]].
Before the refactoring to nested subcommands, [[grade]] was a top-level command.
This alias ensures that existing scripts using [[canvaslms grade]] continue to
work without modification.

The [[grade]] command is implemented in [[canvaslms.cli.grade]] and reuses all
the functionality from the [[submissions grade]] subcommand.
<<modules>>=
import canvaslms.cli.grade
<<add subcommands to subp>>=
canvaslms.cli.grade.add_command(subp)
@

\paragraph{The \texttt{results} command}

The \texttt{results} command is located in [[canvaslms.cli.results]].
<<modules>>=
import canvaslms.cli.results
<<add subcommands to subp>>=
canvaslms.cli.results.add_command(subp)
@

\paragraph{The \texttt{calendar} commands}

The calendar commands are located in [[canvaslms.cli.calendar]].
<<modules>>=
import canvaslms.cli.calendar
<<add subcommands to subp>>=
canvaslms.cli.calendar.add_command(subp)
@

\paragraph{The \texttt{discussions} command}

The \texttt{discussions} command is located in [[canvaslms.cli.discussions]].
<<modules>>=
import canvaslms.cli.discussions
<<add subcommands to subp>>=
canvaslms.cli.discussions.add_command(subp)
@

\paragraph{The \texttt{quizzes} command}

The \texttt{quizzes} command is located in [[canvaslms.cli.quizzes]].
<<modules>>=
import canvaslms.cli.quizzes
<<add subcommands to subp>>=
canvaslms.cli.quizzes.add_command(subp)
@

\paragraph{The \texttt{pages} command}

The \texttt{pages} command manages wiki pages in Canvas courses.
It supports listing, viewing, editing, and rendering pages with YAML front
matter for Git-based workflows.
<<modules>>=
import canvaslms.cli.pages
<<add subcommands to subp>>=
canvaslms.cli.pages.add_command(subp)
@

If we use the [[quizzes]] command with a CSV file, we don't need to log in to
Canvas.
So we don't want to unnecessarily create the Canvas object in that case (and
possibly fail).
<<we don't need [[canvas]]>>=
or (args.func == canvaslms.cli.quizzes.analyse_command
    and args.csv)
@

\paragraph{The \texttt{cache} command}

The \texttt{cache} command is located in [[canvaslms.cli.cache]].
<<modules>>=
import canvaslms.cli.cache
<<add subcommands to subp>>=
canvaslms.cli.cache.add_command(subp)
@

The [[cache]] command doesn't need a Canvas object, as it just manages the
cache files.
So we don't want to unnecessarily create the Canvas object in that case.
<<we don't need [[canvas]]>>=
or args.func == canvaslms.cli.cache.clear_command
