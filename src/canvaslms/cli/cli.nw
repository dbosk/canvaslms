\chapter{The main program}

The main program functionality exists in the subpackage [[canvaslms.cli]].
In this module there is a function [[main]] which is the main function of the 
command-line interface.
We define it in this chapter.

The we use subcommands, similar to Git.
Each subcommand has its own module in [[canvaslms.cli]], each module must have 
a function [[add_command]].
The [[add_command]] function takes a subparser as an argument and adds 
its subcommand and options to it.
At the end of the chapter we will call these functions for each of the included 
modules.

\section{Dependencies and source code overview}

We use the following packages:
\begin{itemize}
\item [[appdirs]] for platform specific configuration file locations, it must 
be installed by running [[python3 -m pip install appdirs]].
\item [[argcomplete]] for bash completion, it must be installed by running 
[[python3 -m pip install argcomplete]].
\item [[canvasapi]] for the Canvas LMS REST API, it must be installed by 
running [[python3 -m pip install canvasapi]].
\end{itemize}

Then the source code can be outlined as follows.
<<cli.py>>=
"""A command-line interface for the Canvas LMS."""

import appdirs
import argcomplete, argparse
from canvasapi import Canvas
import canvaslms.cli.login
import json
import os
import pathlib
import sys
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

<<modules>>

dirs = appdirs.AppDirs("canvaslms", "dbosk@kth.se")

<<classes and exceptions>>
<<functions>>

def main():
  <<command-line interface>>
@


\section{Printing errors and warnings}

We want uniform error handling.
<<classes and exceptions>>=
class EmptyListError(Exception):
  """Exception raised when a process function returns an empty list"""
  pass
@

We will use the function [[err]] for errors and [[warn]] for warnings, both 
inspired by err(3) and warn(3) in the BSD world.
These will be available as [[canvaslms.cli.err]] and [[canvaslms.cli.warn]].
<<functions>>=
def err(rc, msg):
  """Prints msg to stderr, prints a stack trace and
  exits with rc as return code"""
  print(f"{sys.argv[0]}: error: {msg}", file=sys.stderr)
  sys.exit(rc)

def warn(msg):
  """Prints msg to stderr"""
  print(f"{sys.argv[0]}: {msg}", file=sys.stderr)
@


\section{Configuration}

We provide several ways to supply configuration to the program.
For ease, we provide a function that loads the configuration and returns a 
dictionary containing it.
<<functions>>=
def read_configuration(config_file):
  """Returns a dictionary containing the configuration"""
  config = {}

  <<read configuration file>>
  <<read environment variables>>

  return config
@

The function gets the configuration file as an argument.
We don't return any error if the file doesn't exist.
We leave that to the caller to determine what to do if the configuration is 
empty.
Likewise, we issue a warning if the configuration file is malformed, \ie it 
can't be processed as valid JSON.
<<read configuration file>>=
try:
  with open(config_file, "r") as file:
    config.update(json.load(file))
except FileNotFoundError:
  pass
except json.decoder.JSONDecodeError as err:
  warn(f"config file is malformed: {err}")
@

We can read the credentials from the environment, this takes precedence over 
the credentials in the configuration file.
<<read environment variables>>=
if "canvas" not in config:
  config["canvas"] = {}

if "CANVAS_SERVER" in os.environ:
  config["canvas"]["host"] = os.environ["CANVAS_SERVER"]

if "CANVAS_TOKEN" in os.environ:
  config["canvas"]["access_token"] = os.environ["CANVAS_TOKEN"]
@

At times, we might want to update the configuration file.
When we update the config file, we must ensure that any other part of the 
configuration file is kept, so we write the [[config]] dictionary to the config 
file.

If we get a [[FileNotFoundError]], that means the config directory doesn't 
exist and we must create it.
<<functions>>=
def update_config_file(config, config_file):
  """Updates the config file by writing the config dictionary back to it"""
  try:
    <<open and write config to config file>>
  except FileNotFoundError:
    <<create file's parent directories>>
    <<open and write config to config file>>
<<create file's parent directories>>=
os.makedirs(pathlib.PurePath(config_file).parent)
<<open and write config to config file>>=
with open(config_file, "w") as fd:
  json.dump(config, fd)
@


\section{A command-line interface}%
\label{command-line-interface}

If we run this program, we must first set up a [[canvas]] object, then process 
the command-line arguments.
<<command-line interface>>=
argp = argparse.ArgumentParser(
  description="Scriptable Canvas LMS",
  epilog="Web: https://github.com/dbosk/canvaslms")

subp = argp.add_subparsers(
  title="commands",
  dest="command",
  required=True)

<<add global options to argp>>
<<add subcommands to subp>>

argcomplete.autocomplete(argp)
args = argp.parse_args()

config = read_configuration(args.config_file)

<<run subcommands>>
@


\subsection{The configuration file location}

We want to add an option to point to a configuration file in a non-standard 
location.
<<add global options to argp>>=
argp.add_argument("-f", "--config-file",
  default=f"{dirs.user_config_dir}/config.json",
  help="Path to configuration file "
    f"(default: {dirs.user_config_dir}/config.json) "
    "or set CANVAS_SERVER and CANVAS_TOKEN environment variables.")
@


\subsection{Output format}

Many commands output data in CSV format.
By default we use the tab character as the delimiter, since this gives us 
compatibility with all the POSIX tools available at the command line.
But we provide an option to change the delimiter, \eg to a comma.
<<add global options to argp>>=
argp.add_argument("-d", "--delimiter",
  default="\t",
  help="Sets the delimiter for CSV output, the default is the tab character")
argp.add_argument("-q", "--quiet",
  action="store_true",
  help="Suppress error messages, report only exit codes")
@


\subsection{Logging in and setting up Canvas}

Each subcommand will have its own module in the package.
Each such module must have a function [[add_command]] that takes the [[subp]] 
parser as an argument and adds its command and options to that.
For example, the [[login]] command:
The \texttt{login} command is located in [[canvaslms.cli.login]].
<<modules>>=
import canvaslms.cli.login
<<add subcommands to subp>>=
canvaslms.cli.login.add_command(subp)
@

In short, each [[add_command]] must add a subparser 
([[subp.add_parser]]) that will set the [[func]] attribute.
Then we can execute the correct function and let that function check the 
remaining arguments.

Each command function must take three arguments:
\begin{enumerate}
\item the configuration,
\item a Canvas object to use for interaction with Canvas,
\item the processed command-line arguments.
\end{enumerate}
This means that we must read the credentials to create the Canvas object.
One exception is the [[login]] command: this command doesn't need the Canvas 
object as it will be run before there are credentials.
<<run subcommands>>=
if (<<we don't need [[canvas]]>>):
  canvas = None
else:
  <<create canvas object>>

if args.func:
  try:
    args.func(config, canvas, args)
  except EmptyListError as e:
    if not args.quiet:
      err(1, str(e))
    else:
      sys.exit(1)
@

We know that the [[login]] command doesn't need the Canvas object.
So we don't want to uncessarily create it (and fail) if the command is 
[[login]] (that means the user is trying to set up Canvas).
(There will be more cases, but we'll return to them later.)
<<we don't need [[canvas]]>>=
args.func == canvaslms.cli.login.login_command
@

To create the Canvas object, we must read the credentials using the 
[[canvaslms.cli.login]] module.
If there are no credentials, we give an error about running the [[login]] 
command first.
Otherwise, we create the Canvas object named [[canvas]].
<<create canvas object>>=
hostname, token = canvaslms.cli.login.load_credentials(config)

if not (hostname and token):
  err(1, "No hostname or token, run `canvaslms login`")

<<add https to hostname if needed>>

canvas = Canvas(hostname, token)

<<configure retry policy for canvas>>
@

Now, we must specify a URL to the Canvas server, not actually a hostname.
If the hostname already contains \enquote{https}, fine; if not, we should add
it.
<<add https to hostname if needed>>=
if "://" not in hostname:
  hostname = f"https://{hostname}"
@


\subsubsection{Configuring retry policy with exponential backoff}

The Canvas API, like most web services, can experience transient failures due to
network issues, temporary server overload, or rate limiting.
Consider what happens without retry logic:
A user runs [[canvaslms courses list]], but the Canvas server happens to return
an HTTP 503 error because it's briefly overloaded.
The command fails immediately with an error, and the user must manually re-run
it\,---\,possibly multiple times if the server remains under load.
This is frustrating and makes scripts brittle.

With automatic retry logic, the same scenario plays out differently:
The first request gets an HTTP 503, but instead of failing, the client waits 2
seconds and tries again.
If that fails, it waits 4 seconds, then 8, and so on.
By the time it tries the third or fourth time, the server has likely recovered,
and the request succeeds\,---\,all without user intervention.

To make [[canvaslms]] more robust and user-friendly, we configure automatic
retry handling with exponential backoff.

The [[canvasapi]] library uses the [[requests]] library internally, which in
turn uses [[urllib3]] for HTTP connections.
The [[urllib3.util.retry.Retry]] class provides sophisticated retry logic with
exponential backoff.
We configure it to handle:
\begin{description}
\item[HTTP 429 (Too Many Requests)] The standard rate-limiting response code.
\item[HTTP 500 (Internal Server Error)] Temporary server-side errors.
\item[HTTP 502 (Bad Gateway)] Upstream server errors, often transient.
\item[HTTP 503 (Service Unavailable)] Server temporarily unable to handle
  requests.
\item[HTTP 504 (Gateway Timeout)] Upstream server timeout, may succeed on retry.
\end{description}

\paragraph{Exponential backoff strategy}

Exponential backoff means that the delay between retries grows exponentially
rather than linearly.
With a backoff factor of 2, the delays follow the sequence: 2, 4, 8, 16, 32, 64,
128, 256 seconds.
We cap the maximum delay at 256 seconds to prevent excessively long waits while
still allowing the server time to recover.
With 10 total retry attempts, the total maximum time spent retrying is
approximately $2 + 4 + 8 + 16 + 32 + 64 + 128 + 256 + 256 + 256 = 1022$ seconds
(about 17 minutes).

This strategy is beneficial because:
\begin{itemize}
\item Early retries happen quickly for transient glitches (2--4 seconds).
\item Later retries give the server more time to recover from sustained issues.
\item It prevents overwhelming a struggling server with rapid retry attempts.
\end{itemize}

\paragraph{Jitter to prevent thundering herd}

We add jitter (random variation) of 0.3 to the backoff delays.
This means each delay is multiplied by a random factor between 0.7 and 1.3.
Jitter is important when many clients experience the same failure simultaneously
(for example, if the Canvas server goes down briefly and then recovers).
Without jitter, all clients would retry at exactly the same moments, potentially
overwhelming the server again.
Jitter spreads the retry attempts over time, allowing the server to recover
smoothly.

\paragraph{Respecting the Retry-After header}

When a server is rate-limiting or overloaded, it may include a [[Retry-After]]
header in the response to tell clients how long to wait before retrying.
By setting [[respect_retry_after_header=True]], we honor this guidance from the
Canvas API, which may specify shorter or longer delays than our exponential
backoff would calculate.

\paragraph{Implementation via session adapter monkey-patching}

The [[canvasapi]] library doesn't expose a way to pass custom retry configuration
through its [[Canvas]] constructor.
However, it internally creates a [[requests.Session]] object for connection pooling.
We can configure retry behavior by creating an [[HTTPAdapter]] with our retry
strategy and mounting it to the session for both [[https://]] and [[http://]]
protocols.

We access the internal session through [[canvas._Canvas__requester._session]].
This uses Python's name mangling for private attributes (the [[__requester]]
attribute becomes [[_Canvas__requester]]).
While this is somewhat fragile (it depends on [[canvasapi]]'s internal structure),
it's currently the only way to configure retries without modifying the library
itself.

<<configure retry policy for canvas>>=
retry_strategy = Retry(
  total=10,
  backoff_factor=2,
  backoff_max=256,
  backoff_jitter=0.3,
  status_forcelist=[429, 500, 502, 503, 504],
  allowed_methods=["HEAD", "GET", "PUT", "DELETE", "OPTIONS", "TRACE", "POST"],
  respect_retry_after_header=True
)

adapter = HTTPAdapter(max_retries=retry_strategy)
canvas._Canvas__requester._session.mount("https://", adapter)
canvas._Canvas__requester._session.mount("http://", adapter)
@


\subsection{Adding the subcommands}

Finally, let's add all the commands.

\paragraph{The \texttt{courses} command}

The \texttt{courses} command resides in [[canvaslms.cli.courses]] and supports 
the protocol above.
<<modules>>=
import canvaslms.cli.courses
<<add subcommands to subp>>=
canvaslms.cli.courses.add_command(subp)
@

\paragraph{The \texttt{modules} command}

The \texttt{modules} command resides in [[canvaslms.cli.modules]].
<<modules>>=
import canvaslms.cli.modules
<<add subcommands to subp>>=
canvaslms.cli.modules.add_command(subp)
@

\paragraph{The \texttt{users} command}

The \texttt{users} command resides in [[canvaslms.cli.users]].
<<modules>>=
import canvaslms.cli.users
<<add subcommands to subp>>=
canvaslms.cli.users.add_command(subp)
@

\paragraph{The assignments related commands}

There are two commands related to assignments in the 
[[canvaslms.cli.assignments]] module.
Both are added by the same function call.
<<modules>>=
import canvaslms.cli.assignments
<<add subcommands to subp>>=
canvaslms.cli.assignments.add_command(subp)
@

\paragraph{The submissions related commands}

There are two commands related to submissions in the
[[canvaslms.cli.submissions]] module.
Both are added by one function call.
<<modules>>=
import canvaslms.cli.submissions
<<add subcommands to subp>>=
canvaslms.cli.submissions.add_command(subp)
@

\paragraph{The \texttt{grade} command (backwards compatibility alias)}

For backwards compatibility, we provide a standalone [[grade]] command that
serves as an alias for [[submissions grade]].
Before the refactoring to nested subcommands, [[grade]] was a top-level command.
This alias ensures that existing scripts using [[canvaslms grade]] continue to
work without modification.

The [[grade]] command is implemented in [[canvaslms.cli.grade]] and reuses all
the functionality from the [[submissions grade]] subcommand.
<<modules>>=
import canvaslms.cli.grade
<<add subcommands to subp>>=
canvaslms.cli.grade.add_command(subp)
@

\paragraph{The \texttt{results} command}

The \texttt{results} command is located in [[canvaslms.cli.results]].
<<modules>>=
import canvaslms.cli.results
<<add subcommands to subp>>=
canvaslms.cli.results.add_command(subp)
@

\paragraph{The \texttt{calendar} commands}

The calendar commands are located in [[canvaslms.cli.calendar]].
<<modules>>=
import canvaslms.cli.calendar
<<add subcommands to subp>>=
canvaslms.cli.calendar.add_command(subp)
@

\paragraph{The \texttt{discussions} command}

The \texttt{discussions} command is located in [[canvaslms.cli.discussions]].
<<modules>>=
import canvaslms.cli.discussions
<<add subcommands to subp>>=
canvaslms.cli.discussions.add_command(subp)
@

\paragraph{The \texttt{quizzes} command}

The \texttt{quizzes} command is located in [[canvaslms.cli.quizzes]].
<<modules>>=
import canvaslms.cli.quizzes
<<add subcommands to subp>>=
canvaslms.cli.quizzes.add_command(subp)
@

If we use the [[quizzes]] command with a CSV file, we don't need to log in to 
Canvas.
So we don't want to unnecessarily create the Canvas object in that case (and 
possibly fail).
<<we don't need [[canvas]]>>=
or (args.func == canvaslms.cli.quizzes.analyse_command
    and args.csv)
