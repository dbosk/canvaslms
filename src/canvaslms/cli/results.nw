\chapter{The \texttt{results} command}
\label{results-command}

This chapter provides the subcommand [[results]], which lists the results of a 
course.
The purpose of the listing is to export results from Canvas.
The format of the listing is compatible with the \texttt{ladok3} 
package\footnote{%
  URL: \url{https://github.com/dbosk/ladok3}
}.

\section{The [[results]] subcommand and its options}

We outline the module:
<<results.py>>=
import canvaslms.cli
import canvaslms.cli.assignments as assignments
import canvaslms.cli.courses as courses
import canvaslms.cli.submissions as submissions
import canvaslms.hacks.canvasapi

import argparse
import csv
import datetime as dt
import importlib
import importlib.machinery
import importlib.util
import os
import pathlib
import re
import sys

<<functions>>

def add_command(subp):
  """Adds the results command to argparse parser subp"""
  <<add results command to subp>>
@

We add the subparser for [[results]].
The command requires two arguments: course and assignment.
We can add these by using [[add_assignment_option]], however, we don't need the 
ungraded flag as we want to export results (\ie graded material).
<<add results command to subp>>=
results_parser = subp.add_parser("results",
    help="Lists results of a course",
    description="Lists results of a course for export, for instance "
    "to the `ladok report -f` command. Output format, CSV: "
      "<course code> <component code> <student ID> <grade> <grade date>.",
    epilog="If you specify an assignment group, the results of the "
      "assignments in that group will be summarized. You can supply your "
      "own function for summarizing grades through the -S option. "
      "See `pydoc3 canvaslms.grades` for different options.")
results_parser.set_defaults(func=results_command)
assignments.add_assignment_option(results_parser, ungraded=False)
<<add option for custom summary module>>
<<add option to include Fs>>
@ We will cover the option for and loading of the custom summary module later, 
in \cref{custom-summary-module}.
Now, that [[results_command]] function must take three arguments: [[config]], 
[[canvas]] and [[args]].
However, unlike the other commands, we don't want to do the processing for the 
assignment options using [[process_assignment_option]].
We want to handle that ourselves, because we want slightly different handling.
<<functions>>=
def results_command(config, canvas, args):
  <<get results and print them>>
@

Now we'd simply like to print the results.
The user provides us with a set of courses and a set of assignments or 
assignment groups in those courses.
If the user provides assignment groups, we will automatically summarize the 
results of all assignments in the assignment group.

We also let the user choose to not include Fs in the output.
<<add option to include Fs>>=
results_parser.add_argument("-F", "--include-Fs",
  required=False, default=False, action="store_true",
  help="Include failing grades (Fs) in output. By default we only output "
    "A--Es and Ps.")
@

We will create a list of results, where each result is a tuple.
These tuples will then be printed in CSV format to standard output.
<<get results and print them>>=
output = csv.writer(sys.stdout, delimiter=args.delimiter)

assignments_list = assignments.process_assignment_option(canvas, args)

if args.assignment_group != "":
  results = summarize_assignment_groups(canvas, args)
else:
  results = summarize_assignments(canvas, args)

for result in results:
  if not args.include_Fs and result[3][0] == "F":
    continue
  output.writerow(result)
@


\section{Extracting assignment results}

In this case, we want to have one assignment per row in the output.
We want to output course, assignment, student ID, grade and submission date.

We first get the list of courses.
We do this to then get the list of all users in all courses.
We need these to get the integration ID.

Then we get the list of assignments in all courses.
We get the submissions for each assignment.
These submissions are filtered by user.
We do this because this attaches a [[user]] attribute to each submissions with 
the details of each user.
This gives a trivial [[yield]] statement at the end.
<<functions>>=
def summarize_assignments(canvas, args):
  """Turn submissions into results,
  canvas is a Canvas object,
  args is the command-line arguments"""

  courses_list = courses.process_course_option(canvas, args)

  users_list = []
  for course in courses_list:
    for user in course.get_users(enrollment_type=["student"]):
      users_list.append(user)

  assignments_list = assignments.process_assignment_option(canvas, args)
  submissions_list = submissions.filter_submissions(
    submissions.list_submissions(assignments_list, include=[]),
    users_list)

  for submission in submissions_list:
    if submission.grade is not None:
      yield (
        submission.assignment.course.course_code,
        submission.assignment.name,
        submission.user.integration_id,
        submission.grade,
        submission.submitted_at or submission.graded_at
        )
@


\section{Summarizing assignment group results}

In this case, we want to have one assignment group per row in the output.
We want to output course, assignment group, student ID, summarized grade based 
on all assignments in the group and the latest submission date.

Unlike the previous case, here we must maintain the structure of which 
assignments belong to which assignment group so that we can check easily that a 
user has passed all assignments in the group.
<<functions>>=
def summarize_assignment_groups(canvas, args):
  """Summarize assignment groups into a single grade,
  canvas is a Canvas object,
  args is the command-line arguments"""

  <<load the correct summary module as summary>>

  courses_list = courses.process_course_option(canvas, args)
  all_assignments = list(assignments.process_assignment_option(canvas, args))

  for course in courses_list:
    users_list = list(course.get_users(enrollment_type=["student"]))
    ag_list = assignments.filter_assignment_groups(
      course, args.assignment_group)

    for assignment_group in ag_list:
      assignments_list = list(assignments.filter_assignments_by_group(
        assignment_group, all_assignments))
      for user, grade, grade_date in summary.summarize_group(
        assignments_list, users_list):
          yield (
            course.course_code,
            assignment_group.name,
            user.integration_id,
            grade,
            grade_date
          )
@ We will now cover the [[summarize_group]] function in the [[summary]] module.


\subsection{Loading a custom summary module}

Different teachers have different policies for merging several assignments into 
one grade.
We now want to provide a way to override the default function.
<<add option for custom summary module>>=
default_summary_module = "canvaslms.grades.conjunctavg"
results_parser.add_argument("-S", "--summary-module",
  required=False, default=default_summary_module,
  help="Name of Python module or file containing module to "
    "load with a custom summarization function "
    "to summarize assignment groups. The default module is part of the "
    f"`canvaslms` package: `{default_summary_module}`. "
    "This module must contain a function "
    "`summarize_group(assignments, users)`, where `assignments` "
    "is a list of `canvasapi.assignment.Assignment` objects and "
    "`users` is a list of `canvasapi.user.User` objects. The return value "
    "must be a list of tuples of the form "
    "`(user object, grade, grade date)`.")
@

Now, let's load the module into the identifier [[summary]] for the above code.
This is a very dangerous construction.
An attacker can potentially load their own module and have it execute when 
reporting grades.
For instance, a malicious module could change grades, \eg always set 
A's.

Now to the loader, we first try to load a system module, then we look for a 
module in the current working directory.
<<load the correct summary module as summary>>=
try:
  summary = importlib.import_module(args.summary_module)
except ModuleNotFoundError:
  module_path = pathlib.Path.cwd() / args.summary_module
  module = module_path.stem

  try:
    loader = importlib.machinery.SourceFileLoader(
      module, str(module_path))
    spec = importlib.util.spec_from_loader(module, loader)
    summary = importlib.util.module_from_spec(spec)
    loader.exec_module(summary)
  except Exception as err:
    canvaslms.cli.err(1, f"Error loading summary module "
      f"'{args.summary_module}': {err}")
@

The available summary functions and the default one can be found in 
\cref{summary-modules}.

