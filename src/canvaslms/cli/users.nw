\chapter{The \texttt{users} and \texttt{groups} commands}

This chapter provides the subcommand [[users]], which lists the users of a 
given course.
We also provide some functions as part of this module that are useful for other 
commands to use.

In particular, we provide the function~[[add_user_option]] which adds the 
[[-u]] option to specify a user and the function~[[process_user_option]] which 
filters out that user from a set of courses.

\section{Module outline}

For selecting the course for which to list the users, we use the 
[[add_course_option]] and [[process_course_option]] functions from the 
[[canvaslms.cli.courses]] module.

We outline the module:
<<users.py>>=
import argparse
import canvasapi.course
import canvasapi.group
import canvaslms.cli
import canvaslms.cli.courses as courses
import canvaslms.hacks.canvasapi
import csv
import re
import sys

<<functions>>

def add_command(subp):
  """Adds the subcommands users and groups to argparse subparser subp"""
  add_users_command(subp)
  add_groups_command(subp)
@


\section{The \texttt{users} command}

The \texttt{users} command lists users in a course and relevant data about 
them.
<<functions>>=
def add_users_command(subp):
  """Adds the users subcommand and its options to argparse subparser subp"""
  users_parser = subp.add_parser("users",
    help="Lists users of a course",
    description="Lists users of a course(s). Output, CSV-format: "
      "<course> [<group>] [<Canvas ID>] <login ID> [<LADOK ID>] "
      "<name> [<email>]")
  users_parser.set_defaults(func=users_command)
  courses.add_course_option(users_parser)
  add_group_option(users_parser)
  <<set up options for selecting type of users>>
  <<set up options for selecting user attributes>>
  <<add positional argument for user regex>>
@ Now, that function~[[users_command]] must take three arguments: [[config]], 
[[canvas]] and [[args]].
<<functions>>=
def users_command(config, canvas, args):
  <<process options for selecting type of users>>
  <<get users and print them>>
@ We will cover the set up and processing of the options in the following 
subsections.

\subsection{Selecting the type of users}

We also want to be able to filter out the type of users.
For now, we focus on students and teachers.
<<set up options for selecting type of users>>=
users_parser.add_argument("-s", "--students", action="store_true",
  help="Include students.")
users_parser.add_argument("-a", "--assistants", action="store_true",
  help="Include teaching assistants.")
@

We want students by default, if the user doesn't specify anything.
Otherwise, we add them together.
<<process options for selecting type of users>>=
roles = []
if args.students:
  roles.append("student")
if args.assistants:
  roles.append("ta")
@

\subsection{Selecting the user attributes}

We want to be able to select which user attributes that we want to print.
The attributes that are interesting are
\begin{itemize}
\item Canvas ID (optional),
\item KTH ID (login email),
\item LADOK ID (optional),
\item name (or first name and last name as separate fields),
\item registered email address (optional).
\end{itemize}
We will make the Canvas ID, LADOK ID and email address optional.
<<set up options for selecting user attributes>>=
users_parser.add_argument("-i", "--canvas-id", action="store_true",
  help="Include Canvas identifier")
users_parser.add_argument("-l", "--ladok", action="store_true",
  help="Include LADOK identifier")
users_parser.add_argument("-S", "--split-name", action="store_true",
  help="Returns first and last names as separate fields, "
    "instead of one containing the full name.")
users_parser.add_argument("-e", "--email", action="store_true",
  help="Include email address")
@

\subsection{Specifying a user regex}

We have an optional positional argument for specifying a regex to filter users.
We set the default to match everything.
<<add positional argument for user regex>>=
users_parser.add_argument("regex",
  default=".*", nargs="?",
  help="Regex for filtering users, default: '.*'")
@

\subsection{Get and print the list of users}

We have several options to do this.
In the basic case, we simply call the list-users function with the 
[[course_list]] object and the [[roles]] list as the parameters.
Then we will print the most useful attributes (identifiers) of a user.
However, when we filter by groups, we would like to include the group in the 
output.
<<get users and print them>>=
output = csv.writer(sys.stdout, delimiter=args.delimiter)

if args.group or args.category:
  rows = make_user_rows_w_groups(canvas, args, roles)
else:
  rows = make_user_rows(canvas, args, roles)

for row in rows:
  output.writerow(row)
@

We start by creating a list of rows without group information.
<<functions>>=
def make_user_rows(canvas, args, roles):
  """Takes a list of courses and returns a list of users in those courses"""

  course_list = courses.process_course_option(canvas, args)

  users = filter_users(
    course_list,
    args.regex,
    roles)

  for user in users:
    try:
      row = []
      row.append(user.course.course_code)
      if args.canvas_id:
        row.append(user.id)
      row.append(user.login_id)
      if args.ladok:
        row.append(user.integration_id)
      if args.split_name:
        lastnames, firstnames = user.sortable_name.split(", ")
        row.append(firstnames.strip())
        row.append(lastnames.strip())
      else:
        row.append(user.name)
      if args.email:
        row.append(user.email)
    except AttributeError as err:
      canvaslms.cli.warn(f"skipped {user}: {err}")
      continue

    yield row
@ Note that in most cases, the [[user.login_id]] and [[user.email]] will be the 
same.
However, we need both, because the students can change their email address to a 
non-KTH address.
Also note, there are users for whom some attributes don't exist, hence we must 
first extract them in a try-except construction.
This happens if they've been removed from the course or never registered.

If we filter by groups, then we must iterate over the groups to include the 
group information.
<<functions>>=
def make_user_rows_w_groups(canvas, args, roles):
  """Takes a list of courses and returns a list of users in those courses,
  includes a group column"""

  groups = process_group_options(canvas, args)

  for group in groups:
    users = filter_users([group], args.regex, roles)

    for user in users:
      try:
        try:
          row = [group.category.course.course_code]
        except AttributeError:
          pass
        try:
          row = [group.course.course_code]
        except AttributeError:
          pass
        row.append(group.name)
        if args.canvas_id:
          row.append(user.id)
        row.append(user.login_id)
        if args.ladok:
          row.append(user.integration_id)
        if args.split_name:
          lastnames, firstnames = user.sortable_name.split(", ")
          row.append(firstnames.strip())
          row.append(lastnames.strip())
        else:
          row.append(user.name)
        if args.email:
          row.append(user.email)
      except AttributeError as err:
        canvaslms.cli.warn(f"skipped {user}: {err}")
        continue

      yield row
@


\section{The \texttt{groups} command}

The \texttt{groups} command lists groups in a course and relevant data about 
them.
Particularly, we start by group categories and then the actual groups.
<<functions>>=
def add_groups_command(subp):
  """Adds the groups subcommand and its options to argparse subparser subp"""
  groups_parser = subp.add_parser("groups",
    help="Lists groups of a course",
    description="Lists groups of a course(s). Output, CSV-format: "
      "<Canvas ID> <group category> <group name> <#members>")
  groups_parser.set_defaults(func=groups_command)
  courses.add_course_option(groups_parser)
  <<add groups specific options>>
@ Now, that function~[[groups_command]] must take three arguments: [[config]], 
[[canvas]] and [[args]].
<<functions>>=
def groups_command(config, canvas, args):
  course_list = courses.process_course_option(canvas, args)
  <<get groups and print them>>
@ We will cover the set up and processing of the options in the following 
subsections.

\subsection{Group specific options}

We have an optional positional argument for specifying a regex to filter groups.
We set the default to match everything.
<<add groups specific options>>=
add_group_category_option(groups_parser)
groups_parser.add_argument("regex", metavar="group_regex",
  default=".*", nargs="?",
  help="Regex for filtering groups, default: '.*'")
@

\subsection{Get and print the list of groups}

We then simply call the list-groups function with the [[course_list]] object 
and the [[roles]] list as the parameters.
Then we will print the most useful attributes (identifiers) of a user.
<<get groups and print them>>=
output = csv.writer(sys.stdout, delimiter=args.delimiter)
if args.category:
  categories = filter_group_categories(course_list, args.category)
else:
  categories = filter_group_categories(course_list, ".*")

for category in categories:
  for group in filter_groups([category], args.regex):
    row = [group.id, category.name, group.name, group.members_count]
    output.writerow(row)
@


\section{Producing lists of groups}

We want to do two things: filter out group categories from courses, from which 
we can filter out groups; or filter out groups directly from courses.

\subsection{Filtering out group categories}

We want to filter out the group categories from a list of courses.
<<functions>>=
def filter_group_categories(course_list, regex):
  """Filters out the group categories whose names match regex
  in the courses in course_list"""

  name = re.compile(regex or ".*")

  for course in course_list:
    for category in course.get_group_categories():
      if name.search(category.name):
        category.course = course
        yield category
@

\subsection{Filtering out groups}

We can produce a list of groups in two ways:
list all groups in a course or lists all groups in a group category.
Fortunately, both the group category and course objects of [[canvasapi]] have a 
method [[.get_groups()]], so thanks to Python's duck typing we can write short 
code.
<<functions>>=
def filter_groups(items, regex):
  """Items is a list of either courses or group categories,
  regex is a regular expression.
  Returns all groups whose name match regex."""

  name = re.compile(regex or ".*")

  for item in items:
    for group in item.get_groups():
      if name.search(group.name):
        if isinstance(item, canvasapi.course.Course):
          group.course = item
        elif isinstance(item, canvasapi.group.GroupCategory):
          group.category = item
        yield group
@


\section{Producing a list of users}%
\label{list-users-function}

We provide the following functions:
\begin{itemize}
  \item [[filter_users]], which returns a list of users filtered by regex 
  matching their name, login ID or Canvas ID;
  \item [[list_students]], which returns a list of enrolled students;
  \item [[list_teachers]], which returns a list of teachers;
  \item [[list_users]], which is a general function that also takes a list of 
  roles.
\end{itemize}

First, we provide [[list_users]], which takes a list of courses and a list of 
Canvas roles as arguments.
<<functions>>=
def list_users(courses, roles):
  """List users in courses with roles"""
  users = list()

  for course in courses:
    course_users = list(course.get_users(enrollment_type=roles))
    for user in course_users:
      user.course = course
    users.extend(course_users)

  return users
@

Second, we provide the most general function, [[filter_users]], which takes a 
list of courses, a list of Canvas roles and a regex as arguments.
<<functions>>=
def filter_users(course_list, regex, roles=[]):
  """Filter users in courses with roles based on regex

  regex is matched on login ID, Canvas ID and name."""
  pattern = re.compile(regex or ".*")

  for user in list_users(course_list, roles):
    if pattern.search(user.name):
      yield user
      continue

    try:
      if pattern.search(user.login_id):
        yield user
        continue
    except AttributeError:
      canvaslms.cli.warn(f"{user} has no login_id")

    if str(user.id) == regex:
      yield user
      continue

    try:
      if user.integration_id == regex:
        yield user
        continue
    except AttributeError:
      canvaslms.cli.warn(f"{user} has no integration_id")
@

Now, we can define the function~[[list_students]] in terms of [[list_users]].
<<functions>>=
def list_students(courses):
  """List users in courses with role student"""
  return list_users(courses, ["student"])

def list_teachers(courses):
  """List users in courses with role teacher"""
  return list_users(courses, ["teacher"])
@


\section{Options for the command line}

We provide two ways to filter out users by command-line option:
\begin{itemize}
\item just filter among all users in a course directly, or
\item filter by groups in a course and select all users in the groups that 
match.
\end{itemize}
We provide functions that add either option, but we also provide a function 
which add these as mutually exclusive options.

\subsection{The user option}

We provide the two helper functions for other modules to filter out users from 
a set of courses.
This option requires the course option from [[canvaslms.cli.courses]].
<<functions>>=
def add_user_option_wo_depends(parser):
  """Adds the -u option to argparse parser,
  without adding other required options"""
  user_parser = parser.add_argument_group("filter by user")
  user_parser.add_argument("-u", "--user", metavar="user_regex",
    required=False, default=".*",
    help="Filter users on name, login ID or Canvas ID by user_regex, "
      "default: '.*'")

def add_user_option(parser):
  """Adds the -u option to argparse parser"""
  try:
    courses.add_course_option(parser)
  except argparse.ArgumentError:
    pass

  add_user_option_wo_depends(parser)
@

When processing this option, we need to filter by course first.
<<functions>>=
def process_user_option(canvas, args):
  """Processes the user option from command line, returns a list of users"""
  return list(filter_users(
    courses.process_course_option(canvas, args),
    args.user))
@

\subsection{The group option}

The group option is a bit more complex.
We can choose groups by either filtering on the group names directly or by 
first filtering on the group categories and filtering only groups in a given 
category.
The latter is useful as students can change the name of a group so it doesn't 
match the group category by prefix.
<<functions>>=
def add_group_category_option_wo_depends(parser):
  """Adds the group category option, without adding required other options"""
  parser.add_argument("-C", "--category", metavar="category_regex",
    required=False,
    help="Filters groups only from the group categories matching "
      "category_regex")

def add_group_category_option(parser):
  """Adds the group category option, adds required options"""
  try:
    courses.add_course_option(parser)
  except argparse.ArgumentError:
    pass

  add_group_category_option_wo_depends(parser)

def add_group_option_wo_depends(parser):
  """Adds group filtering option to argparse parser,
  without adding required options"""

  group_parser = parser.add_argument_group("filter by group")
  add_group_category_option_wo_depends(group_parser)
  group_parser.add_argument("-G", "--group", metavar="group_regex",
    required=False,
    help="Filters groups whose name match group_regex")

def add_group_option(parser):
  """Adds group filtering options to argparse parser,
  adds required other options"""
  try:
    courses.add_course_option(parser)
  except argparse.ArgumentError:
    pass

  add_group_option_wo_depends(parser)
@

We must also provide a function that can process these options.
<<functions>>=
def process_group_options(canvas, args):
  """Processes the group/group category options, returns a list of groups"""

  course_list = courses.process_course_option(canvas, args)

  if args.category:
    return list(filter_groups(
      filter_group_categories(course_list, args.category),
      args.group))

  return list(filter_groups(
    course_list,
    args.group))
@

\subsection{An option for user or group}

Finally, we can provide both options together, but mutually exclusive so that 
only one option can be used at a time.
The processing must return a list of users, so in case of the group option we 
must extract the users.
<<functions>>=
def add_user_or_group_option(parser):
  """Adds user and group options as mutually exclusive options to parser"""
  try:
    courses.add_course_option(parser)
  except argparse.ArgumentError:
    pass

  add_user_option_wo_depends(parser)
  add_group_option_wo_depends(parser)

def process_user_or_group_option(canvas, args):
  """Returns a list of users, filtered either by user regex or by groups"""
  if args.group or args.category:
    users = list()
    for group in process_group_options(canvas, args):
      users.extend(group.get_users())

    return users

  return process_user_option(canvas, args)
@

