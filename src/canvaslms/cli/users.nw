\chapter{The \texttt{users} command}

This chapter provides the subcommand [[users]], which lists the users of a 
given course.
We also provide some functions as part of this module that are useful for other 
commands to use.

In particular, we provide the function~[[add_user_option]] which adds the 
[[-u]] option to specify a user and the function~[[process_user_option]] which 
filters out that user from a set of courses.

\section{Module outline}

For selecting the course for which to list the users, we use the 
[[add_course_option]] and [[process_course_option]] functions from the 
[[canvaslms.cli.courses]] module.

We outline the module:
<<users.py>>=
import canvaslms.cli.courses as courses
import csv
import re
import sys

<<functions>>

def add_command(subp):
  """Adds the subcommand and its options to argparse subparser subp"""
  users_parser = subp.add_parser("users", help="Lists users of a course",
      description="Output, CSV-format: " +
        "<Canvas ID> <login ID> [<LADOK ID>] <name> [<email>]")
  users_parser.set_defaults(func=users_command)
  courses.add_course_option(users_parser)
  <<set up options for selecting type of users>>
  <<set up options for selecting user attributes>>
  <<add positional argument for user regex>>
@ Now, that [[users_command]] function must take three arguments: [[config]], 
[[canvas]] and [[args]].
<<functions>>=
def users_command(config, canvas, args):
  course_list = courses.process_course_option(canvas, args)
  <<process options for selecting type of users>>
  <<get users and print them>>
@ We will cover the set up and processing of the options in the following 
subsections.

\section{Selecting the type of users}

We also want to be able to filter out the type of users.
For now, we focus on students and teachers.
<<set up options for selecting type of users>>=
users_parser.add_argument("-s", "--students", action="store_true",
  help="Include students.")
users_parser.add_argument("-t", "--teachers", action="store_true",
  help="Include teachers.")
users_parser.add_argument("-a", "--assistants", action="store_true",
  help="Include teaching assistants.")
@

We want students by default, if the user doesn't specify anything.
Otherwise, we add them together.
<<process options for selecting type of users>>=
roles = []
if args.students:
  roles.append("student")
if args.teachers:
  roles.append("teacher")
if args.assistants:
  roles.append("ta")
@


\section{Selecting the user attributes}

We want to be able to select which user attributes that we want to print.
The attributes that are interesting are
\begin{itemize}
\item Canvas ID,
\item KTH ID (login email),
\item LADOK ID,
\item name,
\item registered email address.
\end{itemize}
We will make the LADOK ID and email address optional.
<<set up options for selecting user attributes>>=
users_parser.add_argument("-l", "--ladok", action="store_true",
  help="Include LADOK identifier")
users_parser.add_argument("-e", "--email", action="store_true",
  help="Include LADOK identifier")
@


\section{Specifying a user regex}

We have an optional positional argument for specifying a regex to filter users.
We set the default to match everything.
<<add positional argument for user regex>>=
users_parser.add_argument("regex",
  default=".*", nargs="?",
  help="Regex for filtering users, default: '.*'")
@


\section{Get and print the list of users}

We then simply call the list-users function with the [[course_list]] object and 
the [[roles]] list as the parameters.
Then we will print the most useful attributes (identifiers) of a user.
<<get users and print them>>=
output = csv.writer(sys.stdout, delimiter=args.delimiter)
users = filter_users(course_list, args.regex, roles)

for user in users:
  try:
    cid = user.id
    lid = user.login_id
    iid = user.integration_id
    name = user.name
    email = user.email
  except AttributeError as err:
    warn(f"skipped {user}: {err}")
    continue

  row = []
  row.append(cid)
  row.append(lid)
  if args.ladok:
    row.append(iid)
  row.append(name)
  if args.email:
    row.append(email)

  output.writerow(row)
@ Note that in most cases, the [[user.login_id]] and [[user.email]] will be the 
same.
However, we need both, because the students can change their email address to a 
non-KTH address.
Also note, there are users for whom some attributes don't exist, hence we must 
first extract them in a try-except construction.
This happens if they've been removed from the course or never registered.


\section{Producing a list of users}%
\label{list-users-function}

We provide the following functions:
\begin{itemize}
  \item [[filter_users]], which returns a list of users filtered by regex 
  matching their name, login ID or Canvas ID;
  \item [[list_students]], which returns a list of enrolled students;
  \item [[list_teachers]], which returns a list of teachers;
  \item [[list_users]], which is a general function that also takes a list of 
  roles.
\end{itemize}

First, we provide the most general function, [[filter_users]], which takes a 
list of courses, a list of Canvas roles and a regex as arguments.
<<functions>>=
def filter_users(courses, regex, roles=[]):
  """Filter users in courses with roles based on regex

  regex is matched on login ID, Canvas ID and name."""
  name = re.compile(regex)
  login = re.compile(f"^{regex}@kth.se$")
  id = re.compile(f"^{regex}$")

  for course in courses:
    users = course.get_users(enrollment_type=roles) if roles \
      else course.get_users()
    for user in users:
      if name.search(user.name):
        yield user
        continue
      if login.search(user.login_id):
        yield user
        continue
      if id.search(str(user.id)):
        yield user
        continue
      if id.search(user.integration_id):
        yield user
        continue
@

Second, we provide [[list_users]], which takes a list of courses and a list of 
Canvas roles as arguments.
<<functions>>=
def list_users(courses, roles):
  """List users in courses with roles"""
  for course in courses:
    users = course.get_users(enrollment_type=roles)
    for user in users:
      yield user
@

Now, we can define the function~[[list_students]] in terms of [[list_users]].
<<functions>>=
def list_students(courses):
  """List users in courses with role student"""
  return list_users(courses, ["student"])

def list_teachers(courses):
  """List users in courses with role teacher"""
  return list_users(courses, ["teacher"])
@


\section{A user option}

We provide the two helper functions for other modules to filter out users from 
a set of courses.
This option requires the course option from [[canvaslms.cli.courses]].
<<functions>>=
def add_user_option(parser):
  """Adds the -u option to argparse parser"""
  courses.add_course_option(parser)

  parser.add_argument("-u", "--user",
    required=False, default=".*",
    help="Filter users on name, login ID or Canvas ID by regex, "
      "default: '.*'")
@

When processing this option, we need to filter by course first.
<<functions>>=
def process_user_option(canvas, args):
  """Processes the user option from command line, returns a list of users"""
  return filter_users(
    courses.process_course_option(canvas, args),
    args.user)
@

