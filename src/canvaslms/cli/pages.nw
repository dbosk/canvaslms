\chapter{The [[pages]] command}
\chapterprecis{%
  This chapter provides commands for managing Canvas wiki pages.
}

This chapter provides the [[pages]] module with its subcommands: [[list]],
[[view]], and [[edit]]. Canvas wiki pages are a flexible content type used
for course information, resources, and documentation that doesn't fit into
announcements or assignments.

The module follows the same bidirectional workflow as announcements and
assignments: pages can be exported to Markdown with YAML front matter using
[[view]] (piped to a file), edited locally (perhaps in a Git repository),
and pushed back to Canvas using [[edit -f]].


\section{Module outline}

We structure the module following the standard CLI pattern, with functions
for adding commands and processing options.
<<[[pages.py]]>>=
import logging
import re
import sys

import pypandoc
import rich.console
import rich.markdown
import rich.syntax

from datetime import datetime

import canvaslms.cli
import canvaslms.cli.content
import canvaslms.cli.courses
import canvaslms.cli.modules

logger = logging.getLogger(__name__)

<<functions>>

def add_command(subp):
  """Adds the pages command with subcommands to argparse parser"""
  pages_parser = subp.add_parser("pages",
    help="Manage course wiki pages",
    description="Manage wiki pages in Canvas courses: list, view, and edit.")

  pages_subp = pages_parser.add_subparsers(
    title="pages commands",
    dest="pages_command",
    required=True)

  <<add pages list subcommand>>
  <<add pages view subcommand>>
  <<add pages edit subcommand>>
@


\section{Common options for page selection}

All page commands need to select a course and optionally filter pages by title
or module membership. We provide helper functions to add these options
consistently.

The filters use AND logic: if both [[-p]] and [[-M]] are specified, only pages
matching both criteria are returned. This is consistent with how assignments
handle multiple filters.
<<functions>>=
def add_page_options(parser, required=False):
  """Add course and page selection options to a parser."""
  canvaslms.cli.courses.add_course_option(parser, required=required)
  parser.add_argument("-p", "--page",
    default=".*",
    help="Regex matching page title or URL slug, default: '.*'")
  parser.add_argument("-M", "--module",
    default="",
    help="Regex matching module title or Canvas identifier. "
         "Can be combined with -p for AND filtering.")

def process_page_option(canvas, args):
  """Process page options and return matching pages."""
  course_list = canvaslms.cli.courses.process_course_option(canvas, args)
  pages = []
  for course in course_list:
    <<filter pages for course>>
  if not pages:
    raise canvaslms.cli.EmptyListError("No pages found matching the criteria")
  return pages

def filter_pages(course, regex):
  """Return pages from course whose title or URL matches regex."""
  pattern = re.compile(regex)
  result = []
  for page in course.get_pages():
    if pattern.search(page.title) or pattern.search(page.url):
      page.course = course
      result.append(page)
  return result
@

\subsection{Sequential filtering}

We apply filters sequentially: first filter by page title/URL, then by module
membership if [[-M]] is specified. This mirrors the approach used in the
assignments subcommand.
<<filter pages for course>>=
filtered_pages = filter_pages(course, args.page)

if args.module:
  course_modules = canvaslms.cli.modules.filter_modules(course, args.module)
  filtered_pages = list(canvaslms.cli.modules.filter_pages_by_module_list(
      course_modules, filtered_pages))

pages.extend(filtered_pages)
@


\section{The [[pages list]] subcommand}

The [[list]] subcommand shows pages in a tabular format suitable for
processing with standard UNIX tools. Output is tab-separated: course code,
page title, published status, and URL.
<<add pages list subcommand>>=
list_parser = pages_subp.add_parser("list",
    help="List wiki pages in a course",
    description="Lists wiki pages from courses. "
      "Output: <course> <title> <published> <url>")
list_parser.set_defaults(func=pages_list_command)
add_page_options(list_parser)
@

<<functions>>=
def pages_list_command(config, canvas, args):
  """List wiki pages from courses."""
  import csv
  output = csv.writer(sys.stdout, delimiter=args.delimiter)
  pages = process_page_option(canvas, args)

  for page in pages:
    output.writerow([
      page.course.course_code,
      page.title,
      "published" if page.published else "unpublished",
      page.html_url
    ])
@


\section{The [[pages view]] subcommand}

The [[view]] subcommand displays detailed page content. When output is a TTY,
it shows rich formatting with a pager. When piped, it outputs YAML front matter
plus Markdown suitable for editing and pushing back with [[edit -f]].

\subsection{The [[--html]] option}

By default, [[view]] converts page content from HTML to Markdown for easier
reading and editing. However, some pages contain elements that don't convert
well to Markdown: embedded videos, iframes, complex tables, or custom HTML
formatting. The [[--html]] option preserves the original HTML content.

When [[--html]] is specified:
\begin{description}
\item[TTY output] Shows syntax-highlighted HTML in the pager
\item[Piped output] Outputs YAML front matter plus raw HTML body
\end{description}

This enables a round-trip workflow where HTML pages can be viewed, edited, and
pushed back without losing any formatting.
<<add pages view subcommand>>=
view_parser = pages_subp.add_parser("view",
    help="View page content",
    description="View wiki page content. When piped, outputs editable format "
      "with YAML front matter. Use --html to preserve HTML instead of "
      "converting to Markdown.")
view_parser.set_defaults(func=pages_view_command)
add_page_options(view_parser)
view_parser.add_argument("--html",
    action="store_true",
    help="Output raw HTML instead of converting to Markdown")
@

<<functions>>=
def pages_view_command(config, canvas, args):
  """View wiki page content."""
  console = rich.console.Console()
  pages = process_page_option(canvas, args)

  for page in pages:
    <<fetch full page content>>

    if sys.stdout.isatty():
      if args.html:
        <<output page html in tty>>
      else:
        output = format_page(full_page)
        with console.pager(styles=False, links=True):
          console.print(rich.markdown.Markdown(output, code_theme="manni"))
    else:
      if args.html:
        <<output page in html format>>
      else:
        <<output page in editable format>>
@

\subsection{Editable output format}

When output is piped (not a TTY), we output the page in an editable format:
YAML front matter with attributes followed by the body converted to Markdown.
This format can be saved to a file, edited, and pushed back to Canvas using
[[pages edit -f]].

The front matter includes a [[modules]] field listing which modules currently
contain this page. Users can edit this list to control module membership:
\begin{description}
\item[Omit or leave unchanged] Module membership is not modified
\item[Set to empty list] Page is removed from all modules
\item[Set to list of regexes] Page is placed in exactly those modules matching
  the patterns (added to matching, removed from non-matching)
\end{description}

<<output page in editable format>>=
<<get current modules for page>>
output = canvaslms.cli.content.render_to_markdown(
    full_page,
    canvaslms.cli.content.PAGE_SCHEMA,
    content_attr='body',
    extra_attributes={'modules': page_modules})
print(output)
@

We query the current module membership using the utility function from the
modules module. Pages are identified by their URL slug.
<<get current modules for page>>=
page_modules = canvaslms.cli.modules.get_item_modules(
    full_page.course, 'Page', full_page.url)
@

\subsection{HTML output format}

When [[--html]] is specified, we preserve the original HTML content instead of
converting to Markdown. This is the counterpart to the editable format above.

For TTY output, we display the HTML with syntax highlighting. We show a header
with metadata first (same as the Markdown view), then the raw HTML body with
syntax highlighting for readability.
<<output page html in tty>>=
header = f"# {full_page.title}\n\n"
header += f"## Metadata\n\n"
header += f"- Course: {full_page.course.course_code}\n"
header += f"- Published: {'Yes' if full_page.published else 'No'}\n"
header += f"- URL: {full_page.html_url}\n"
if hasattr(full_page, 'front_page') and full_page.front_page:
  header += f"- Front page: Yes\n"
if hasattr(full_page, 'editing_roles'):
  header += f"- Editing roles: {full_page.editing_roles}\n"
header += "\n## Content (HTML)\n\n"

with console.pager(styles=True):
  console.print(rich.markdown.Markdown(header))
  if hasattr(full_page, 'body') and full_page.body:
    syntax = rich.syntax.Syntax(full_page.body, "html", theme="monokai",
                                word_wrap=True)
    console.print(syntax)
  else:
    console.print("(No content)")
@

For piped output, we use [[render_to_html]] from the content module to produce
YAML front matter with the raw HTML body. This can be saved to a file, edited,
and pushed back using [[pages edit --html -f]].
<<output page in html format>>=
<<get current modules for page>>
output = canvaslms.cli.content.render_to_html(
    full_page,
    canvaslms.cli.content.PAGE_SCHEMA,
    content_attr='body',
    extra_attributes={'modules': page_modules})
print(output)
@

The page object returned by [[get_pages()]] doesn't include the body content.
We need to fetch the full page using [[get_page()]] with the URL slug.
<<fetch full page content>>=
full_page = page.course.get_page(page.url)
full_page.course = page.course
@

<<functions>>=
def format_page(page):
  """Format a wiki page for terminal display."""
  text = f"# {page.title}\n\n"
  text += f"## Metadata\n\n"
  text += f"- Course: {page.course.course_code}\n"
  text += f"- Published: {'Yes' if page.published else 'No'}\n"
  text += f"- URL: {page.html_url}\n"

  if hasattr(page, 'front_page') and page.front_page:
    text += f"- Front page: Yes\n"

  if hasattr(page, 'editing_roles'):
    text += f"- Editing roles: {page.editing_roles}\n"

  text += "\n## Content\n\n"

  if hasattr(page, 'body') and page.body:
    try:
      markdown_content = pypandoc.convert_text(page.body, 'md', format='html')
      text += markdown_content
    except Exception:
      text += page.body
  else:
    text += "(No content)"

  return text
@


\section{The [[pages edit]] subcommand}

The [[edit]] subcommand updates page content. It supports two modes:
\begin{description}
\item[Interactive mode] (default): Opens matching pages one by one in your
  editor, shows a preview, and asks whether to accept, edit further, or discard.
  This is the default when no [[-f]] option is given.
\item[File mode] ([[-f]]): Reads content from a Markdown file with YAML front
  matter and updates directly without preview. This enables a Git-based workflow:
  export page content with [[view]] (piped to a file), edit locally, and push
  changes back with [[edit -f]].
\end{description}
<<add pages edit subcommand>>=
edit_parser = pages_subp.add_parser("edit",
    help="Edit page content interactively or from a file",
    description="Edit wiki page content. Without -f, opens each matching "
      "page in your editor for interactive editing with preview. "
      "With -f, reads from a Markdown file with YAML front matter and updates "
      "directly (script-friendly). If the YAML contains a 'url' field, the "
      "command uses it to identify the page; use --create to create a new page "
      "if the URL is not found. Use --html to read/edit HTML directly without "
      "Markdown conversion.")
edit_parser.set_defaults(func=pages_edit_command)
add_page_options(edit_parser, required=True)
canvaslms.cli.content.add_file_option(edit_parser)
edit_parser.add_argument("--create",
    action="store_true",
    help="Create a new page if the URL in the YAML is not found")
edit_parser.add_argument("--html",
    action="store_true",
    help="Read file as HTML instead of converting from Markdown. "
         "In interactive mode, edit HTML directly.")
@

<<functions>>=
def pages_edit_command(config, canvas, args):
  """Edit wiki page content interactively or from file."""
  if args.file:
    <<edit pages from file>>
  else:
    <<edit pages interactively>>
@

\subsection{File-based editing}

When [[-f]] is provided, we read from the file, validate, and update directly.
This mode is script-friendly and does not require user interaction.
<<edit pages from file>>=
<<read and validate page content from file>>
<<update pages with new content>>
@

We read the file using the content module's infrastructure, then validate the
attributes against the page schema. The body content may be Markdown (default)
or HTML (when [[--html]] is specified).
<<read and validate page content from file>>=
try:
  # body_content is Markdown or HTML depending on args.html
  attributes, body_content = canvaslms.cli.content.read_content_from_file(args.file)
except FileNotFoundError:
  logger.error(f"File not found: {args.file}")
  print(f"Error: File not found: {args.file}", file=sys.stderr)
  return
except Exception as e:
  logger.error(f"Error reading file: {e}")
  print(f"Error reading file: {e}", file=sys.stderr)
  return

errors = canvaslms.cli.content.validate_attributes(
    attributes, canvaslms.cli.content.PAGE_SCHEMA)
if errors:
  for error in errors:
    print(f"Validation error: {error}", file=sys.stderr)
  return
@

\subsection{Updating pages with new content}

We convert the content to HTML for Canvas (unless [[--html]] is specified, in
which case the content is already HTML) and build the update dictionary. The
Canvas API expects page updates with a [[wiki_page]] wrapper.

If the YAML front matter contains a [[url]] field, we use it to identify the
specific page to update. This enables a Git-based workflow where the page can
be reliably identified even if the title changes. If the URL is not found and
[[--create]] is specified, we create a new page instead.

If no [[url]] is in the YAML, we try title-based matching first (using the
[[title]] field from the front matter), then fall back to filter-based matching
using [[-p]] and [[-M]] options only if no title is specified.
<<update pages with new content>>=
if args.html:
  html_content = body_content  # Already HTML, no conversion needed
else:
  html_content = pypandoc.convert_text(body_content, 'html', format='md')

if 'url' in attributes and attributes['url']:
  <<update or create page by url>>
else:
  <<update pages by filter matching>>
@

\subsubsection{URL-based page identification}

When the YAML contains a [[url]] field, we look up the page directly by its URL
slug. This is more reliable than filter matching because it identifies exactly
one page even if multiple pages have similar titles.
<<update or create page by url>>=
page_url = attributes['url']
course_list = canvaslms.cli.courses.process_course_option(canvas, args)
if not course_list:
  print("Error: No courses found matching criteria", file=sys.stderr)
  return

course = course_list[0]
try:
  full_page = course.get_page(page_url)
  full_page.course = course
  <<update existing page>>
except Exception as e:
  if args.create:
    <<create new page>>
  else:
    print(f"Error: Page '{page_url}' not found. "
          f"Use --create to create a new page.", file=sys.stderr)
    return
@

When updating an existing page, we build the update dictionary and call the
Canvas API.
<<update existing page>>=
update_data = {
  'wiki_page': {
    'title': attributes.get('title', full_page.title),
    'body': html_content,
  }
}

<<add optional page attributes to update>>

try:
  full_page.edit(**update_data)
  <<update page cache after edit>>
  logger.info(f"Updated page: {full_page.title}")
  <<update page module membership>>
except Exception as e:
  logger.error(f"Error updating page '{full_page.title}': {e}")
  print(f"Error updating page '{full_page.title}': {e}", file=sys.stderr)
@

\subsubsection{Updating the cache after editing}

After successfully editing a page, we must update the cache entry to prevent
unnecessary re-fetches.
The Canvas API's [[edit()]] method updates the object in-place, but the
[[_fetched_at]] timestamp (used for staleness checks) isn't automatically set.
Without this update, pages originally fetched via bulk [[get_pages()]]
(which lack the [[body]] attribute) would be re-fetched on every subsequent
operation, even though they now have complete data from the edit response.
<<update page cache after edit>>=
full_page._fetched_at = datetime.now()
if hasattr(full_page.course, 'page_cache'):
  full_page.course.page_cache[full_page.url] = (full_page, {})
@

\subsubsection{Creating new pages}

When [[--create]] is specified and the page doesn't exist, we create a new one.
<<create new page>>=
create_params = {
  'title': attributes.get('title', 'Untitled Page'),
  'body': html_content,
}
if 'published' in attributes:
  create_params['published'] = attributes['published']
if 'front_page' in attributes:
  create_params['front_page'] = attributes['front_page']
if 'editing_roles' in attributes and attributes['editing_roles']:
  create_params['editing_roles'] = attributes['editing_roles']

try:
  new_page = course.create_page(wiki_page=create_params)
  new_page.course = course
  print(f"Created page: {new_page.title} (url: {new_page.url})", file=sys.stderr)
  <<update new page module membership>>
except Exception as e:
  logger.error(f"Error creating page: {e}")
  print(f"Error creating page: {e}", file=sys.stderr)
@

For newly created pages, we also process module membership if specified.
<<update new page module membership>>=
if 'modules' in attributes:
  module_regexes = attributes['modules']
  added, removed = canvaslms.cli.modules.update_item_modules(
      new_page.course, 'Page', new_page.url, module_regexes)
  if added:
    print(f"  Added to modules: {', '.join(added)}", file=sys.stderr)
@

\subsubsection{Title-based page identification}

When no [[url]] is specified in the YAML but a [[title]] is present, we use the
title to find the page. This is the most common case when creating or updating
pages from Markdown files: the user specifies a title in the front matter and
expects the command to find or create a page with that title.

This behavior is critical for safety. Without it, the command would fall back to
filter-based matching with the default [[-p '.*']] pattern, which matches
\emph{all} pages in the course. The result would be catastrophic: every page
would be overwritten with the content from the file.

We use exact title matching (not regex) to avoid accidentally updating multiple
pages. If exactly one page matches, we update it. If no pages match and
[[--create]] is specified, we create a new page. If multiple pages match, we
report an error---the user should add a [[url]] field to disambiguate.
<<update or create page by title>>=
title = attributes['title']
course_list = canvaslms.cli.courses.process_course_option(canvas, args)
if not course_list:
  print("Error: No courses found matching criteria", file=sys.stderr)
  return

course = course_list[0]

matching_pages = [p for p in course.get_pages() if p.title == title]

if len(matching_pages) == 1:
  full_page = course.get_page(matching_pages[0].url)
  full_page.course = course
  <<update existing page>>
elif len(matching_pages) == 0:
  if args.create:
    <<create new page>>
  else:
    print(f"Error: Page '{title}' not found. "
          f"Use --create to create a new page.", file=sys.stderr)
    return
else:
  print(f"Error: Multiple pages with title '{title}' found. "
        f"Add 'url' field to YAML to identify specific page.", file=sys.stderr)
  return
@

\subsubsection{Filter-based page matching}

When neither [[url]] nor [[title]] is specified in the YAML, we fall back to the
filter options ([[-p]], [[-M]]) to find matching pages. This is a rare case but
maintains backwards compatibility. We add a safety check: if multiple pages
match, we report an error rather than updating all of them.
<<update pages by filter matching>>=
if 'title' in attributes and attributes['title']:
  <<update or create page by title>>
else:
  pages = process_page_option(canvas, args)
  if len(pages) > 1:
    print(f"Error: {len(pages)} pages match filter. "
          f"Add 'title' or 'url' to YAML, or use -p to narrow selection.",
          file=sys.stderr)
    return
  for page in pages:
    full_page = page.course.get_page(page.url)
    full_page.course = page.course
    <<update existing page>>
@

We add optional attributes only if they are present in the YAML front matter.
<<add optional page attributes to update>>=
if 'published' in attributes:
  update_data['wiki_page']['published'] = attributes['published']
if 'front_page' in attributes:
  update_data['wiki_page']['front_page'] = attributes['front_page']
if 'editing_roles' in attributes and attributes['editing_roles']:
  update_data['wiki_page']['editing_roles'] = attributes['editing_roles']
@

\subsection{Processing module membership}

After updating the page content, we process the [[modules]] attribute if it's
present in the front matter. This attribute controls which modules contain the
page:
\begin{description}
\item[Absent] Module membership is not modified
\item[Empty list] Page is removed from all modules
\item[List of regexes] Page is placed in exactly those modules matching
  the patterns---added to matching modules, removed from non-matching ones
\end{description}

We use the [[update_item_modules]] utility from the modules module, which
handles both adding to matching modules and removing from non-matching ones.
<<update page module membership>>=
if 'modules' in attributes:
  module_regexes = attributes['modules']
  added, removed = canvaslms.cli.modules.update_item_modules(
      full_page.course, 'Page', full_page.url, module_regexes)
  if added:
    print(f"  Added to modules: {', '.join(added)}", file=sys.stderr)
  if removed:
    print(f"  Removed from modules: {', '.join(removed)}", file=sys.stderr)
@

In the interactive editing context, the attributes are stored in [[final_attrs]]
rather than [[attributes]], so we provide a separate chunk for that scope.
<<update page module membership interactively>>=
if 'modules' in final_attrs:
  module_regexes = final_attrs['modules']
  added, removed = canvaslms.cli.modules.update_item_modules(
      full_page.course, 'Page', full_page.url, module_regexes)
  if added:
    print(f"  Added to modules: {', '.join(added)}", file=sys.stderr)
  if removed:
    print(f"  Removed from modules: {', '.join(removed)}", file=sys.stderr)
@

\subsection{Interactive editing}

When no [[-f]] is given, we enter interactive mode. This involves:
\begin{enumerate}
\item Fetching all matching pages
\item Showing a confirmation dialog listing what will be edited
\item For each page: open editor, preview, accept/edit/discard
\item Reporting results at the end
\end{enumerate}

This workflow allows batch editing with human review---users can match multiple
pages with a regex and then review each one before committing changes.
<<edit pages interactively>>=
<<get pages for interactive editing>>
<<confirm pages to edit>>
<<edit each page interactively>>
<<report interactive page edit results>>
@

First we fetch the matching pages. We use [[process_page_option]] which handles
the course and page filtering.
<<get pages for interactive editing>>=
try:
  page_list = process_page_option(canvas, args)
except canvaslms.cli.EmptyListError as e:
  print(f"Error: {e}", file=sys.stderr)
  return
@

Before starting the edit loop, we show the user what will be edited and ask for
confirmation. This prevents accidentally editing many pages when the pattern
matches more than expected.
<<confirm pages to edit>>=
print(f"Will edit {len(page_list)} page(s):", file=sys.stderr)
for page in page_list:
  course_code = page.course.course_code if hasattr(page, 'course') else "?"
  print(f"  - {course_code}: {page.title}", file=sys.stderr)

try:
  confirm = input("Continue? [y/N] ").strip().lower()
except (EOFError, KeyboardInterrupt):
  print("\nCancelled.", file=sys.stderr)
  return

if confirm not in ['y', 'yes']:
  print("Cancelled.", file=sys.stderr)
  return
@

Now we edit each page one by one. For each page, we need to fetch the full page
content (the list only has basic info), then:
\begin{enumerate}
\item Render current content to Markdown with YAML front matter
\item Open the editor with this content pre-populated
\item Show preview and enter accept/edit/discard loop
\item On accept, update the page in Canvas
\end{enumerate}
<<edit each page interactively>>=
updated_count = 0
skipped_count = 0

for page in page_list:
  # Fetch full page content (list only has basic info)
  full_page = page.course.get_page(page.url)
  full_page.course = page.course

  course_code = page.course.course_code if hasattr(page, 'course') else "?"
  print(f"\nEditing: {course_code}: {full_page.title}", file=sys.stderr)

  <<render current page content>>
  <<open editor with page content>>
  <<interactive confirm and update single page>>
@

We extract the current page attributes using the content module's schema.
We also fetch the current module membership so it can be edited.
<<render current page content>>=
current_attrs = canvaslms.cli.content.extract_attributes_from_object(
    full_page, canvaslms.cli.content.PAGE_SCHEMA)
page_modules = canvaslms.cli.modules.get_item_modules(
    full_page.course, 'Page', full_page.url)
@

We open the user's editor with the current content. By specifying
[[content_attr='body']], the editor function automatically extracts the body
from the attributes, converts HTML to Markdown, and excludes it from the YAML
front matter. We include the [[modules]] attribute so users can edit module
membership.

When [[--html]] is specified, we pass [[html_mode=True]] to skip the
HTML-to-Markdown conversion and use a \verb|.html| file suffix. This preserves
embedded elements that would be lost during Markdown round-tripping.
<<open editor with page content>>=
result = canvaslms.cli.content.get_content_from_editor(
    canvaslms.cli.content.PAGE_SCHEMA,
    current_attrs,
    content_attr='body',
    extra_attributes={'modules': page_modules},
    html_mode=args.html)
if result is None:
  print("Editor cancelled. Skipping this page.", file=sys.stderr)
  skipped_count += 1
  continue

# body_content is Markdown or HTML depending on args.html
attributes, body_content = result
@

After editing, we enter the interactive confirm loop. The user can preview the
content, accept it (which triggers the update), edit further, or discard changes.
<<interactive confirm and update single page>>=
title = attributes.get('title', full_page.title)
result = canvaslms.cli.content.interactive_confirm_and_edit(
    title, body_content, attributes,
    canvaslms.cli.content.PAGE_SCHEMA, "Page",
    content_attr='body')

if result is None:
  print("Discarded changes for this page.", file=sys.stderr)
  skipped_count += 1
  continue

final_attrs, final_content = result
<<update single page from interactive edit>>
@

When the user accepts, we convert the Markdown to HTML (unless [[--html]] is
specified, in which case the content is already HTML) and update the page.
<<update single page from interactive edit>>=
if args.html:
  html_content = final_content  # Already HTML, no conversion needed
else:
  try:
    html_content = pypandoc.convert_text(final_content, 'html', format='md')
  except Exception as e:
    logger.warning(f"Failed to convert markdown to HTML: {e}")
    html_content = final_content

update_data = {
  'wiki_page': {
    'title': final_attrs.get('title', full_page.title),
    'body': html_content,
  }
}

# Add optional attributes
if 'published' in final_attrs:
  update_data['wiki_page']['published'] = final_attrs['published']
if 'front_page' in final_attrs:
  update_data['wiki_page']['front_page'] = final_attrs['front_page']
if 'editing_roles' in final_attrs and final_attrs['editing_roles']:
  update_data['wiki_page']['editing_roles'] = final_attrs['editing_roles']

try:
  full_page.edit(**update_data)
  <<update page cache after edit>>
  logger.info(f"Updated page: {full_page.title}")
  <<update page module membership interactively>>
  updated_count += 1
except Exception as e:
  logger.error(f"Error updating page '{full_page.title}': {e}")
  print(f"Error updating page '{full_page.title}': {e}", file=sys.stderr)
  skipped_count += 1
@

Finally, we report a summary of what was done.
<<report interactive page edit results>>=
print(f"\nDone. Updated {updated_count}/{len(page_list)} page(s).", file=sys.stderr)
if skipped_count > 0:
  print(f"Skipped {skipped_count} page(s).", file=sys.stderr)
@
