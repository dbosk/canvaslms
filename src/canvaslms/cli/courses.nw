\chapter{The \texttt{courses} subcommand}

This chapter provides everything related to courses.
Firstly, it provides the [[courses]] subcommand.
Secondly, it provides some useful functions for working with courses that can
be used by other subcommands.

We outline the module:
<<[[courses.py]]>>=
import argparse
import arrow
import canvaslms.cli
import canvaslms.hacks.canvasapi
import csv
import datetime
import re
import sys

<<functions>>

def add_command(subp):
  """Adds the subcomand and its options to argparse subparser subp"""
  courses_parser = subp.add_parser("courses",
    help="Lists your courses",
    description="Lists your courses. Output, CSV-format: "
      "<<columns in CSV output>>")
  courses_parser.set_defaults(func=courses_command)
  <<add arguments>>
@

\section{Testing course filtering and selection}
\label{sec:courses:testing}

Course filtering is fundamental to the entire [[canvaslms]] tool---almost every command starts by selecting courses.
Tests are distributed throughout this chapter, appearing immediately after each implementation to verify correctness.

\subsection{Testing philosophy}

The [[add_course_option()]] and [[process_course_option()]] functions follow a critical pattern used throughout this codebase:
\begin{description}
\item[ [[add_XXX_option]] ] Adds command-line arguments to argparse parser
\item[ [[process_XXX_option]] ] Processes those arguments and returns filtered results
\end{description}

This pattern appears in [[courses]], [[assignments]], [[users]], [[submissions]], and more.
By testing it thoroughly here, we establish confidence in the entire codebase.

\subsection{Test structure}

We define the test file structure early, but the actual test implementations appear after their corresponding functionality:

<<test [[courses.py]]>>=
"""
Tests for canvaslms.cli.courses filtering and selection functions.

These tests verify the core course filtering logic used throughout
the canvaslms tool. The add_course_option/process_course_option
pattern is fundamental to many commands.
"""
import pytest
import re
from unittest.mock import MagicMock

from canvaslms.cli import EmptyListError
from canvaslms.cli.courses import (
    filter_courses,
    process_course_option
)

<<test functions>>
@

The [[courses]] subcommand takes one positional argument, that is a regular
expression for filtering the courses.
<<add arguments>>=
courses_parser.add_argument("regex",
  default=".*", nargs="?",
  help="Regex for filtering courses, default: '.*'")
@

We also take an option [[--all]] to show all courses.
By default we just want to show the courses that haven't ended.
<<add arguments>>=
courses_parser.add_argument("-a", "--all",
  action="store_true", default=False,
  help="List all courses, by default list only current courses.")
@


\section{Producing a list of courses, [[courses_command]]}%
\label{list-courses-function}

We provide the function~[[courses_command]] which will be called by the main 
argument parser.
<<functions>>=
def courses_command(config, canvas, args):
  """Prints the users list of courses in CSV format to stdout"""
  output = csv.writer(sys.stdout, delimiter=args.delimiter)

  course_list = filter_courses(canvas, args.regex)

  <<filter out current courses>>

  <<check for empty course list>>

  for course in course_list:
    <<write course data to output>>
@ We will cover the set up and processing of the options in the following 
sections.


\section{Filter the list of courses}

We want to filter the courses depending on the [[--all]] argument.
<<filter out current courses>>=
if not args.all:
  is_current_course = lambda x: \
      x.start_at is None \
      or (x.end_at is None and \
        arrow.get(x.start_at)-arrow.now().shift(years=-1) \
          > datetime.timedelta(0)) \
      or x.end_at is not None and arrow.get(x.end_at) > arrow.now()
  course_list = filter(is_current_course, course_list)
@

Now we need to check if the course list is empty and warn the user.
<<check for empty course list>>=
# Convert to list and check if empty
course_list = list(course_list)
if not course_list:
  raise canvaslms.cli.EmptyListError("No courses found matching the criteria.")
@

\section{Output the course data}

We have the course data in a [[course]] object.
Now we just print the interesting data about it.
<<columns in CSV output>>=
<canvas ID>* <SIS course ID>* <course-code> <course-name> \
  <start-time> <end-time>
<<write course data to output>>=
row = []
if args.id:
  row.append(course.id)
if args.ladok:
  row.append(course.sis_course_id)
row.extend([
  course.course_code,
  course.name,
  course.start_at,
  course.end_at
])
output.writerow(row)
@


\section{Find course based on course code}%
\label{search-course-code}
\label{filter-courses}

We provide the function~[[filter_courses]] that will filter the list of courses
based on a regular expression~[[regex]].
<<functions>>=
def filter_courses(canvas, regex):
  courses = canvas.get_courses()
  p = re.compile(regex)
  for course in courses:
    <<yield course matching regex>>
@

We will match a course if the [[regex]] (compiled into [[p]]) will match any of
the attributes [[course_code]] or [[name]] of a course.
<<yield course matching regex>>=
if p.search(course.name):
  yield course
elif p.search(course.course_code):
  yield course
elif p.search(str(course.id)):
  yield course
@

We add the option [[--id]] to show the Canvas ID of the course.
<<add arguments>>=
courses_parser.add_argument("-i", "--id",
  action="store_true", default=False,
  help="Include Canvas ID of the course as first column.")
@ We also want to add [[--ladok]] or [[-l]] to show the integration ID for
LADOK.
<<add arguments>>=
courses_parser.add_argument("-l", "--ladok",
  action="store_true", default=False,
  help="Include LADOK ID (integration ID) of the course as "
       "first (or second, with -i) column.")
@

\subsection{Verifying course filtering}

Now let's verify this filtering logic works correctly across various scenarios.
The [[filter_courses()]] function is a generator that yields courses matching a regex pattern, searching three attributes: [[name]], [[course_code]], and [[id]].

We apply variation theory to these tests:
\begin{description}
\item[Invariant] The regex matching logic across all three attributes
\item[Variant] Input patterns (names, codes, IDs), number of matches, regex complexity
\end{description}

<<test functions>>=
class TestFilterCourses:
    """Test filter_courses() with various regex patterns"""

    def test_matches_course_name(self, mock_canvas, mock_courses):
        """Should match courses by name"""
        mock_canvas.get_courses.return_value = mock_courses

        # Regex that matches "Programming" in course name
        result = list(filter_courses(mock_canvas, "Programming"))

        assert len(result) == 1
        assert result[0].name == "Introduction to Programming"

    def test_matches_course_code(self, mock_canvas, mock_courses):
        """Should match courses by course code"""
        mock_canvas.get_courses.return_value = mock_courses

        # Regex that matches "CS101" in course code
        result = list(filter_courses(mock_canvas, "CS101"))

        assert len(result) == 1
        assert result[0].course_code == "CS101"

    def test_matches_course_id(self, mock_canvas, mock_courses):
        """Should match courses by Canvas ID"""
        mock_canvas.get_courses.return_value = mock_courses

        # Regex that matches ID 1002
        result = list(filter_courses(mock_canvas, "1002"))

        assert len(result) == 1
        assert result[0].id == 1002

    def test_matches_multiple_courses(self, mock_canvas, mock_courses):
        """Should return multiple matches when regex matches multiple courses"""
        mock_canvas.get_courses.return_value = mock_courses

        # Regex that matches "CS" in course codes
        result = list(filter_courses(mock_canvas, "CS"))

        # Should match CS101, CS201, CS102
        assert len(result) == 3

    def test_match_all_pattern(self, mock_canvas, mock_courses):
        """Regex '.*' should match all courses"""
        mock_canvas.get_courses.return_value = mock_courses

        result = list(filter_courses(mock_canvas, ".*"))

        assert len(result) == 3

    def test_no_matches_empty_list(self, mock_canvas, mock_courses):
        """Should return empty list when no courses match"""
        mock_canvas.get_courses.return_value = mock_courses

        result = list(filter_courses(mock_canvas, "NoMatchingCourse"))

        assert len(result) == 0

    def test_case_sensitive_matching(self, mock_canvas, mock_courses):
        """Regex matching is case-sensitive by default"""
        mock_canvas.get_courses.return_value = mock_courses

        # Lowercase "programming" should not match "Programming"
        result = list(filter_courses(mock_canvas, "programming"))

        assert len(result) == 0

        # Uppercase should match
        result = list(filter_courses(mock_canvas, "Programming"))
        assert len(result) == 1

    def test_special_regex_characters(self, mock_canvas):
        """Should handle special regex characters properly"""
        # Create course with special characters in name
        course = MagicMock()
        course.id = 9999
        course.name = "C++ Programming (Advanced)"
        course.course_code = "CS301"
        mock_canvas.get_courses.return_value = [course]

        # Parentheses need escaping in regex
        result = list(filter_courses(mock_canvas, r"C\+\+"))

        assert len(result) == 1
        assert result[0].name == "C++ Programming (Advanced)"
@

These tests demonstrate the flexibility of regex matching: users can search by name, code, or ID, and the function handles all three uniformly.
This is powerful---users don't need to remember which field they're searching.


\section{Selecting a course on the command line}

We provide one way to identify a course: by matching the course code, course
name or Canvas ID against a regular expression.

We provide a function that can be used by other subcommands to set up options
for selecting a course in this way.
If the [[required]] option is specified, we want the course option to be
required (\eg for the [[grade]] command).
<<functions>>=
def add_course_option(parser, required=False, suppress_help=False):
  """Adds the -c option to argparse parser to filter out courses

  Args:
    parser: The argparse parser to add options to
    required: Whether the course option should be required
    suppress_help: If True, hide this option from help output (default: False)
  """
  <<set up options for selecting courses>>

def process_course_option(canvas, args):
  """Processes -c option, returns a list of courses"""
  <<process options for selecting courses>>
  course_list = list(course_list)
  if not course_list:
    raise canvaslms.cli.EmptyListError("No courses found matching the criteria.")
  return course_list
@

We need a course, so we require a regular expression that matches the course
title, course code or Canvas identifier.
<<set up options for selecting courses>>=
parser.add_argument("-c", "--course", required=required, default=".*",
  help=argparse.SUPPRESS if suppress_help else
    "Regex matching courses on title, course code or Canvas ID, "
    "default: '.*'")
@

When we check for either of these arguments, we set up a list of courses,
[[course_list]], that will be returned.
<<process options for selecting courses>>=
course_list = filter_courses(canvas, args.course)
@ We use the [[filter_courses]] from \cref{filter-courses}.

\subsection{Verifying [[process_course_option]]}

The [[process_course_option()]] function wraps [[filter_courses()]] and adds critical error handling: it raises [[EmptyListError]] when no courses match.
This is essential behavior---many commands depend on having at least one course selected.

Let's verify this error handling works correctly:

<<test functions>>=
class TestProcessCourseOption:
    """Test process_course_option() error handling and integration"""

    def test_returns_matching_courses(self, mock_canvas, mock_courses):
        """Should return list of matching courses"""
        mock_canvas.get_courses.return_value = mock_courses

        args = MagicMock()
        args.course = "CS"

        result = process_course_option(mock_canvas, args)

        assert len(result) == 3
        assert all(course.course_code.startswith("CS") for course in result)

    def test_raises_empty_list_error_no_matches(self, mock_canvas, mock_courses):
        """Should raise EmptyListError when no courses match"""
        mock_canvas.get_courses.return_value = mock_courses

        args = MagicMock()
        args.course = "NoSuchCourse"

        with pytest.raises(EmptyListError, match="No courses found"):
            process_course_option(mock_canvas, args)

    def test_default_regex_matches_all(self, mock_canvas, mock_courses):
        """Default regex '.*' should match all courses"""
        mock_canvas.get_courses.return_value = mock_courses

        args = MagicMock()
        args.course = ".*"

        result = process_course_option(mock_canvas, args)

        assert len(result) == 3

    def test_single_course_match(self, mock_canvas, mock_courses):
        """Should handle single course match correctly"""
        mock_canvas.get_courses.return_value = mock_courses

        args = MagicMock()
        args.course = "^Introduction"  # Anchor to match only one

        result = process_course_option(mock_canvas, args)

        assert len(result) == 1
        assert result[0].name == "Introduction to Programming"

    def test_empty_canvas_courses_raises_error(self, mock_canvas):
        """Should raise EmptyListError when Canvas returns no courses"""
        mock_canvas.get_courses.return_value = []

        args = MagicMock()
        args.course = ".*"

        with pytest.raises(EmptyListError):
            process_course_option(mock_canvas, args)
@

These tests validate that the [[add_XXX_option]]/[[process_XXX_option]] pattern works reliably:
\begin{enumerate}
\item \textbf{Reliable command execution:} Commands won't fail mysteriously when courses don't match
\item \textbf{Clear error messages:} Users get [[EmptyListError]] with helpful message, not generic exceptions
\item \textbf{Flexible matching:} Users can search by any identifying attribute
\end{enumerate}

Since this pattern is reused for assignments, users, submissions, and more, confidence in these tests extends across the entire codebase.

