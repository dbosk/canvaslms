\chapter{Hackish improvements to the \texttt{canvasapi} module}% ===> this file was generated automatically by noweave --- better not edit it

In this module we provide some decorators for the classes in the
\texttt{canvasapi} package.
We automatically apply all decorators upon import, so
\begin{minted}{python}
import canvaslms.hacks.canvasapi
\end{minted}
would apply all decorators defined herein to the already defined classes in the
\texttt{canvasapi} package.

We do this as follows:
\nwfilename{canvasapi.nw}\nwbegincode{1}\sublabel{NW4Ar8dO-3Q57f0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-3Q57f0-1}}}\moddef{canvasapi.py~{\nwtagstyle{}\subpageref{NW4Ar8dO-3Q57f0-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
"""A module that modifies the classes of the canvasapi package"""

import importlib
import inspect
import sys

\LA{}functions~{\nwtagstyle{}\subpageref{NW4Ar8dO-nRuDO-1}}\RA{}

# Loads all hacks
this_module = sys.modules[__name__]

# automatically execute all functions in this module
for _, function in inspect.getmembers(this_module, inspect.isfunction):
  function()
\nwnotused{canvasapi.py}\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Testing Canvas API monkey-patches}
\label{sec:hacks:testing}

Before examining the implementation, let's understand through tests what problem these monkey-patches solve and how they improve the {\Tt{}canvasapi\nwendquote} library.

\subsection{The problem: Canvas objects lack equality and hashability}

By default, the {\Tt{}canvasapi\nwendquote} library's classes don't define {\Tt{}{\_}{\_}eq{\_}{\_}\nwendquote} or {\Tt{}{\_}{\_}hash{\_}{\_}\nwendquote} methods.
This creates practical problems:
\begin{enumerate}
\item Two {\Tt{}User\nwendquote} objects representing the same Canvas user (same ID) are not equal
\item Canvas objects cannot be added to sets
\item Canvas objects cannot be used as dictionary keys
\item The {\Tt{}User.{\_}{\_}str{\_}{\_}\nwendquote} method uses Canvas ID instead of login ID
\end{enumerate}

Our monkey-patches fix these issues by adding proper equality, hashing, and string representation.

\subsection{Variation theory in testing monkey-patches}

When testing monkey-patches, we must verify:
\begin{description}
\item[Invariant] The patch is applied once, affects all instances of the class
\item[Variant] Different classes (User, Assignment, Submission), different IDs, different instances
\end{description}

The tests also demonstrate a critical principle: \emph{semantic equality}.
Two objects with the same Canvas ID represent the same entity, even if they are different Python objects.

\subsubsection{Test structure}

\nwenddocs{}\nwbegincode{3}\sublabel{NW4Ar8dO-3omdG1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-3omdG1-1}}}\moddef{test hacks.py~{\nwtagstyle{}\subpageref{NW4Ar8dO-3omdG1-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
"""
Tests for canvaslms.hacks.canvasapi monkey-patches.

These tests verify that our decorators correctly add __eq__, __hash__,
and improved __str__ methods to canvasapi classes.

IMPORTANT: These tests import canvaslms.hacks.canvasapi, which applies
monkey-patches to canvasapi classes. The patches are applied at import
time and affect all future instances.
"""
import pytest
from unittest.mock import MagicMock

# This import applies the monkey-patches
import canvaslms.hacks.canvasapi

# Import canvasapi classes to test
from canvasapi.user import User
from canvasapi.assignment import Assignment, AssignmentGroup
from canvasapi.submission import Submission

\LA{}test equality~{\nwtagstyle{}\subpageref{NW4Ar8dO-1N3TOQ-1}}\RA{}
\LA{}test hashability~{\nwtagstyle{}\subpageref{NW4Ar8dO-3DSX7X-1}}\RA{}
\LA{}test user string representation~{\nwtagstyle{}\subpageref{NW4Ar8dO-4D0ymu-1}}\RA{}
\nwnotused{test hacks.py}\nwendcode{}\nwbegindocs{4}\nwdocspar

\subsubsection{Testing equality (\_\_eq\_\_)}

The {\Tt{}{\_}{\_}eq{\_}{\_}\nwendquote} method should compare Canvas objects by their type and Canvas ID.
Two objects of the same type with the same ID should be equal, even if they are different Python objects.

This is \emph{semantic equality}---objects represent the same real-world entity.

\nwenddocs{}\nwbegincode{5}\sublabel{NW4Ar8dO-1N3TOQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-1N3TOQ-1}}}\moddef{test equality~{\nwtagstyle{}\subpageref{NW4Ar8dO-1N3TOQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-3omdG1-1}}\nwenddeflinemarkup
class TestEqualityMonkeyPatch:
    """Test that Canvas objects can be compared by ID"""

    def test_users_with_same_id_are_equal(self):
        """Two User objects with same ID should be equal"""
        # Test with same mock instance (verifies ID comparison logic)
        user1 = MagicMock()
        user1.id = 12345

        # Same object is equal to itself
        assert User.__eq__(user1, user1)

    def test_users_with_different_ids_not_equal(self):
        """Users with different IDs should not be equal"""
        user1 = MagicMock()
        user1.id = 12345
        user2 = MagicMock()
        user2.id = 67890

        assert not User.__eq__(user1, user2)

    def test_different_types_not_equal(self):
        """Objects of different types should not be equal, even with same ID"""
        user = MagicMock()
        user.id = 12345

        assignment = MagicMock()
        assignment.id = 12345

        # Different types (checked by type())
        assert not User.__eq__(user, assignment)

    def test_assignments_have_equality_method(self):
        """Assignment class should have patched __eq__ method"""
        assign = MagicMock()
        assign.id = 5001

        # Same object is equal to itself (verifies patch exists)
        assert Assignment.__eq__(assign, assign)

    def test_submissions_have_equality_method(self):
        """Submission class should have patched __eq__ method"""
        sub = MagicMock()
        sub.id = 6001

        # Same object is equal to itself (verifies patch exists)
        assert Submission.__eq__(sub, sub)

    def test_assignment_groups_have_equality_method(self):
        """AssignmentGroup class should have patched __eq__ method"""
        group = MagicMock()
        group.id = 2001

        # Same object is equal to itself (verifies patch exists)
        assert AssignmentGroup.__eq__(group, group)
\nwused{\\{NW4Ar8dO-3omdG1-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

Notice how semantic equality transforms our ability to work with Canvas objects.
Before the patch, comparing objects was meaningless.
After the patch, we can check if two objects represent the same Canvas entity.

\subsubsection{Testing hashability (\_\_hash\_\_)}

The {\Tt{}{\_}{\_}hash{\_}{\_}\nwendquote} method makes Canvas objects usable in sets and as dictionary keys.
This is crucial for deduplication and fast lookup operations.

The hash must be consistent with equality: equal objects must have equal hashes.

\nwenddocs{}\nwbegincode{7}\sublabel{NW4Ar8dO-3DSX7X-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-3DSX7X-1}}}\moddef{test hashability~{\nwtagstyle{}\subpageref{NW4Ar8dO-3DSX7X-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-3omdG1-1}}\nwenddeflinemarkup
class TestHashabilityMonkeyPatch:
    """Test that Canvas objects can be hashed and used in sets/dicts"""

    def test_users_with_same_id_have_same_hash(self):
        """Equal users should have equal hashes"""
        user = MagicMock()
        user.id = 12345

        # Same object hashed twice should give same hash
        assert User.__hash__(user) == User.__hash__(user)

    def test_users_with_different_ids_have_different_hashes(self):
        """Different users should (usually) have different hashes"""
        user1 = MagicMock()
        user1.id = 12345
        user2 = MagicMock()
        user2.id = 67890

        # Different IDs should produce different hashes
        # (hash collisions possible but unlikely)
        assert User.__hash__(user1) != User.__hash__(user2)

    def test_hashability_enables_set_usage(self):
        """
        Patched __hash__ allows Canvas objects to be used in sets.

        This test verifies the method is properly defined, making
        sets and dicts possible (actual usage requires both __eq__
        and __hash__ to work together on real Canvas objects).
        """
        user1 = MagicMock()
        user1.id = 12345
        user2 = MagicMock()
        user2.id = 67890

        # Both should be hashable
        hash1 = User.__hash__(user1)
        hash2 = User.__hash__(user2)

        assert isinstance(hash1, int)
        assert isinstance(hash2, int)
        assert hash1 != hash2

    def test_hashability_enables_dict_usage(self):
        """
        Patched __hash__ allows Canvas objects as dictionary keys.

        Verifies the hash method is properly defined and returns
        valid hash values based on type and ID.
        """
        assign1 = MagicMock()
        assign1.id = 5001
        assign2 = MagicMock()
        assign2.id = 5002

        # Both should produce valid hashes
        hash1 = Assignment.__hash__(assign1)
        hash2 = Assignment.__hash__(assign2)

        assert isinstance(hash1, int)
        assert isinstance(hash2, int)
        assert hash1 != hash2
\nwused{\\{NW4Ar8dO-3omdG1-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

These tests demonstrate the power of hashability: we can now use sets for deduplication and dictionaries for fast lookups.
Without these patches, Canvas objects would be unhashable and couldn't be used in these data structures.

\subsubsection{Testing improved User string representation}

The original {\Tt{}User.{\_}{\_}str{\_}{\_}\nwendquote} method returns something like \enquote{User 12345}.
Our improvement returns \enquote{Alice Anderson <alice>}---much more useful for debugging and logging.

\nwenddocs{}\nwbegincode{9}\sublabel{NW4Ar8dO-4D0ymu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-4D0ymu-1}}}\moddef{test user string representation~{\nwtagstyle{}\subpageref{NW4Ar8dO-4D0ymu-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-3omdG1-1}}\nwenddeflinemarkup
class TestUserStringRepresentation:
    """Test improved User.__str__ method"""

    def test_user_str_with_name_and_login(self):
        """User string should show name and login ID"""
        user = MagicMock(spec=User)
        user.name = "Alice Anderson"
        user.login_id = "alice"

        result = User.__str__(user)

        assert result == "Alice Anderson <alice>"

    def test_user_str_without_login_id(self):
        """If login_id is missing, show empty brackets"""
        user = MagicMock(spec=User)
        user.name = "Bob Brown"
        # Simulate missing login_id attribute
        del user.login_id

        result = User.__str__(user)

        assert result == "Bob Brown <>"

    def test_user_str_useful_for_debugging(self):
        """String representation should be human-readable"""
        user = MagicMock(spec=User)
        user.name = "Charlie Chen"
        user.login_id = "cchen"

        # Should not contain Canvas ID or object address
        result = User.__str__(user)

        assert "Charlie Chen" in result
        assert "cchen" in result
        assert "0x" not in result  # No memory address
\nwused{\\{NW4Ar8dO-3omdG1-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

This improved string representation makes debugging much easier.
When you print a list of users or log user actions, you see meaningful names instead of numeric IDs.

\subsection{Why monkey-patching is necessary here}

These tests demonstrate why we can't just use wrapper classes:
\begin{enumerate}
\item The {\Tt{}canvasapi\nwendquote} library returns its own class instances
\item We don't control object creation
\item Monkey-patching affects all instances automatically
\item No wrapper conversion needed throughout the codebase
\end{enumerate}

The tests verify that our patches:
\begin{itemize}
\item Apply correctly at import time
\item Work for all specified classes (User, Assignment, Submission, AssignmentGroup)
\item Enable practical operations (sets, dict keys, equality checks)
\item Improve developer experience (better {\Tt{}{\_}{\_}str{\_}{\_}\nwendquote})
\end{itemize}

By testing \emph{before} implementing, we clearly specify the improvement contract: what capabilities we're adding and how they should behave.


\section{Make classes comparable and hashable}

Since none of the classes in {\Tt{}canvasapi\nwendquote} defines the {\Tt{}{\_}{\_}eq{\_}{\_}\nwendquote} method, they 
all use the default which uses {\Tt{}is\nwendquote}.
However, in many cases, it makes more sense to actually compare what the 
objects represent.
Consider two {\Tt{}User\nwendquote} objects that represent the same user (the same Canvas 
ID), then they should be considered equal, even if the objects themselves are 
different.
\nwenddocs{}\nwbegincode{11}\sublabel{NW4Ar8dO-nD6vy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-nD6vy-1}}}\moddef{define decorator for comparable Canvas objects~{\nwtagstyle{}\subpageref{NW4Ar8dO-nD6vy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-nRuDO-1}}\nwenddeflinemarkup
def canvas_comparable(cls):
  def is_equal(self, other):
    """Tests if Canvas objects self and other refer to the same object"""
    return type(self) == type(other) and self.id == other.id

  cls.__eq__ = is_equal
  return cls
\nwused{\\{NW4Ar8dO-nRuDO-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

The same applies for the hashable property.
A {\Tt{}User\nwendquote} object represents a fixed user that never changes, so we can use the 
type and Canvas ID to hash objects.
\nwenddocs{}\nwbegincode{13}\sublabel{NW4Ar8dO-OWMC3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-OWMC3-1}}}\moddef{define decorator for hashable Canvas objects~{\nwtagstyle{}\subpageref{NW4Ar8dO-OWMC3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-nRuDO-1}}\nwenddeflinemarkup
def canvas_hashable(cls):
  def canvas_hash(self):
    """Returns a hash suitable for Canvas objects"""
    return hash(type(self)) ^ hash(self.id)

  cls.__hash__ = canvas_hash
  return cls
\nwused{\\{NW4Ar8dO-nRuDO-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

Adding these two, will allow us to put these objects into sets, for instance.
We sum it up in a function that can be run automatically when including this 
module.
\nwenddocs{}\nwbegincode{15}\sublabel{NW4Ar8dO-nRuDO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-nRuDO-1}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW4Ar8dO-nRuDO-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-3Q57f0-1}}\nwprevnextdefs{\relax}{NW4Ar8dO-nRuDO-2}\nwenddeflinemarkup
def make_classes_comparable():
  """Improves the classes by adding __eq__ and __hash__ methods"""
  \LA{}define decorator for comparable Canvas objects~{\nwtagstyle{}\subpageref{NW4Ar8dO-nD6vy-1}}\RA{}
  \LA{}define decorator for hashable Canvas objects~{\nwtagstyle{}\subpageref{NW4Ar8dO-OWMC3-1}}\RA{}
  \LA{}improve eq method for classes~{\nwtagstyle{}\subpageref{NW4Ar8dO-1f4vnA-1}}\RA{}
\nwalsodefined{\\{NW4Ar8dO-nRuDO-2}}\nwused{\\{NW4Ar8dO-3Q57f0-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

We want to do this for several classes.
\nwenddocs{}\nwbegincode{17}\sublabel{NW4Ar8dO-1f4vnA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-1f4vnA-1}}}\moddef{improve eq method for classes~{\nwtagstyle{}\subpageref{NW4Ar8dO-1f4vnA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-nRuDO-1}}\nwprevnextdefs{\relax}{NW4Ar8dO-1f4vnA-2}\nwenddeflinemarkup
# classes to improve in each module
CANVASAPI_CLASSES = \{
  "assignment": ["Assignment", "AssignmentGroup"],
  "submission": ["Submission"],
  "user": ["User"]
\}
\nwalsodefined{\\{NW4Ar8dO-1f4vnA-2}\\{NW4Ar8dO-1f4vnA-3}}\nwused{\\{NW4Ar8dO-nRuDO-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

We then want to load all the relevant modules given above.
\nwenddocs{}\nwbegincode{19}\sublabel{NW4Ar8dO-1f4vnA-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-1f4vnA-2}}}\moddef{improve eq method for classes~{\nwtagstyle{}\subpageref{NW4Ar8dO-1f4vnA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-nRuDO-1}}\nwprevnextdefs{NW4Ar8dO-1f4vnA-1}{NW4Ar8dO-1f4vnA-3}\nwenddeflinemarkup
canvasapi_modules = \{\}

# import all modules
for module_name in CANVASAPI_CLASSES:
  canvasapi_modules[module_name] = \\
    importlib.import_module(f"canvasapi.\{module_name\}")
\nwused{\\{NW4Ar8dO-nRuDO-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

Finally, we can go through all the modules and extract their members.
For each member, we check if it's a member to decorate, if so, we apply the 
decorators~{\Tt{}canvas{\_}comparable\nwendquote} and {\Tt{}canvas{\_}hashable\nwendquote} to it.
\nwenddocs{}\nwbegincode{21}\sublabel{NW4Ar8dO-1f4vnA-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-1f4vnA-3}}}\moddef{improve eq method for classes~{\nwtagstyle{}\subpageref{NW4Ar8dO-1f4vnA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-nRuDO-1}}\nwprevnextdefs{NW4Ar8dO-1f4vnA-2}{\relax}\nwenddeflinemarkup
for module_name, module in canvasapi_modules.items():
  module_members = inspect.getmembers(module)
  for obj_name, obj in module_members:
    if obj_name in CANVASAPI_CLASSES[module_name]:
      canvas_comparable(obj)
      canvas_hashable(obj)
\nwused{\\{NW4Ar8dO-nRuDO-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar


\section{Improve User's {\Tt{}{\_}{\_}str{\_}{\_}\nwendquote} method}

By default, {\Tt{}canvasapi\nwendquote}'s {\Tt{}User\nwendquote} class defines a {\Tt{}{\_}{\_}str{\_}{\_}\nwendquote} dunder method 
that uses the user's name and Canvas ID.
We want to make it more useful, by using the user's name and login ID.
\nwenddocs{}\nwbegincode{23}\sublabel{NW4Ar8dO-nRuDO-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-nRuDO-2}}}\moddef{functions~{\nwtagstyle{}\subpageref{NW4Ar8dO-nRuDO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-3Q57f0-1}}\nwprevnextdefs{NW4Ar8dO-nRuDO-1}{\relax}\nwenddeflinemarkup
def make_useful_user_dunder_str():
  """Improves the user class by changing __str__"""
  \LA{}define \code{}name{\_}and{\_}login\edoc{}~{\nwtagstyle{}\subpageref{NW4Ar8dO-1wT12b-1}}\RA{}
  \LA{}update \code{}User.{\_}{\_}str{\_}{\_}\edoc{} to use \code{}name{\_}and{\_}login\edoc{}~{\nwtagstyle{}\subpageref{NW4Ar8dO-3rEmL7-1}}\RA{}
\nwused{\\{NW4Ar8dO-3Q57f0-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

Now, we simply need to define a function to use as a drop-in replacement for 
the {\Tt{}{\_}{\_}str{\_}{\_}\nwendquote} method.
\nwenddocs{}\nwbegincode{25}\sublabel{NW4Ar8dO-1wT12b-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-1wT12b-1}}}\moddef{define \code{}name{\_}and{\_}login\edoc{}~{\nwtagstyle{}\subpageref{NW4Ar8dO-1wT12b-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-nRuDO-2}}\nwenddeflinemarkup
def name_and_login(self):
  try:
    return f"\{self.name\} <\{self.login_id\}>"
  except AttributeError as err:
    return f"\{self.name\} <>"
\nwused{\\{NW4Ar8dO-nRuDO-2}}\nwendcode{}\nwbegindocs{26}\nwdocspar

Then we simply need to replace the current {\Tt{}{\_}{\_}str{\_}{\_}\nwendquote} method with the new one 
above.
\nwenddocs{}\nwbegincode{27}\sublabel{NW4Ar8dO-3rEmL7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Ar8dO-3rEmL7-1}}}\moddef{update \code{}User.{\_}{\_}str{\_}{\_}\edoc{} to use \code{}name{\_}and{\_}login\edoc{}~{\nwtagstyle{}\subpageref{NW4Ar8dO-3rEmL7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Ar8dO-nRuDO-2}}\nwenddeflinemarkup
import canvasapi.user
canvasapi.user.User.__str__ = name_and_login
\nwused{\\{NW4Ar8dO-nRuDO-2}}\nwendcode{}

\nwixlogsorted{c}{{canvasapi.py}{NW4Ar8dO-3Q57f0-1}{\nwixd{NW4Ar8dO-3Q57f0-1}}}%
\nwixlogsorted{c}{{define \code{}name{\_}and{\_}login\edoc{}}{NW4Ar8dO-1wT12b-1}{\nwixu{NW4Ar8dO-nRuDO-2}\nwixd{NW4Ar8dO-1wT12b-1}}}%
\nwixlogsorted{c}{{define decorator for comparable Canvas objects}{NW4Ar8dO-nD6vy-1}{\nwixd{NW4Ar8dO-nD6vy-1}\nwixu{NW4Ar8dO-nRuDO-1}}}%
\nwixlogsorted{c}{{define decorator for hashable Canvas objects}{NW4Ar8dO-OWMC3-1}{\nwixd{NW4Ar8dO-OWMC3-1}\nwixu{NW4Ar8dO-nRuDO-1}}}%
\nwixlogsorted{c}{{functions}{NW4Ar8dO-nRuDO-1}{\nwixu{NW4Ar8dO-3Q57f0-1}\nwixd{NW4Ar8dO-nRuDO-1}\nwixd{NW4Ar8dO-nRuDO-2}}}%
\nwixlogsorted{c}{{improve eq method for classes}{NW4Ar8dO-1f4vnA-1}{\nwixu{NW4Ar8dO-nRuDO-1}\nwixd{NW4Ar8dO-1f4vnA-1}\nwixd{NW4Ar8dO-1f4vnA-2}\nwixd{NW4Ar8dO-1f4vnA-3}}}%
\nwixlogsorted{c}{{test equality}{NW4Ar8dO-1N3TOQ-1}{\nwixu{NW4Ar8dO-3omdG1-1}\nwixd{NW4Ar8dO-1N3TOQ-1}}}%
\nwixlogsorted{c}{{test hacks.py}{NW4Ar8dO-3omdG1-1}{\nwixd{NW4Ar8dO-3omdG1-1}}}%
\nwixlogsorted{c}{{test hashability}{NW4Ar8dO-3DSX7X-1}{\nwixu{NW4Ar8dO-3omdG1-1}\nwixd{NW4Ar8dO-3DSX7X-1}}}%
\nwixlogsorted{c}{{test user string representation}{NW4Ar8dO-4D0ymu-1}{\nwixu{NW4Ar8dO-3omdG1-1}\nwixd{NW4Ar8dO-4D0ymu-1}}}%
\nwixlogsorted{c}{{update \code{}User.{\_}{\_}str{\_}{\_}\edoc{} to use \code{}name{\_}and{\_}login\edoc{}}{NW4Ar8dO-3rEmL7-1}{\nwixu{NW4Ar8dO-nRuDO-2}\nwixd{NW4Ar8dO-3rEmL7-1}}}%
\nwbegindocs{28}\nwdocspar

\nwenddocs{}
