\chapter{Hackish improvements to the \texttt{canvasapi} module}

In this module we provide some decorators for the classes in the 
\texttt{canvasapi} package.
We automatically apply all decorators upon import, so
\begin{minted}{python}
import canvaslms.hacks.canvasapi
\end{minted}
would apply all decorators defined herein to the already defined classes in the 
\texttt{canvasapi} package.

We do this as follows:
<<canvasapi.py>>=
"""A module that modifies the classes of the canvasapi package"""

import cachetools
import canvasapi.assignment
from canvasapi.user import User
from datetime import datetime, timedelta
import functools
import importlib
import inspect
import sys

<<constants>>
<<functions>>

# Loads all hacks
this_module = sys.modules[__name__]

# automatically execute all functions in this module
for _, function in inspect.getmembers(this_module, inspect.isfunction):
  function()
@


\section{Make classes comparable and hashable}\label{ComparableObjects}

Since none of the classes in [[canvasapi]] defines the [[__eq__]] method, they 
all use the default which uses [[is]].
However, in many cases, it makes more sense to actually compare what the 
objects represent.
Consider two [[User]] objects that represent the same user (the same Canvas 
ID), then they should be considered equal, even if the objects themselves are 
different.
<<define decorator for comparable Canvas objects>>=
def canvas_comparable(cls):
  def is_equal(self, other):
    """Tests if Canvas objects self and other refer to the same object"""
    return type(self) == type(other) and self.id == other.id

  cls.__eq__ = is_equal
  return cls
@

The same applies for the hashable property.
A [[User]] object represents a fixed user that never changes, so we can use the 
type and Canvas ID to hash objects.
<<define decorator for hashable Canvas objects>>=
def canvas_hashable(cls):
  def canvas_hash(self):
    """Returns a hash suitable for Canvas objects"""
    return hash(type(self)) ^ hash(self.id)

  cls.__hash__ = canvas_hash
  return cls
@

Adding these two, will allow us to put these objects into sets, for instance.
We sum it up in a function that can be run automatically when including this 
module.
<<functions>>=
def make_classes_comparable():
  """Improves the classes by adding __eq__ and __hash__ methods"""
  <<define decorator for comparable Canvas objects>>
  <<define decorator for hashable Canvas objects>>
  <<improve eq method for classes>>
@

We want to do this for several classes.
<<improve eq method for classes>>=
# classes to improve in each module
CANVASAPI_CLASSES = {
  "assignment": ["Assignment", "AssignmentGroup"],
  "submission": ["Submission"],
  "user": ["User"]
}
@

We then want to load all the relevant modules given above.
<<improve eq method for classes>>=
canvasapi_modules = {}

# import all modules
for module_name in CANVASAPI_CLASSES:
  canvasapi_modules[module_name] = \
    importlib.import_module(f"canvasapi.{module_name}")
@

Finally, we can go through all the modules and extract their members.
For each member, we check if it's a member to decorate, if so, we apply the 
decorators~[[canvas_comparable]] and [[canvas_hashable]] to it.
<<improve eq method for classes>>=
for module_name, module in canvasapi_modules.items():
  module_members = inspect.getmembers(module)
  for obj_name, obj in module_members:
    if obj_name in CANVASAPI_CLASSES[module_name]:
      canvas_comparable(obj)
      canvas_hashable(obj)
@


\section{Improve User's [[__str__]] method}

By default, [[canvasapi]]'s [[User]] class defines a [[__str__]] dunder method 
that uses the user's name and Canvas ID.
We want to make it more useful, by using the user's name and login ID.
<<functions>>=
def make_useful_user_dunder_str():
  """Improves the user class by changing __str__"""
  <<define [[name_and_login]]>>
  <<update [[User.__str__]] to use [[name_and_login]]>>
@

Now, we simply need to define a function to use as a drop-in replacement for 
the [[__str__]] method.
<<define [[name_and_login]]>>=
def name_and_login(self):
  try:
    return f"{self.name} <{self.login_id}>"
  except AttributeError as err:
    return f"{self.name} <>"
@

Then we simply need to replace the current [[__str__]] method with the new one 
above.
<<update [[User.__str__]] to use [[name_and_login]]>>=
import canvasapi.user
canvasapi.user.User.__str__ = name_and_login
@


\section{Cacheable Canvas objects}

We would like certain methods in certain Canvas objects to be cached.
Particularly, methods that return objects that rarely change should be 
cacheable.
For instance, [[canvas.get_courses()]] returns a list of courses.
This list changes rarely\footnote{%
  This happens four times per year, when IT creates the new Canvas rooms 270 
  days ahead of course start.
  It also happens when someone adds you to manually to a course.
}, so its results can and should be cached.
The list of students changes usually only once in the beginning of the course.

Results on the other hand changes during a course.
However, once a student receives a pass, the result will (usually) not change 
again.
There are these cases however, where a student complements their submission to 
get a higher grade.
But once the student has the highest grade, an A or a P, the result will not 
change.

We will use the [[cachetools]] package to provide suitable caching decorators 
for the [[canvasapi]] classes' methods.
However, in some cases we can't, but need to write our own caching mechanisms.
But this means that we can construct quite complex cache policies.

The general design is this:
We add a cache attribute, then the methods store objects (return values) there.
The [[Canvas]] object stores [[Course]] objects.
Each [[Course]] object stores [[Assignment]] objects.
Each [[Assignment]] object stores [[Submission]] objects.
This means we can store and restore the entire hierarchy just by storing the 
[[Canvas]] object.
If we pickle the [[Canvas]] object, the caches of the [[Course]] objects will 
be in there, the [[Assignment]] caches will in turn be in them, and so on.

When we want to force an update of the courses, we don't want to clear the 
cache.
Then we lose the entire hierarchy.
We can update the list instead of clearing the entire cache hierarchy.
That way we can update objects and keep their caches.
But we'll need a way to know when to update.

\subsection{Syncing caches}

We usually have two methods to cache:
\begin{center}
[[get_x(id, /, **kwargs)]]
\quad
and
\quad
[[get_xs(**kwargs)]].
\end{center}
For example,
\begin{center}
[[get_submission(id, /, **kwargs)]]
\quad
and
\quad
[[get_submissions(**kwargs)]].
\end{center}
These should sync.
In Canvas we can also pass options through keyword arguments, a common one 
being [[include]] which specifies a list of things to include.
For instance, when it comes to submissions we can ask Canvas to include grading 
rubrics.
This means that we want to maintain these details, so that we don't lose 
information in the cache.

This means that we need two functions to support the caching:
\begin{description}
\item [[must_update(prev_kwargs, kwargs)]] takes the old keyword 
arguments ([[prev_kwargs]]) to check if they're a superset of the new keyword 
arguments ([[kwargs]]).
If not, the cache doesn't have all necessary information and we must fetch it.
\item [[merge_kwargs]] will take a list of keyword arguments dictionaries and 
merge them.
Most of the time these contain only the key [[include]] whose value is a list 
of things to include.
So essentially, we want to take the union of all these sets.
\end{description}
We can thus start with the following defaults:
<<kwargs functions caches>>=
def must_update(prev_kwargs, new_kwargs,
                ignore_keys=[
                  <<keys to ignore>>
                ]):
  """
  Returns True if we must update the cache (refetch).

  <<doc for keys to ignore>>
  """
  for key, value in new_kwargs.items():
    if key not in prev_kwargs:
      return True
    elif isinstance(value, list):
      if set(value) > set(prev_kwargs[key]):
        return True
    elif value != prev_kwargs[key]:
      return True

    return False

def merge_kwargs(kwargs_list,
                 ignore_keys=[
                   <<keys to ignore>>
                 ]):
  """
  Merges a list of keyword arguments dictionaries. Lists are unioned.
  All non-list keys (usually strings) must be the same in all dictionaries.

  <<doc for keys to ignore>>
  """
  new_kwargs = dict()

  for kwargs in kwargs_list:
    for key, value in kwargs.items():
      if key not in new_kwargs:
        new_kwargs[key] = value
      elif isinstance(kwargs[key], list):
        new_kwargs[key] = list(set(value) | set(new_kwargs[key]))
      else:
        <<if [[key]] can be ignored>>:
          new_kwargs[key] = value
        elif value != new_kwargs[key]:
          raise ValueError(f"Cannot merge {key} with "
                           f"{value} and {new_kwargs[key]}")

  return new_kwargs
@

We can now define the keys to ignore.
There are some keys that can be ignored for our purposes, like sorting order, 
as they don't affect the caching.
In those cases, we simply use the last value, as seen in the loop above.
<<doc for keys to ignore>>=
By default, we ignore the keys

  <<keys to ignore>>

as they don't affect the caching.
<<keys to ignore>>=
"sort",
"order",
"order_by"
@

\subsection{Wrapping the methods with a caching decorator}

Now, let's turn our attention to the caching decorator.
We want to cover both the singular and plural methods.
So this decorator should be applied to the class, for instance the 
[[Assignment]] class with the attribute [[submission]] to cache
[[get_submission]] and [[get_submissions]].
<<general class decorator for caching get methods>>=
class CacheGetMethods:
  """
  General class decorator to add caching to get_*{,s} methods.

  <<notes in [[CacheGetMethods]] doc>>
  """
  def __init__(self, attribute_name, cache=None, include_plural=True):
    """No parameters required"""
    self.__attribute_name = attribute_name
    self.__include_plural = include_plural
    self.__cache = cache if cache else {}

  def __call__(self, cls):
    """Applies the decorator to the class cls"""
    <<create decorator functions and update [[cls]]>>
    return cls
@ If we want to cache several attributes, then we can simply apply this decorator 
several times.
For instance, the [[Course]] class has both [[assignments]] and [[users]].

We need to update two methods in sync, the [[get_x]] and [[get_xs]] methods.
This is why we can't just use the decorators from [[cachetools]] or similar.
<<create decorator functions and update [[cls]]>>=
<<update constructor with new attributes>>

<<update the singular method>>

if self.__include_plural:
  <<update the plural method>>
@

We must update the constructor so that the object that is created keeps the 
cache.
To update the constructor, we simply wrap it in a new constructor that simply 
adds the desired attributes.

Note that the cache stored in the constructor must be named specifically to the 
attribute at hand.
Otherwise, when we cache several attributes, they will all use the same cache 
named [[cache]].
This will not work.
So they must be named [[submission_cache]], for example.
<<update constructor with new attributes>>=
init = cls.__init__
cache = self.__cache
attr_name = self.__attribute_name

@functools.wraps(init)
def new_init(*args, **kwargs):
  self = args[0]
  self.attr_name = attr_name
  <<construct [[attr_name]] cache attributes in [[self]]>>
  init(*args, **kwargs)

cls.__init__ = new_init
@

We do the same thing for the singular and plural get methods.
We get the original method, then wrap it in a new method that adds suitable 
caching or falls back to the original [[get_*]] function.
<<update the singular method>>=
singular_name = f"get_{self.__attribute_name}"
get_attr = getattr(cls, singular_name)

@functools.wraps(get_attr)
def new_get_attr(self, *args, **kwargs):
  <<return cached result or fetch from [[get_attr]]>>

setattr(cls, singular_name, new_get_attr)
<<update the plural method>>=
plural_name = f"get_{self.__attribute_name}s"
get_attrs = getattr(cls, plural_name)

@functools.wraps(get_attrs)
def new_get_attrs(self, *args, **kwargs):
  <<return cached result or fetch from [[get_attrs]]>>

setattr(cls, plural_name, new_get_attrs)
@

\subsection{Caching the get methods}

The idea of the caching is as follows.
If the plural method ([[get_xs]]) is called, we fetch all items if they haven't 
been fetched before.
If the singular method ([[get_x]]) is called, we check for the request in the 
cache, otherwise we fetch it.
Each request can specify that Canvas should include extra data.
We don't want to lose data, so when making a new call, we first check what data 
has been fetched, so that we never lose data from the cache.

To be able to handle caching, we need attributes to keep track of the cache and 
if we've fetched all objects.
Even if we've fetched all objects, there might be new objects added at times.
So periodically, we must refetch all objects even if we've previously fetched 
them---but only when a sufficient amount of time has passed.
So we'll let the [[_all_fetched]] attribute be a [[datetime]] object, or 
[[None]] if it was never fetched.
<<construct [[attr_name]] cache attributes in [[self]]>>=
setattr(self, f"{self.attr_name}_cache", cache)
setattr(self, f"{self.attr_name}_all_fetched", None)
@

In all [[get_attr]] requests, it's the positional arguments ([[*args]]) that 
identify what to get.
The keyword arguments ([[**kwargs]]) specify additional options.
However, in most cases the [[*args]] will only contain one element, and that is 
an ID.
<<notes in [[CacheGetMethods]] doc>>=
We assume that the first positional argument is the ID of the object to fetch.
This must be the same as the `.id` attribute of an object (`obj.id`).
@

This allows us to specify how the cache is structured.
We'll let the cache be a dictionary where the key is the ID of the object.
The value will be a tuple of the object and the keyword arguments used to fetch 
it.
For example:
\begin{minted}{text}
{
  1: (obj1, kwargs1),
  2: (obj2, kwargs2),
  ...
}
\end{minted}
<<return cached result or fetch from [[get_attr]]>>=
attr_cache = getattr(self, f"{self.attr_name}_cache")

<<let [[id]] be the ID of the object to fetch>>

try:
  obj, prev_kwargs = attr_cache[id]
except KeyError:
  obj = None
  prev_kwargs = {}

if obj and (must_update(prev_kwargs, kwargs) or outdated(obj)):
  obj = None

if not obj:
  obj = get_attr(self, *args, **kwargs)
  attr_cache[obj.id] = (obj, kwargs)

return obj
@

We already saw [[must_update]] above.
That one focuses on the keyword arguments.
We'll return to the [[outdated]] function later, that one determines from the 
object itself if it needs updating.

The [[get_*]] methods all take either an ID or an object as argument.
If it's an object, then we can get the ID from that object.
<<let [[id]] be the ID of the object to fetch>>=
try:
  obj = args[0]
  id = obj.id
except IndexError:
  raise TypeError(f"{singular_name}() missing 1 required positional "
                  f"argument: 'id'")
except AttributeError:
  if isinstance(obj, int):
    id = obj
  else:
    raise TypeError(f"{singular_name}() argument 1 must be int or "
                    f"Canvas object, not {type(obj)}")
@

Now, let's turn to the plural method.
We have the obvious case that we must fetch all if we haven't fetched all 
before.
But after this it gets more interesting.
If we have fetched all, we must check if the previous [[kwargs]] are a superset 
of the new [[kwargs]].
If not, we must fetch all again with the extended [[kwargs]].
However, even if we can reuse the cache, we must check each object if it 
requires updating.
For instance, if it's a submission and the grade is not P, then we must update 
it.
<<return cached result or fetch from [[get_attrs]]>>=
attr_cache = getattr(self, f"{selt.attr_name}_cache")
attr_all_fetched = getattr(self, f"{self.attr_name}_all_fetched")

if attr_all_fetched:
  for _, prev_kwargs in attr_cache.values():
    if must_update(prev_kwargs, kwargs):
      attr_all_fetched = None
      break

if not attr_all_fetched:
  <<fetch all and populate [[attr_cache]]>>
  <<yield all objects in [[attr_cache]]>>

<<yield all objects in [[attr_cache]], update individual entries if needed>>
@

To fetch all again, we must merge the keyword arguments.
This is done with the [[merge_kwargs]] function.
Then we must add each object to the cache.
<<fetch all and populate [[attr_cache]]>>=
union_kwargs = merge_kwargs(
  [kwargs for _, kwargs in attr_cache.values()].append(kwargs))

for obj in get_attrs(self, *args, **union_kwargs):
  old_obj = attr_cache.get(obj.id, None)
  <<update [[obj]] with cache from [[old_obj]]>>
  attr_cache[obj.id] = (obj, union_kwargs)

setattr(self, f"{self.attr_name}_all_fetched", datetime.now())
attr_all_fetched = getattr(self, f"{self.attr_name}_all_fetched")
@

Finally, when we want to return all the objects, we will yield them instead.
It's more efficient to use a generator in this case, as that would make us 
update when (if) needed.
When we update an object, we should use the same keyword arguments as specified 
in the cache---not the requested ones---because these will, at this point, be 
the largest possible set of keyword arguments.
<<yield all objects in [[attr_cache]], update individual entries if needed>>=
for obj, obj_kwargs in attr_cache.values():
  if outdated(obj):
    obj = get_attr(self, obj.id, **obj_kwargs)
  yield obj
<<yield all objects in [[attr_cache]]>>=
for obj, _ in attr_cache.values():
  yield obj
@

\subsection{Copy cache to new object}

When we update all objects, we want to keep the caches of every old object.
Otherwise, whenever we update all objects we lose all caches further down the 
hierarchy.
When we construct a new object, we want to copy the cache from the old object.

We can do this by finding all cache-related attributes and copying them.
The problem is that we don't know what attributes an object has caches for.
So we'll do some pattern matching on the attribute names.
We'll look for attributes that end with [[_cache]] and [[_all_fetched]].
<<update [[obj]] with cache from [[old_obj]]>>=
for attr_name in dir(old_obj):
  if attr_name.endswith("_cache") or attr_name.endswith("_all_fetched"):
    setattr(obj, attr_name, getattr(old_obj, attr_name))
@

\subsection{Testing outdated objects}

Now we'll deal with the [[outdated]] function.
We simply test different attributes of the object.
If we find values indicating that we want to refresh it, we return [[True]].
<<function [[outdated]] to test if an object is outdated>>=
def outdated(obj):
  """Returns True if the object obj is outdated"""
  <<test if [[obj]] is outdated, return True if so>>
  return False
@

The obvious case is the grade on a submission.
We've discussed that above.
<<test if [[obj]] is outdated, return True if so>>=
try:
  if obj.grade not in NOREFRESH_GRADES:
    return True
except AttributeError:
  pass
@

Instinctively, we might want to use all passing grades as the grades that don't 
need refreshing.
However, even if a student has gotten a B, they might want to improve their 
grade.
So the only grades that we should use are passing grades that can't be 
improved.
<<constants>>=
NOREFRESH_GRADES = ["A", "P", "P+", "complete"]
@

Another thing that we can do is to periodically reset the [[_all_fetched]] 
flag.
If we set it to [[None]], then we'll fetch all objects again.
So we can check this value to see if a sufficient amount of time has passed for 
us to reset it.
Note, however, that for this case we shouldn't return [[True]] or [[False]], 
since it's not the object itself that is outdated.
We don't need to refetch this object, just for it to refetch its children.
<<test if [[obj]] is outdated, return True if so>>=
for attr_name in dir(obj):
  <<reset [[_all_fetched]] if necessary>>
@

We want to periodically reset the [[_all_fetched]] date so that we periodically 
try to refetch all data.
This interval will be different for different attributes.
But we add a default of 7 days.
<<reset [[_all_fetched]] if necessary>>=
<<if statements for resetting [[_all_fetched]] for various attributes>>
elif attr_name.endswith("_all_fetched"):
  if not getattr(obj, attr_name):
    continue
  elif datetime.now() - getattr(obj, attr_name) > timedelta(days=7):
    setattr(obj, attr_name, None)
@

We don't want them to refresh at the same time, so we'll need to have the 
intervals coprime.
The default 7 is a prime, so everything will be coprime with it.

Students can be added every now and then.
So it will be useful to refetch them quite often.
For instance, they're added at the beginning of the course, might fail to 
register and get removed, then readded when they're registered.
Also, when a student reregister for the course, that might happen at any time.
So a rather short interval is useful.
<<if statements for resetting [[_all_fetched]] for various attributes>>=
if attr_name == "user_all_fetched":
  if datetime.now() - getattr(obj, attr_name) > timedelta(days=2):
    setattr(obj, attr_name, None)
@


The list of courses changes whenever new courses are created that we have 
access to.
This usually happens well in advance, so we could have a rather long 
time-to-live on the courses cache.
<<construct TTLCache for courses>>=
self.cache = cachetools.TTLCache(ttl=timedelta(days=30), timer=datetime.now)
@

Now, let's construct the decorator for the [[Canvas]] class to cache 
[[get_courses]] and [[get_course]].


\subsection{Caching submissions}

For the results, we can construct something more specific.
Results that we're interested in are submissions.
We can only get submission from an assignment object.
We can either get all submissions, or one specific submission if we specify the 
user.
<<functions>>=
def make_assignment_submissions_cacheable():
  def cache_submissions(cls):
    """Class decorator for cacheable get_submission, get_submissions methods"""
    <<decorator body for caching assignment submissions>>
    return cls

  canvasapi.assignment.Assignment = \
    cache_submissions(canvasapi.assignment.Assignment)
@

Then we can write the decorator as follows.
We need to add a cache attribute in the constructor, so we must decorate the 
constructor.
The we must decorate both [[get_submission]] and [[get_submissions]].
<<decorator body for caching assignment submissions>>=
old_constructor = cls.__init__

@functools.wraps(cls.__init__)
def new_init(*args, **kwargs):
  <<extend class constructor for decorators>>
  old_constructor(*args, *kwargs)

cls.__init__ = new_init

get_submission = cls.get_submission

@functools.wraps(cls.get_submission)
def new_get_submission(self, user, **kwargs):
  <<return submission of user>>

cls.get_submission = new_get_submission

get_submissions = cls.get_submissions

@functools.wraps(cls.get_submissions)
def new_get_submissions(self, **kwargs):
  <<return a list of all submissions>>

cls.get_submissions = new_get_submissions
@

We decorate the method to get a specific submission, [[get_submission]].
This way we can cache the submissions of users who have passed.
Then we always return up-to-date submissions of students who are expected to 
submit.
For this, we first need a cache attribute.
<<extend class constructor for decorators>>=
args[0].__cache = {}
@

Now we can treat how we get an individual submission.
<<return submission of user>>=
if isinstance(user, User):
  uid = user.id
elif isinstance(user, int):
  uid = user
else:
  raise TypeError(f"user must be User or int")

submission = None

if "include" in kwargs:
  to_include = set(kwargs["include"])
else:
  to_include = set()

if uid in self.__cache:
  submission, included = self.__cache[uid]
  if not set(included).issubset(to_include):
    submission = None
    to_include |= set(included)

if not submission or submission.grade not in ["A", "B", "C", "D", "E", "P"]:
  submission = get_submission(self, user, include=list(to_include))
  self.__cache[uid] = (submission, to_include)

return submission
@

Now we can deal with [[get_submissions]].
As we might call [[get_submission]] before any [[get_submissions]], we cannot 
rely on the cache as a check.
We introduce a new attribute.
<<extend class constructor for decorators>>=
args[0].__all_fetched = False
@ Now we can check if this is set or not.
When we fetch, we want to include any data that was previously included.
<<return a list of all submissions>>=
if "include" in kwargs:
  to_include = set(kwargs["include"])
else:
  to_include = set()

if self.__all_fetched:
  for submission, included in self.__cache.values():
    if not to_include.issubset(included) or \
       submission.grade not in ["A", "B", "C", "D", "E", "P"]:
      self.get_submission(submission.user_id, include=list(to_include))
else:
  for _, included in self.__cache.values():
    to_include |= included

  for submission in get_submissions(self, **kwargs):
    self.__cache[submission.user_id] = submission

return self.__cache.values()
@

