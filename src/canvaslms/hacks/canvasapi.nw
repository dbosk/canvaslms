\chapter{Hackish improvements to the \texttt{canvasapi} module}

In this module we provide some decorators for the classes in the 
\texttt{canvasapi} package.
We automatically apply all decorators upon import, so
\begin{minted}{python}
import canvaslms.hacks.canvasapi
\end{minted}
would apply all decorators defined herein to the already defined classes in the 
\texttt{canvasapi} package.

We do this as follows:
<<canvasapi.py>>=
"""A module that modifies the classes of the canvasapi package"""

from canvasapi.assignment import Assignment
from canvasapi.user import User
import functools
import importlib
import inspect
import sys

<<functions>>

# Loads all hacks
this_module = sys.modules[__name__]

# automatically execute all functions in this module
for _, function in inspect.getmembers(this_module, inspect.isfunction):
  function()
@


\section{Make classes comparable and hashable}

Since none of the classes in [[canvasapi]] defines the [[__eq__]] method, they 
all use the default which uses [[is]].
However, in many cases, it makes more sense to actually compare what the 
objects represent.
Consider two [[User]] objects that represent the same user (the same Canvas 
ID), then they should be considered equal, even if the objects themselves are 
different.
<<define decorator for comparable Canvas objects>>=
def canvas_comparable(cls):
  def is_equal(self, other):
    """Tests if Canvas objects self and other refer to the same object"""
    return type(self) == type(other) and self.id == other.id

  cls.__eq__ = is_equal
  return cls
@

The same applies for the hashable property.
A [[User]] object represents a fixed user that never changes, so we can use the 
type and Canvas ID to hash objects.
<<define decorator for hashable Canvas objects>>=
def canvas_hashable(cls):
  def canvas_hash(self):
    """Returns a hash suitable for Canvas objects"""
    return hash(type(self)) ^ hash(self.id)

  cls.__hash__ = canvas_hash
  return cls
@

Adding these two, will allow us to put these objects into sets, for instance.
We sum it up in a function that can be run automatically when including this 
module.
<<functions>>=
def make_classes_comparable():
  """Improves the classes by adding __eq__ and __hash__ methods"""
  <<define decorator for comparable Canvas objects>>
  <<define decorator for hashable Canvas objects>>
  <<improve eq method for classes>>
@

We want to do this for several classes.
<<improve eq method for classes>>=
# classes to improve in each module
CANVASAPI_CLASSES = {
  "assignment": ["Assignment", "AssignmentGroup"],
  "submission": ["Submission"],
  "user": ["User"]
}
@

We then want to load all the relevant modules given above.
<<improve eq method for classes>>=
canvasapi_modules = {}

# import all modules
for module_name in CANVASAPI_CLASSES:
  canvasapi_modules[module_name] = \
    importlib.import_module(f"canvasapi.{module_name}")
@

Finally, we can go through all the modules and extract their members.
For each member, we check if it's a member to decorate, if so, we apply the 
decorators~[[canvas_comparable]] and [[canvas_hashable]] to it.
<<improve eq method for classes>>=
for module_name, module in canvasapi_modules.items():
  module_members = inspect.getmembers(module)
  for obj_name, obj in module_members:
    if obj_name in CANVASAPI_CLASSES[module_name]:
      canvas_comparable(obj)
      canvas_hashable(obj)
@


\section{Cacheable Canvas objects}

We would like certain methods in certain Canvas objects to be cached.
Particularly, methods that return objects that rarely change should be 
cacheable.
For instance, [[canvas.get_courses()]] returns a list of courses.
This list changes rarely (up to four times per year), so it's results can and 
should be cached.
The list of students changes usually only once in the beginning of the course.
Results on the other hand changes during a course.
However, once a student receives a pass, the result will not change again.
We will use the [[cachetools]] package to provide suitable caching decorators 
for the [[canvasapi]] classes' methods.
This means that we can construct quite complex cache policies.


\subsection{Caching submissions}

For the results, we can construct something more specific.
Results that we're interested in are submissions.
We can only get submission from an assignment object.
We can either get all submissions, or one specific submission if we specify the 
user.
<<functions>>=
def make_assignment_submissions_cacheable():
  def cache_submissions(cls):
    """Class decorator for cacheable get_submission, get_submissions methods"""
    <<decorator body for caching assignment submissions>>
    return cls

  Assignment = cache_submissions(Assignment)
@

Then we can write the decorator as follows.
We need to add a cache attribute in the constructor, so we must decorate the 
constructor.
The we must decorate both [[get_submission]] and [[get_submissions]].
<<decorator body for caching assignment submissions>>=
@functools.wraps(cls.__init__)
def new_init(*args. *kwargs):
  <<extend class constructor for decorators>>
  cls.__init__(*args, *kwargs)

cls.__init__ = new_init

@functools.wraps(cls.get_submission)
def new_get_submission(self, user, *kwargs):
  get_submission = cls.get_submission
  <<return submission of user>>

cls.get_submission = new_get_submission

@functools.wraps(cls.get_submissions)
def new_get_submissions(self, *kwargs):
  get_submissions = cls.get_submissions
  <<return a list of all submissions>>

cls.get_submissions = new_get_submissions
@

We decorate the method to get a specific submission, [[get_submission]].
This way we can cache the submissions of users who have passed.
Then we always return up-to-date submissions of students who are expected to 
submit.
For this, we first need a cache attribute.
<<extend class constructor for decorators>>=
args[0].__cache = {}
@

Now we can treat how we get an individual submission.
<<return submission of user>>=
if isinstance(user, User):
  uid = user.id
elif isinstance(user, int):
  uid = user
else:
  raise TypeError(f"user must be User or int")

submission = None

if "include" in kwargs:
  to_include = set(kwargs["include"])
else:
  to_include = set()

if uid in self.__cache:
  submission, included = self.__cache[uid]
  if not set(included).issubset(to_include):
    submission = None
    to_include |= set(included)

if not submission or submission.grade not in ["A", "B", "C", "D", "E", "P"]:
  submission = get_submission(self, user, include=list(to_include))
  self.__cache[uid] = (submission, to_include)

return submission
@

Now we can deal with [[get_submissions]].
As we might call [[get_submission]] before any [[get_submissions]], we cannot 
rely on the cache as a check.
We introduce a new attribute.
<<extend class constructor for decorators>>=
args[0].__all_fetched = False
@ Now we can check if this is set or not.
When we fetch, we want to include any data that was previously included.
<<return a list of all submissions>>=
if "include" in kwargs:
  to_include = set(kwargs["include"])
else:
  to_include = set()

if self.__all_fetched:
  for submission, included in self.__cache.values():
    if not to_include.issubset(included) or \
       submission.grade not in ["A", "B", "C", "D", "E", "P"]:
      self.get_submission(submission.user_id, include=list(to_include))
else:
  for _, included in self.__cache.values():
    to_include |= included

  for submission in get_submissions(self, *kwargs):
    self.__cache[submissions.user] = submission

return self.__cache.values()
@
