\section{Conjunctive P/F grading, the \texttt{participation} module}

This module implements conjunctive P/F grading for participation-based
assignments.
It's useful when students must complete \emph{all} assignments in a group to
pass, where each assignment is graded as complete/incomplete or 100/0.

As an example, consider a course where students pass by participating in
seminars and completing reflections:
\begin{minted}{text}
$ canvaslms assignments list -c vetcyb25h -A "^Participation INL1" \
  | cut -f 1-3
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on literature reviews
DA2215 HT25 (vetcyb25h)	Participation INL1	Overview of Science in Security
DA2215 HT25 (vetcyb25h)	Participation INL1	How to Design Computer Security Experiments
DA2215 HT25 (vetcyb25h)	Participation INL1	How do you know it's secure? Passwords
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension, literature review: Of passwords and people
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Graphical Passwords: Learning from the First Twelve Years
DA2215 HT25 (vetcyb25h)	Participation INL1	Achieving Rigor in Literature Reviews  Insights from Qualitative Data Analysis and Tool-Support
DA2215 HT25 (vetcyb25h)	Participation INL1	Live seminar 13/11 at 13:15
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Of Passwords and People, Measuring the Effect of Password-Composition Policies
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Can long passwords be secure and usable?
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Why phishing works
DA2215 HT25 (vetcyb25h)	Participation INL1	Live seminar 6/11 at 15:15
DA2215 HT25 (vetcyb25h)	Participation INL1	The RSA and ElGamal cryptosystems
DA2215 HT25 (vetcyb25h)	Participation INL1	On the Security of EIGamal Based Encryption
DA2215 HT25 (vetcyb25h)	Participation INL1	Stealing Keys from PCs using a Radio: Cheap Electromagnetic Attacks on Windowed Exponentiation
DA2215 HT25 (vetcyb25h)	Participation INL1	Timing Analysis of Keystrokes and Timing Attacks on SSH
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on the use of models, part I
DA2215 HT25 (vetcyb25h)	Participation INL1	Theorem proving: 1. Introduction
DA2215 HT25 (vetcyb25h)	Participation INL1	Theorem proving: 2. Formal methods and Interactive Theorem Proving
DA2215 HT25 (vetcyb25h)	Participation INL1	Theorem proving: 4. Examples for what can be verified with Interactive Theorem Provers
DA2215 HT25 (vetcyb25h)	Participation INL1	Theorem proving: 5. Limitations of Interactive Theorem Proving and Conclusion
DA2215 HT25 (vetcyb25h)	Participation INL1	Model checking: algorithmic verification and debugging
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on the use of models, part II
DA2215 HT25 (vetcyb25h)	Participation INL1	Live seminar 28/11  at 10:15
DA2215 HT25 (vetcyb25h)	Participation INL1	Dos and Don'ts of Machine Learning in Computer Security
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on the use of statistics
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Why Johnny can't encrypt
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Comparing the Usability of Cryptographic APIs
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on qualitative methods
DA2215 HT25 (vetcyb25h)	Participation INL1	SoK: Science, Security and the Elusive Goal of Security as a Scientific Pursuit
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on Science in Security
DA2215 HT25 (vetcyb25h)	Participation INL1	Live seminar 12/12 at 12:15
DA2215 HT25 (vetcyb25h)	Participation INL1	Tor: The Second-Generation Onion Router
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Users get routed: traffic correlation on tor by realistic adversaries
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension:  Shadow: Running Tor in a Box for Accurate and Efficient Experimentation
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Website Fingerprinting with Website Oracles
DA2215 HT25 (vetcyb25h)	Participation INL1	Comprehension: Online Website Fingerprinting: Evaluating Website Fingerprinting Attacks on Tor in the Real World
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on the use of models, part III
DA2215 HT25 (vetcyb25h)	Participation INL1	Live seminar 3/12 at 12:15
DA2215 HT25 (vetcyb25h)	Participation INL1	Reflection on inferences, experiments and measurements
\end{minted}
The exact assignments and names might change though.
But that's fine.
The grading system remains the same, we have the following grades:
\begin{minted}{text}
$ canvaslms submissions list -c vetcyb25h -A "^Participation INL1" \
  | cut -f 4 | sort -u

100
complete
incomplete
\end{minted}
We want all assignments to have either complete or 100 to get a passing grade.
Otherwise the student gets an F.

\subsection{Grading logic: conjunctive P/F}

This module implements what we call \emph{conjunctive P/F grading}.
Let's contrast this with other approaches to understand what makes it unique:
\begin{description}
\item[conjunctavg] All assignments must pass, and A--E grades are averaged.
  Here we have no A--E grades, only complete/incomplete or 100/empty.
\item[disjunctmax] At least one assignment must pass (disjunctive), and we take
  the best grade.
  Here \emph{all} assignments must pass (conjunctive), and the only possible
  grades are P or F.
\end{description}

The grading rule is simple: if \emph{all} participation assignments have a
passing grade, the student passes.
If \emph{any} assignment is missing or has an incomplete grade, the student
fails.

\subsection{Module structure}

We follow the standard module structure: a [[summarize_group]] function that
iterates over users and delegates to a [[summarize]] helper function.
<<[[participation.py]]>>=
"""
<<module doc>>
"""
import datetime as dt
from canvaslms.cli import results
from canvasapi.exceptions import ResourceDoesNotExist

<<helper functions>>

def summarize_group(assignments_list, users_list):
  """
  Summarizes participation assignments using conjunctive P/F grading.
  All assignments must have 'complete' or '100' for P, otherwise F.
  """
  for user in users_list:
    grade, grade_date, graders = summarize(user, assignments_list)
    yield [user, grade, grade_date, *graders]
@

<<module doc>>=
Summarizes participation assignments using conjunctive P/F grading.
All assignments must have 'complete' or '100' for P, otherwise F.
@

\subsection{What counts as passing?}

A grade is considered passing if it is either:
\begin{itemize}
\item [[complete]] (case-insensitive, so [[Complete]] or [[COMPLETE]] also work)
\item [[100]] (a numeric grade indicating full completion)
\end{itemize}

Anything else---including [[incomplete]], [[None]], or a missing
submission---counts as not passing.
<<helper functions>>=
def is_passing_grade(grade):
  """
  Returns True if the grade indicates passing (complete or 100).
  """
  if grade is None:
    return False
  if isinstance(grade, str):
    if grade.casefold() == "complete":
      return True
    if grade == "100":
      return True
  return False
@

\subsection{Summarizing a student's participation}

The [[summarize]] function iterates through all assignments and checks whether
each one has a passing grade.
We collect dates and graders along the way.
<<helper functions>>=
def summarize(user, assignments_list):
  """
  Extracts user's submissions for all participation assignments.
  Returns (grade, date, graders) where grade is P if all passed, F otherwise.
  """
  passed = []
  dates = []
  graders = []

  for assignment in assignments_list:
    <<get submission for assignment>>
    <<check if grade is passing>>
    <<add graders to [[graders]] list>>
    <<add date to [[dates]] list>>

  <<determine final grade>>

  return (final_grade, final_date, graders)
@

For each assignment, we attempt to fetch the student's submission.
If the submission doesn't exist (which can happen in rare cases), we treat it
as not passing.
<<get submission for assignment>>=
try:
  submission = assignment.get_submission(user,
                                        include=["submission_history"])
except ResourceDoesNotExist:
  passed.append(False)
  continue

submission.assignment = assignment
@

We extract the grade from the submission and check whether it's passing.
<<check if grade is passing>>=
grade = submission.grade
passed.append(is_passing_grade(grade))
@

We collect all graders from the submission history.
This ensures we credit everyone who participated in the grading process, not
just the last person to grade.
<<add graders to [[graders]] list>>=
graders += results.all_graders(submission)
@

For the date, we prefer the submission date but fall back to the grading date
if no submission was made (for example, oral presentations where the student
didn't submit anything).
<<add date to [[dates]] list>>=
grade_date = submission.submitted_at or submission.graded_at
if grade_date:
  grade_date = dt.date.fromisoformat(grade_date.split("T")[0])
  dates.append(grade_date)
@

\subsection{Determining the final grade}

The final grade is P if \emph{all} assignments passed, F otherwise.
If there are no dates (meaning the student has no activity at all), we return
[[None]] for both grade and date.
<<determine final grade>>=
if dates:
  final_date = max(dates)
  if all(passed):
    final_grade = "P"
  else:
    final_grade = "F"
else:
  final_date = None
  final_grade = None
@
