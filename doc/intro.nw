\chapter{Introduction}
\label{chap:introduction}

This is the documentation of the [[canvaslms]] Python package and the
[[canvaslms]] command.
It provides a command-line interface for Canvas LMS, designed in the style of
Git with hierarchical subcommands and output formats suitable for POSIX tools.

The goal is to make it easy to automate common teaching tasks: grading
assignments, managing course content, analysing quiz results, and exporting
grades for institutional systems like LADOK\@.


\section{Installation}

The command comes as a PyPI package.
It can be installed by running:
\begin{minted}{bash}
pipx install canvaslms           # modern way (recommended)
python3 -m pip install canvaslms # traditional way
\end{minted}

For additional features, install with optional extras (requires Python 3.9+):
\begin{minted}{bash}
pipx install canvaslms[llm,diff]
\end{minted}
The [[llm]] extra enables AI-powered quiz analysis summaries, and the [[diff]]
extra provides improved diffing when comparing assignment versions.

Then you can use \mintinline{bash}|canvaslms -h| for further usage
instructions.

Some subcommands use the [[pandoc]] command\footnote{%
  URL: \url{https://pandoc.org/installing.html}.
} for converting between document formats.
You will have to install that command manually on your system.


\section{Design philosophy}
\label{sec:design-philosophy}

The design of [[canvaslms]] follows three core principles that make it
powerful for automation while remaining easy to use interactively.

\subsection{POSIX-first output}

All listing commands output tab-separated values (TSV) by default.
This makes the output directly usable with standard Unix tools like [[cut]],
[[awk]], [[sort]], and [[grep]].

For example, to count the number of assignments per assignment group:
\begin{minted}{bash}
canvaslms assignments -c "prgi25" | cut -f 2 | sort | uniq -c
\end{minted}
\begin{pycode}
import subprocess
result = subprocess.run(
    "canvaslms assignments -c prgi25 | cut -f 2 | sort | uniq -c",
    shell=True, capture_output=True, text=True
)
print(r"\begin{verbatim}")
print(result.stdout.strip())
print(r"\end{verbatim}")
\end{pycode}

The delimiter can be changed with \mintinline{bash}|-d| if needed:
\begin{minted}{bash}
canvaslms courses -d ","  # comma-separated for CSV import
\end{minted}

\subsection{Git-style subcommand structure}

Commands are organized hierarchically, following the pattern familiar from
Git.
Top-level commands like [[assignments]] and [[submissions]] have subcommands
for different operations:
\begin{minted}{bash}
canvaslms assignments list      # list assignments
canvaslms assignments view      # view assignment details
canvaslms assignments set-dates # modify dates
canvaslms assignments edit      # edit content
\end{minted}

Many commands default to the most common operation (usually [[list]]), so
these two commands are equivalent:
\begin{minted}{bash}
canvaslms assignments -c "prgi25"
canvaslms assignments list -c "prgi25"
\end{minted}

\subsection{Regex-based filtering}

All selection options accept regular expressions for flexible matching.
This applies to courses (\mintinline{bash}|-c|), assignments
(\mintinline{bash}|-a|), users (\mintinline{bash}|-u|), and more.

Patterns match against multiple attributes:
\begin{description}
\item[Courses] Match on course name, course code, or Canvas ID
\item[Assignments] Match on assignment name or Canvas ID
\item[Users] Match on name, login ID, integration ID, or Canvas ID
\end{description}

Multiple filters combine with AND logic.
For example, to find assignments in assignment group [[KAL1]] that are also
in a module matching [[Excel]]:
\begin{minted}{bash}
canvaslms assignments -c "prgi25" -A "KAL1" -M "Excel"
\end{minted}
\begin{pycode}
import subprocess
result = subprocess.run(
    ["canvaslms", "assignments", "-c", "prgi25", "-A", "KAL1", "-M", "Excel"],
    capture_output=True, text=True
)
print(r"\begin{verbatim}")
print(result.stdout.strip() if result.stdout.strip() else "(no matching assignments)")
print(r"\end{verbatim}")
\end{pycode}


\section{Getting started}
\label{sec:getting-started}

\subsection{Authentication}

Before using [[canvaslms]], you need to authenticate with your Canvas server.
Run the login command and follow the interactive prompts:
\begin{minted}{bash}
canvaslms login
\end{minted}

This will guide you to:
\begin{enumerate}
\item Enter your Canvas server hostname (e.g., \texttt{canvas.kth.se})
\item Generate an access token in Canvas (Settings â†’ Access Tokens)
\item Securely store your credentials using the system keyring
\end{enumerate}

Alternatively, you can set environment variables for use in scripts or CI/CD:
\begin{minted}{bash}
export CANVAS_SERVER="canvas.kth.se"
export CANVAS_TOKEN="your-access-token"
\end{minted}

\subsection{Exploring your courses}

Start by listing your courses:
\begin{minted}{bash}
canvaslms courses
\end{minted}

By default, this shows only current courses.
Use \mintinline{bash}|-a| to include past courses:
\begin{minted}{bash}
canvaslms courses -a  # all courses, including ended ones
\end{minted}

Filter with a regex pattern to find specific courses:
\begin{minted}{bash}
canvaslms courses "prgi"
\end{minted}
For example, this might output:
\begin{pycode}
import subprocess
result = subprocess.run(
    ["canvaslms", "courses", "prgi"],
    capture_output=True, text=True
)
print(r"\begin{verbatim}")
print(result.stdout.strip())
print(r"\end{verbatim}")
\end{pycode}

\subsection{Listing assignments}

Once you know your course, you can list assignments.
The output shows the course, assignment group, assignment name, due date,
unlock date, and lock date:
\begin{minted}{bash}
canvaslms assignments -c "prgi25"
canvaslms assignments list -c "prgi25"  # equivalent
\end{minted}
For example:
\begin{pycode}
import subprocess
result = subprocess.run(
    ["canvaslms", "assignments", "-c", "prgi25"],
    capture_output=True, text=True
)
# Show first few lines as example
lines = result.stdout.strip().split('\n')[:5]
print(r"\begin{verbatim}")
for line in lines:
    print(line)
if len(result.stdout.strip().split('\n')) > 5:
    print("...")
print(r"\end{verbatim}")
\end{pycode}

You can filter by assignment group with \mintinline{bash}|-A|:
\begin{minted}{bash}
canvaslms assignments -c "prgi25" -A "LAB1"
\end{minted}
\begin{pycode}
import subprocess
result = subprocess.run(
    ["canvaslms", "assignments", "-c", "prgi25", "-A", "LAB1"],
    capture_output=True, text=True
)
print(r"\begin{verbatim}")
print(result.stdout.strip() if result.stdout.strip() else "(no matching assignments)")
print(r"\end{verbatim}")
\end{pycode}

Or filter across multiple assignment groups using a regex pattern:
\begin{minted}{bash}
canvaslms assignments -c "prgi25" -A "LAB[123]"
\end{minted}
\begin{pycode}
import subprocess
result = subprocess.run(
    ["canvaslms", "assignments", "-c", "prgi25", "-A", "LAB[123]"],
    capture_output=True, text=True
)
lines = result.stdout.strip().split('\n') if result.stdout.strip() else []
print(r"\begin{verbatim}")
if lines:
    for line in lines[:6]:
        print(line)
    if len(lines) > 6:
        print("...")
else:
    print("(no matching assignments)")
print(r"\end{verbatim}")
\end{pycode}

You can also filter by assignment name with \mintinline{bash}|-a|:
\begin{minted}{bash}
canvaslms assignments -c "prgi25" -a "redovisn"
\end{minted}
\begin{pycode}
import subprocess
result = subprocess.run(
    ["canvaslms", "assignments", "-c", "prgi25", "-a", "redovisn"],
    capture_output=True, text=True
)
print(r"\begin{verbatim}")
print(result.stdout.strip() if result.stdout.strip() else "(no matching assignments)")
print(r"\end{verbatim}")
\end{pycode}

To list only assignments with ungraded submissions:
\begin{minted}{bash}
canvaslms assignments -c "prgi25" -U
\end{minted}

\subsection{Listing modules}

Courses are often organized into modules.
You can list them with:
\begin{minted}{bash}
canvaslms modules -c "prgi25"
canvaslms modules list -c "prgi25"  # equivalent
\end{minted}
\begin{pycode}
import subprocess
result = subprocess.run(
    ["canvaslms", "modules", "-c", "prgi25"],
    capture_output=True, text=True
)
lines = result.stdout.strip().split('\n')[:8]
print(r"\begin{verbatim}")
for line in lines:
    print(line)
if len(result.stdout.strip().split('\n')) > 8:
    print("...")
print(r"\end{verbatim}")
\end{pycode}


\section{Command overview}
\label{sec:command-overview}

This section provides a brief overview of all commands.
Detailed documentation for each command appears in later chapters.

\subsection{Course and user management}

\begin{description}
\item[\texttt{courses}] List and filter courses by name, code, or ID\@.
  Supports showing LADOK integration IDs for institutional integration.

\item[\texttt{users}] List users in courses with filtering by role
  (\mintinline{bash}|-s| students, \mintinline{bash}|-a| assistants) and
  group.
  Outputs include Canvas ID, login ID, integration ID, name, and email.
\end{description}

\subsection{Assignment and submission management}

\begin{description}
\item[\texttt{assignments list}] List assignments with filtering by name,
  assignment group, module, or ungraded status.

\item[\texttt{assignments view}] Display detailed assignment information
  including description (converted to Markdown) and rubric.

\item[\texttt{assignments set-dates}] Modify due dates, unlock dates, and
  lock dates for assignments.
  Supports human-readable date formats.

\item[\texttt{assignments edit}] Edit assignment content interactively or
  from a Markdown file with YAML front matter.

\item[\texttt{submissions list}] List submissions with filtering by
  assignment, user, group, or grading status.

\item[\texttt{submissions view}] Display detailed submission information
  including attachments, comments, and history.

\item[\texttt{submissions grade}] Set grades and comments programmatically.
  Also opens SpeedGrader for interactive grading.
  (Also available as the [[grade]] command for backwards compatibility.)
\end{description}

\subsection{Content management}

\begin{description}
\item[\texttt{pages list}] List wiki pages in a course.

\item[\texttt{pages view}] Display page content with optional YAML front
  matter for the export-edit-import workflow.

\item[\texttt{pages edit}] Edit page content interactively or from a
  Markdown file.

\item[\texttt{modules list}] List course modules with unlock dates and
  sequential progress requirements.

\item[\texttt{modules view}] Display module contents including all items
  and completion requirements.

\item[\texttt{discussions}] Create and manage announcements and discussion
  topics.
  Supports scheduling announcements for future dates.
\end{description}

\subsection{Calendar and events}

\begin{description}
\item[\texttt{calendar list}] List calendar events with time filtering.

\item[\texttt{calendar view}] Display detailed event information.

\item[\texttt{calendar create}] Create new calendar events with flexible
  date parsing and recurring event support.
\end{description}

\subsection{Analysis and export}

\begin{description}
\item[\texttt{quizzes list}] List quizzes and surveys in a course.

\item[\texttt{quizzes analyse}] Analyse quiz/survey responses with
  statistical summaries.
  Supports AI-generated summaries for qualitative responses (requires
  [[canvaslms[llm]]]).

\item[\texttt{results}] Export grades in LADOK-compatible format.
  Can show either grades or missing assignments blocking grades.
\end{description}

\subsection{System commands}

\begin{description}
\item[\texttt{cache clear}] Clear the Canvas object cache.
  Useful when data seems stale.

\item[\texttt{cache clear-attachments}] Clear downloaded submission
  attachments cache.
\end{description}


\section{Workflow examples}
\label{sec:workflow-examples}

This section demonstrates common workflows through complete, executable
examples.
Each example is provided as a script that can be tangled from this document
and run directly.

\subsection{Setup phase: First-time exploration}

When you first start using [[canvaslms]], you'll want to explore your courses
and understand what's available.
This script helps you get oriented:

<<examples/explore-courses.sh>>=
#!/bin/bash
# explore-courses.sh - First-time exploration of your Canvas courses

# List all current courses with their LADOK IDs
echo "=== Your Current Courses ==="
canvaslms courses -l

# For each course, show some basic stats
echo ""
echo "=== Course Details ==="
for course in $(canvaslms courses | cut -f 3); do
    echo "--- $course ---"
    echo "Students: $(canvaslms users -c "$course" -s 2>/dev/null | wc -l)"
    echo "Assignments: $(canvaslms assignments -c "$course" 2>/dev/null | wc -l)"
    echo "Ungraded: $(canvaslms assignments -c "$course" -U 2>/dev/null | wc -l)"
    echo ""
done
@

The script first lists all courses with their LADOK integration IDs (useful
for results export later), then iterates through each course to show basic
statistics.

As a simpler example, here's how to quickly check the status of a specific
course:
\begin{pycode}
import subprocess

# Get course info
print(r"\begin{verbatim}")
print("=== Course: prgi25 ===")

# Count assignments
result = subprocess.run(
    ["canvaslms", "assignments", "-c", "prgi25"],
    capture_output=True, text=True
)
num_assignments = len(result.stdout.strip().split('\n')) if result.stdout.strip() else 0
print(f"Total assignments: {num_assignments}")

# Count modules
result = subprocess.run(
    ["canvaslms", "modules", "-c", "prgi25"],
    capture_output=True, text=True
)
num_modules = len(result.stdout.strip().split('\n')) if result.stdout.strip() else 0
print(f"Total modules: {num_modules}")

print(r"\end{verbatim}")
\end{pycode}


\subsection{Daily teaching: Finding ungraded work}

A common daily task is checking what needs grading.
This script creates a summary of all ungraded submissions across your courses:

<<examples/list-ungraded.sh>>=
#!/bin/bash
# list-ungraded.sh - Find all ungraded work across courses
#
# Usage: ./list-ungraded.sh [course-pattern]
#
# Examples:
#   ./list-ungraded.sh           # All courses
#   ./list-ungraded.sh "prgi25"  # Only prgi25

COURSE_PATTERN="${1:-.*}"

echo "=== Ungraded Submissions ==="
echo "Course pattern: $COURSE_PATTERN"
echo ""

# Get assignments with ungraded submissions
canvaslms assignments -c "$COURSE_PATTERN" -U | while IFS=$'\t' read -r \
    course group assignment due unlock lock; do

    echo "--- $course: $assignment ---"
    echo "Due: $due"

    # Count ungraded submissions for this assignment
    count=$(canvaslms submissions -c "$course" -a "$assignment" -U \
        2>/dev/null | wc -l)
    echo "Ungraded: $count submissions"
    echo ""
done
@

The script takes an optional course pattern argument, then lists each
assignment that has ungraded submissions along with the count.


\subsection{Daily teaching: Grading based on external criteria}
\label{sec:grading-workflow}

One of the most powerful features of [[canvaslms]] is the ability to grade
students based on external criteria.
This example, adapted from our abstract, grades students who have logged into
an SSH server:

<<examples/grade-ssh-login.sh>>=
#!/bin/bash
# grade-ssh-login.sh - Grade students based on SSH server login
#
# This script checks who has logged into an SSH server and grades
# the corresponding assignments in Canvas.
#
# Usage: ./grade-ssh-login.sh

# Configuration - modify these for your course
COURSE="DD1301"
ASSIGNMENT="(Preparing the terminal|The terminal)"
SSH_SERVER="student-shell.sys.kth.se"
GRADE="P"
MESSAGE="Well done! You successfully logged into the terminal."

# Step 1: Get student list from Canvas
# Format: Canvas_ID <tab> Login_ID <tab> ...
echo "Fetching student list from Canvas..."
canvaslms users -c "$COURSE" -s | cut -f 1,4 > students.csv
echo "Found $(wc -l < students.csv) students"

# Step 2: Get list of users who logged into SSH server
echo "Checking SSH server login history..."
ssh "$SSH_SERVER" last | cut -f 1 -d " " | sort -u > logged-in.csv
echo "Found $(wc -l < logged-in.csv) unique logins"

# Step 3: Grade students who have logged in
echo "Grading matching students..."
graded=0
while IFS=$'\t' read -r canvas_id login_id; do
    if grep -q "^${login_id}$" logged-in.csv; then
        echo "Grading $login_id..."
        canvaslms grade -c "$COURSE" -a "$ASSIGNMENT" \
            -u "$canvas_id" \
            -g "$GRADE" -m "$MESSAGE"
        ((graded++))
    fi
done < students.csv

echo "Graded $graded students"

# Cleanup
rm -f students.csv logged-in.csv
@

\paragraph{How it works.}
The script follows a three-step process:
\begin{enumerate}
\item Extract student Canvas IDs and login IDs from Canvas
\item Query the SSH server for login history
\item Match students and set their grades in Canvas
\end{enumerate}

This pattern generalizes to any external verification: checking Git commits,
verifying completion of online tutorials, or any other automated check.


\subsection{Daily teaching: Content version control}

Wiki pages and announcements can be managed using a Git-like workflow:
export, edit locally, then import back.
This supports version control of course content.

<<examples/export-page.sh>>=
#!/bin/bash
# export-page.sh - Export a Canvas page for local editing
#
# Usage: ./export-page.sh <course> <page-title>
#
# Example:
#   ./export-page.sh "DD1301" "Syllabus"
#   # Edit syllabus.md locally
#   ./import-page.sh "DD1301" syllabus.md

COURSE="${1:?Usage: $0 <course> <page-title>}"
PAGE="${2:?Usage: $0 <course> <page-title>}"

# Create safe filename from page title
FILENAME=$(echo "$PAGE" | tr '[:upper:]' '[:lower:]' | tr ' ' '-').md

# Export page with YAML front matter
echo "Exporting '$PAGE' from '$COURSE' to $FILENAME..."
canvaslms pages view -c "$COURSE" -p "$PAGE" > "$FILENAME"

echo "Done. Edit $FILENAME, then run:"
echo "  canvaslms pages edit -c \"$COURSE\" -p \"$PAGE\" -f $FILENAME"
@

<<examples/import-page.sh>>=
#!/bin/bash
# import-page.sh - Import an edited page back to Canvas
#
# Usage: ./import-page.sh <course> <filename>

COURSE="${1:?Usage: $0 <course> <filename>}"
FILENAME="${2:?Usage: $0 <course> <filename>}"

# Extract page title from YAML front matter
PAGE=$(grep "^title:" "$FILENAME" | sed 's/^title: *//' | tr -d '"')

if [ -z "$PAGE" ]; then
    echo "Error: Could not find 'title:' in YAML front matter"
    exit 1
fi

echo "Importing '$FILENAME' as '$PAGE' to '$COURSE'..."
canvaslms pages edit -c "$COURSE" -p "$PAGE" -f "$FILENAME"
echo "Done."
@

The YAML front matter in the exported file preserves metadata like the page
title, allowing the import script to update the correct page.


\subsection{End of course: Survey analysis}

At the end of a course, you often want to analyse student evaluations.
The [[quizzes analyse]] command provides statistical summaries and optional
AI-generated synthesis of qualitative responses.

<<examples/analyse-survey.sh>>=
#!/bin/bash
# analyse-survey.sh - Analyse course evaluation survey
#
# Usage: ./analyse-survey.sh <csv-file> [--ai]
#
# Get the CSV from Canvas:
# 1. Go to the quiz/survey in Canvas
# 2. Click "Student Analysis" under Quiz Statistics
# 3. Download the CSV file

CSV_FILE="${1:?Usage: $0 <csv-file> [--ai]}"
AI_FLAG="${2:-}"

if [ ! -f "$CSV_FILE" ]; then
    echo "Error: File '$CSV_FILE' not found"
    exit 1
fi

echo "=== Survey Analysis ==="
echo "File: $CSV_FILE"
echo ""

if [ "$AI_FLAG" = "--ai" ]; then
    echo "Generating analysis with AI summaries..."
    canvaslms quizzes analyse --csv "$CSV_FILE" --ai
else
    echo "Generating statistical analysis..."
    canvaslms quizzes analyse --csv "$CSV_FILE"
fi
@

For quantitative questions (ratings, multiple choice), the analysis shows:
\begin{itemize}
\item Mean, median, and standard deviation
\item Frequency distributions
\item Response counts
\end{itemize}

For qualitative questions (free text), it shows all responses and
optionally generates AI summaries identifying common themes.


\subsection{End of course: LADOK export}

When it's time to report grades to LADOK, the [[results]] command exports
grades in the required format.

<<examples/export-ladok.sh>>=
#!/bin/bash
# export-ladok.sh - Export grades for LADOK reporting
#
# Usage: ./export-ladok.sh <course> <assignment-group>
#
# Example:
#   ./export-ladok.sh "DD1301" "Labs"

COURSE="${1:?Usage: $0 <course> <assignment-group>}"
ASSIGNMENT_GROUP="${2:?Usage: $0 <course> <assignment-group>}"

DATE=$(date +%Y-%m-%d)
OUTPUT="ladok-export-${DATE}.csv"

echo "=== LADOK Export ==="
echo "Course: $COURSE"
echo "Assignment group: $ASSIGNMENT_GROUP"
echo ""

# First, check for students with incomplete work
echo "Checking for incomplete submissions..."
INCOMPLETE=$(canvaslms results -c "$COURSE" -A "$ASSIGNMENT_GROUP" \
    --missing 2>/dev/null | wc -l)

if [ "$INCOMPLETE" -gt 0 ]; then
    echo "Warning: $INCOMPLETE students have incomplete work:"
    canvaslms results -c "$COURSE" -A "$ASSIGNMENT_GROUP" --missing
    echo ""
    read -p "Continue with export? [y/N] " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Export passing grades
echo "Exporting passing grades to $OUTPUT..."
canvaslms results -c "$COURSE" -A "$ASSIGNMENT_GROUP" > "$OUTPUT"

echo "Exported $(wc -l < "$OUTPUT") grades"
echo "File: $OUTPUT"
@

The script first checks for students with incomplete work (using
\mintinline{bash}|--missing|), then exports the grades.
This prevents accidentally missing students when reporting to LADOK\@.


\subsection{Advanced: Bulk operations with regex}

For advanced automation, regex patterns enable powerful bulk operations.
This example updates due dates for all labs in a specific module:

<<examples/update-dates.sh>>=
#!/bin/bash
# update-dates.sh - Bulk update assignment due dates
#
# Usage: ./update-dates.sh <course> <assignment-pattern> <due-date>
#
# Examples:
#   ./update-dates.sh "DD1301" "Lab.*" "2024-12-20 23:59"
#   ./update-dates.sh "DD1301" ".*" --clear  # Clear all due dates

COURSE="${1:?Usage: $0 <course> <assignment-pattern> <due-date>}"
PATTERN="${2:?Usage: $0 <course> <assignment-pattern> <due-date>}"
DUE_DATE="${3:?Usage: $0 <course> <assignment-pattern> <due-date>}"

echo "=== Bulk Date Update ==="
echo "Course: $COURSE"
echo "Pattern: $PATTERN"
echo "New due date: $DUE_DATE"
echo ""

# Show what will be affected
echo "Assignments matching pattern:"
canvaslms assignments -c "$COURSE" -a "$PATTERN"
echo ""

read -p "Update these assignments? [y/N] " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
fi

# Perform the update
if [ "$DUE_DATE" = "--clear" ]; then
    canvaslms assignments set-dates -c "$COURSE" -a "$PATTERN" --due clear
else
    canvaslms assignments set-dates -c "$COURSE" -a "$PATTERN" --due "$DUE_DATE"
fi

echo "Done."
@

The script shows what will be affected before making changes, providing a
safety check for bulk operations.


\section{Advanced topics}
\label{sec:advanced-topics}

\subsection{Caching, performance, and verbosity}

The [[canvaslms]] command maintains an encrypted cache of Canvas data between
invocations.
This significantly speeds up repeated operations by avoiding redundant API
calls.

The cache is automatically invalidated when data changes, but you can
manually clear it if needed:
\begin{minted}{bash}
canvaslms cache clear              # Clear object cache
canvaslms cache clear-attachments  # Clear downloaded attachments
\end{minted}

\paragraph{Understanding what the cache is doing.}
To see what [[canvaslms]] is doing behind the scenes---especially regarding
caching and API calls---use the verbosity flags.
Control output verbosity with \mintinline{bash}|-v| and \mintinline{bash}|-q|:
\begin{description}
\item[\texttt{-qqq}] Silent (no output except errors)
\item[\texttt{-qq}] Critical errors only
\item[\texttt{-q}] Errors only
\item[(default)] Warnings and above
\item[\texttt{-v}] Informational messages
\item[\texttt{-vv}] Debug messages (shows cache hits/misses)
\item[\texttt{-vvv}] All library debug messages (shows API calls)
\end{description}

These flags can be combined: \mintinline{bash}|-vv -q| equals
\mintinline{bash}|-v|.

The \mintinline{bash}|-vv| flag is particularly useful for understanding
caching behaviour: it shows when data is loaded from cache versus fetched
from the API\@.

\subsection{Environment variables}

For scripting and CI/CD, the following environment variables override
configuration:
\begin{description}
\item[\texttt{CANVAS\_SERVER}] Canvas server hostname
  (e.g., \texttt{canvas.kth.se})
\item[\texttt{CANVAS\_TOKEN}] Canvas API access token
\end{description}

Example CI/CD configuration:
\begin{minted}{yaml}
# .github/workflows/grade.yml
env:
  CANVAS_SERVER: ${{ secrets.CANVAS_SERVER }}
  CANVAS_TOKEN: ${{ secrets.CANVAS_TOKEN }}
\end{minted}

\subsection{Error handling in scripts}

When no results match a filter, [[canvaslms]] raises an error and exits
with code 1.
Use \mintinline{bash}|-q| to suppress error messages in scripts:
\begin{minted}{bash}
# Silent failure if no ungraded submissions
if canvaslms submissions -c "$COURSE" -U -q 2>/dev/null; then
    echo "There are ungraded submissions"
else
    echo "All caught up!"
fi
\end{minted}


\section{For contributors}
\label{sec:for-contributors}

This section describes the internal architecture for those who want to
extend [[canvaslms]] with new commands.

\subsection{Module structure}

The package is divided into modules.
The [[cli]] module provides the base for the command and it uses the
other modules.
There is a module for each subcommand.

Each such module must provide a function [[add_command]] which takes
an [[argparse]] (sub)parser as an argument:
\begin{minted}{python}
def add_command(subp):
    command_parser = subp.add_parser("command", ...)
    command_parser.set_defaults(func=command_function)
\end{minted}

The subcommand must add the function [[command_function]] which
takes three arguments:
\begin{enumerate}
  \item [[config]], a dictionary with the configuration data.
  \item [[canvas]], a [[canvasapi]] object.
  \item [[args]], the arguments parsed by [[argparse]].
\end{enumerate}

Something along these lines:
\begin{minted}{python}
def command_function(config, canvas, args):
    # process the args and do its thing
\end{minted}

\subsection{Option reuse pattern}

To maintain consistency across commands, use the
[[add_XXX_option]]/[[process_XXX_option]] pattern:
\begin{minted}{python}
def add_course_option(parser, required=False):
    """Adds -c/--course option to parser"""
    parser.add_argument("-c", "--course", required=required, ...)

def process_course_option(canvas, args):
    """Processes -c option, returns filtered course list"""
    courses = filter_courses(canvas, args.course)
    if not courses:
        raise EmptyListError("No courses found")
    return courses
\end{minted}

This pattern is used throughout the codebase for courses, assignments,
users, and other common filters.
